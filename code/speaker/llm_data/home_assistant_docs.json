[
    {
        "url": "https://www.home-assistant.io/docs/configuration/customizing-devices/",
        "content": "You can use the UI to change the entity ID and friendly name of supported entities. To do this: If your entity is not supported, or you cannot customize what you need via this method, please see below for more options. By default, all of your devices will be visible and have a default icon determined by their domain. You can customize the look and feel of your front page by altering some of these parameters. This can be done by overriding attributes of specific entities. Name of the entity as displayed in the UI. URL to use as picture for entity. Any icon from Material Design Icons. Prefix name with mdi:, ie mdi:home. Note: Newer icons may not yet be available in the current Home Assistant release. For switches with an assumed state two buttons are shown (turn off, turn on) instead of a switch. By setting assumed_state to false you will get the default switch icon. Sets the class of the device, changing the device state and icon that is displayed on the UI (see below). It does not set the unit_of_measurement. Defines the units of measurement, if any. This will also influence the graphical presentation in the history visualization as continuous value. Sensors with missing unit_of_measurement are showing as discrete values. Sets the initial state for automations, on or off. Device class is currently supported by the following platforms: If you implement customize, customize_domain, or customize_glob you must make sure it is done inside of homeassistant: or it will fail. Home Assistant offers a service to reload the core configuration while Home Assistant is running. This allows you to change your customize section and see your changes being applied without having to restart Home Assistant. To reload customizations, navigate to Developer Tools > YAML and then press the “Reload Location & Customizations” button. If you don’t see this, enable Advanced Mode on your user profile page first. You can also use the Quick bar, and choose “Reload Location & Customizations”. Alternatively, you can reload via service call. Navigate to Developer Tools > Services tab, select homeassistant.reload_core_config from the dropdown and press the “Call Service” button."
    },
    {
        "url": "https://www.home-assistant.io/docs/scripts/#variables",
        "content": "Scripts are a sequence of actionsActions are used in several places in Home Assistant. As part of a script or automation, actions define what is going to happen once a trigger is activated. In scripts, an action is called sequence.\n[Learn more] that Home Assistant will execute. Scripts are available as an entity through the standalone Script integration but can also be embedded in automationsAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] and Alexa/Amazon Echo configurations. When the script is executed within an automation the trigger variable is available. See Available-Trigger-Data. The script syntax basic structure is a list of key/value maps that contain actions. If a script contains only 1 action, the wrapping list can be omitted. All actions support an optional alias. The most important one is the action to call a service. This can be done in various ways. For all the different possibilities, have a look at the service calls page. Scripts may also use a shortcut syntax for activating scenes instead of calling the scene.turn_on service. The variables action allows you to set/override variables that will be accessible by templates in actions after it. See also script variables for how to define variables accessible in the entire script. Variables can be templated. Variables have local scope. This means that if a variable is changed in a nested sequence block, that change will not be visible in an outer sequence block. Inside the if sequence the variables action will only alter the people variable for that sequence. While executing a script you can add a condition in the main sequence to stop further execution. When a condition does not return true, the script will stop executing. There are many different conditions which are documented at the conditions page. The condition action only stops executing the current sequence block. When it is used inside a repeat action, only the current iteration of the repeat loop will stop. When it is used inside a choose action, only the actions within that choose will stop. condition can also be a list of conditions and execution will then only continue if ALL conditions return true. Delays are useful for temporarily suspending your script and start it at a later moment. We support different syntaxes for a delay as shown below. All forms accept templates. These actions allow a script to wait for entities in the system to be in a certain state as specified by a template, or some event to happen as expressed by one or more triggers. This action evaluates the template, and if true, the script will continue. If not, then it will wait until it is true. The template is re-evaluated whenever an entity ID that it references changes state. If you use non-deterministic functions like now() in the template it will not be continuously re-evaluated, but only when an entity ID that is referenced is changed. If you need to periodically re-evaluate the template, reference a sensor from the Time and Date integration that will update minutely or daily. This action can use the same triggers that are available in an automation’s trigger section. See Automation Trigger. The script will continue whenever any of the triggers fires. All previously defined trigger variables, variables and script variables are passed to the trigger. With both types of waits it is possible to set a timeout after which the script will continue its execution if the condition/event is not satisfied. Timeout has the same syntax as delay, and like delay, also accepts templates. You can also get the script to abort after the timeout by using optional continue_on_timeout: false. Without continue_on_timeout: false the script will always continue since the default for continue_on_timeout is true. After each time a wait completes, either because the condition was met, the event happened, or the timeout expired, the variable wait will be created/updated to indicate the result. This can be used to take different actions based on whether or not the condition was met, or to use more than one wait sequentially while implementing a single timeout overall. This action allows you to fire an event. Events can be used for many things. It could trigger an automation or indicate to another integration that something is happening. For instance, in the below example it is used to create an entry in the logbook. You can also use event_data to fire an event with custom data. This could be used to pass data to another script awaiting\nan event trigger. The event_data accepts templates. The following automation example shows how to raise a custom event called event_light_state_changed with entity_id as the event data. The action part could be inside a script or an automation. The following automation example shows how to capture the custom event event_light_state_changed with an Event Automation Trigger, and retrieve corresponding entity_id that was passed as the event trigger data, see Available-Trigger-Data for more details. This action allows you to repeat a sequence of other actions. Nesting is fully supported.\nThere are three ways to control how many times the sequence will be run. This form accepts a count value. The value may be specified by a template, in which case\nthe template is rendered when the repeat step is reached. This repeat form accepts a list of items to iterate over. The list of items\ncan be a pre-defined list, or a list created by a template. The sequence is ran for each item in the list, and current item in the\niteration is available as repeat.item. The following example will turn a list of lights: Other types are accepted as list items, for example, each item can be a\ntemplate, or even an mapping of key/value pairs. This form accepts a list of conditions (see conditions page for available options) that are evaluated before each time the sequence\nis run. The sequence will be run as long as the condition(s) evaluate to true. The while also accepts a shorthand notation of a template condition.\nFor example: This form accepts a list of conditions that are evaluated after each time the sequence\nis run. Therefore the sequence will always run at least once. The sequence will be run\nuntil the condition(s) evaluate to true. until also accepts a shorthand notation of a template condition.\nFor example: A variable named repeat is defined within the repeat action (i.e., it is available inside sequence, while & until.)\nIt contains the following fields: This action allow you to conditionally (if) run a sequence of actions (then)\nand optionally supports running other sequence when the condition didn’t\npass (else). This action supports nesting, however, if you find yourself using nested if-then\nactions in the else part, you may want to consider using\nchoose instead. This action allows you to select a sequence of other actions from a list of sequences.\nNesting is fully supported. Each sequence is paired with a list of conditions. (See the conditions page for available options and how multiple conditions are handled.) The first sequence whose conditions are all true will be run.\nAn optional default sequence can be included which will be run only if none of the sequences from the list are run. An optional alias can be added to each of the sequences, excluding the default sequence. The choose action can be used like an “if/then/elseif/then…/else” statement. The first conditions/sequence pair is like the “if/then”, and can be used just by itself. Or additional pairs can be added, each of which is like an “elif/then”. And lastly, a default can be added, which would be like the “else.” conditions also accepts a shorthand notation of a template condition.\nFor example: More choose can be used together. This is the case of an IF-IF. The following example shows how a single automation can control entities that aren’t related to each other but have in common the same trigger. When the sun goes below the horizon, the porch and garden lights must turn on. If someone is watching the TV in the living room, there is a high chance that someone is in that room, therefore the living room lights have to turn on too. The same concept applies to the studio room. By default, all sequences of actions in Home Assistant run sequentially. This\nmeans the next action is started after the current action has been completed. This is not always needed, for example, if the sequence of actions doesn’t rely\non each other and order doesn’t matter. For those cases, the parallel action\ncan be used to run the actions in the sequence in parallel, meaning all\nthe actions are started at the same time. The following example shows sending messages out at the same time (in parallel): It is also possible to run a group of actions sequentially inside the parallel\nactions. The example below demonstrates that: Running actions in parallel can be helpful in many cases, but use it with\ncaution and only if you need it. There are some caveats (see below) when using parallel actions. While it sounds attractive to parallelize, most of the time, just the regular\nsequential actions will work just fine. Some of the caveats of running actions in parallel: It is possible to halt a script sequence at any point and return script responses\nusing the stop action. The stop action takes a text as input explaining the reason for halting the\nsequence. This text will be logged and shows up in the automations and\nscript traces. stop can be useful to halt a script halfway through a sequence when,\nfor example, a condition is not met. To return a response from a script, use the response_variable option. This\noption expects the name of the variable that contains the data to return. The\nresponse data must contains a mapping of key/value pairs. There is also an error option, to indicate we are stopping because of\nan unexpected error. It stops the sequence as well, but marks the automation\nor script as failed to run. By default, a sequence of actions will be halted when one of the actions in\nthat sequence encounters an error. The automation or script will be halted,\nan error is logged, and the automation or script run is marked as errored. Sometimes these errors are expected, for example, because you know the service\nyou call can be problematic at times, and it doesn’t matter if it fails.\nYou can set continue_on_error for those cases on such an action. The continue_on_error is available on all actions and is set to\nfalse. You can set it to true if you’d like to continue the action\nsequence, regardless of whether that action encounters an error. The example below shows the continue_on_error set on the first action. If\nit encounters an error; it will continue to the next action. Please note that continue_on_error will not suppress/ignore misconfiguration\nor errors that Home Assistant does not handle. Every individual action in a sequence can be disabled, without removing it.\nTo do so, add enabled: false to the action. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/authentication/#your-account-profile",
        "content": "The authentication system secures access to Home Assistant. You are greeted with a log in screen, asking you for user name and password. When you start Home Assistant for the first time, the owner user account is created. This account has some special privileges and can: Once you’re logged in, you can see the details of your account at the Profile page by clicking on the circular at the very bottom of the sidebar. You can: Make sure to choose a secure password! At some time in the future, you will probably want to access Home Assistant from outside your local network. This means you are also exposed to random black-hats trying to do the same. Treat the password like the key to your house. As an extra level of security, you can turn on multi-factor authentication. Home Assistant provides several ways to authenticate. See the Auth providers section. If you’re seeing authentication failures from 127.0.0.1 and you’re using the nmap device tracker, you should exclude the Home Assistant IP from being scanned. Under the new authentication system you’ll see the following warning logged when the legacy API password is supplied, but not configured in Home Assistant: If you see this, you need to add an api_password to your http: configuration. If you see the following, then this is a message for integration developers, to tell them they need to update how they authenticate to Home Assistant. As an end user you don’t need to do anything: If you lose the password associated with the owner account, you need to start a new onboarding process. You have to use a domain name, not IP address, to remote access Home Assistant otherwise you will get Error: invalid client id or redirect url error on the login form. However, you can use the IP address to access Home Assistant in your home network. This is because we only allow an IP address as a client ID when your IP address is an internal network address (e.g., 192.168.0.1) or loopback address (e.g., 127.0.0.1). If you don’t have a valid domain name for your Home Assistant instance, you can modify the hosts file on your computer to fake one.\nOn Linux edit the /etc/hosts file, and add following entry: Replace 12.34.56.78 with your Home Assistant’s public IP address. This will allow you to open Home Assistant at http://homeassistant.home:8123/ Some ad blocking software, such as Wipr, also blocks WebSockets. If you’re stuck on the Loading data screen, try disabling your ad blocker. If you were using the authentication system before 0.77, you’d likely have auth: and auth_providers: defined. You’ll need to remove these and let Home Assistant handle it automatically."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/",
        "content": "While you can configure most of Home Assistant directly from the user interface under Settings, some parts need you to edit configuration.yaml. This file contains integrationsIntegrations connect and integrate Home Assistant with your devices, services, and more.\n[Learn more] to be loaded along with their configurations. Throughout the documentation you will find snippets that you can add to your configuration file to enable specific functionality. If you run into trouble while configuring Home Assistant, refer to the configuration troubleshooting page and the configuration.yaml examples. The easiest option to edit configuration.yaml is to use the Studio Code Server add-on. This add-on runs VS Code, which offers live syntax checking and auto-fill of various Home Assistant entities. See here for details. If unavailable on your system, use File Editor add-on instead. Again, details can be found here. If you prefer to use a file editor on your computer, use the Samba add-on to access the files as a network share. More details can be found here. The path to your configuration directory can be found in the Home Assistant frontendThe frontend is a necessary component for the UI, it is also where you can define your themes.[Learn more] by going to Settings > System > Repairs > System information from the top right menu  Right under the version you are running, you will find what path Home Assistant has loaded the configuration from.\n If you use Home Assistant Container, you can find configuration.yaml in the config folder that you mounted in your container. If you use Home Assistant Operating System, you can find configuration.yaml in the /config folder of the installation. If you use Home Assistant Core, you can find configuration.yaml in the config folder passed to the hass command (default is ~/.homeassistant). Most integrations in Home Assistant that do not interact with devicesA device is a model representing a physical or logical unit that contains entities.\n or servicesA service carries out one specific task, for example: turn on the light in the living room. A service has targets and data and can be called by actions, a dashboard, or via voice command.\n[Learn more] can reload changes made to their configuration in configuration.yaml. To do this, go to Developer Tools > YAML and scroll down to the YAML configuration reloading section (alternatively, hit “c” anywhere in the UI and search for it). If you can’t see your integration listed there, you will need to restart Home Assistant for changes to take effect. To test any changes to your configuration files from the command line, check out the common tasks for operating system, supervised, container, core for how to do that. Configuration changes can also be tested using the UI by navigating to Developer Tools > YAML and clicking “Check Configuration”. For the button to be visible, you must enable “Advanced Mode” on your User Profile. The preferred way of migrating to a new system is by making a backup. Once you have created the backup on the old system, you can download it to the system that is running the Home Assistant frontend. When setting up the new system, you may use the backup. Alternatively, you can upload it to your new system using the Upload backup menu option of the Backups menu. Then, a restore of the uploaded backup on the new system concludes the migration. If you run the container or core installation methods, you will need to manually make a backup of your configuration folder. Be aware that some of the files you need start with ., which is hidden by default from both ls (in SSH), in Windows Explorer, and macOS Finder. You’ll need to ensure that you’re viewing all files before you copy them."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/templating/#limited-templates",
        "content": "This is an advanced feature of Home Assistant. You’ll need a basic understanding of: Templating is a powerful feature that allows you to control information going into and out of the system. It is used for: Templating in Home Assistant is powered by the Jinja2 templating engine. This means that we are using their syntax and make some custom Home Assistant variables available to templates during rendering. Jinja2 supports a wide variety of operations: We will not go over the basics of the syntax, as Jinja2 does a great job of this in their templates documentation. The frontend has a template editor tool to help develop and debug templates. Navigate to Developer Tools > Template, create your template in the Template editor and check the results on the right. Templates can get big pretty fast. To keep a clear overview, consider using YAML multiline strings to define your templates: There are a few very important rules to remember when adding templates to YAML: Remembering these simple rules will help save you from many headaches and endless hours of frustration when using automation templates. Jinja supports a set of language extensions that add new functionality to the language.\nTo improve the experience of writing Jinja templates, we have enabled the following\nextensions: You can write reusable Jinja templates by adding them to a custom_templates folder under your\nconfiguration directory. All template files must have the .jinja extension and be less than 5MiB.\nTemplates in this folder will be loaded at startup. To reload the templates without\nrestarting Home Assistant, invoke the homeassistant.reload_custom_templates service. Once the templates are loaded, Jinja includes and imports will work\nusing config/custom_templates as the base directory. For example, you might define a macro in a template in config/custom_templates/formatter.jinja: In your automations, you could then reuse this macro by importing it: Extensions allow templates to access all of the Home Assistant specific states and adds other convenience functions and filters. Templates for some triggers as well as trigger_variables only support a subset of the Home Assistant template extensions. This subset is referred to as “Limited Templates”. Not supported in limited templates. Avoid using states.sensor.temperature.state, instead use states('sensor.temperature'). It is strongly advised to use the states(), is_state(), state_attr() and is_state_attr() as much as possible, to avoid errors and error message when the entity isn’t ready yet (e.g., during Home Assistant startup). The next two statements result in the same value if the state exists. The second one will result in an error if the state does not exist. Print out a list of all the sensor states: Print out a list of all the sensor states sorted by entity_id: Entities that are on: Other state examples: The examples below show the output of a temperature sensor with state 20.001, unit °C and user configured presentation rounding set to 1 decimal. The following example results in the number 20.001: The following example results in the string \"20.0 °C\": The following example result in the string \"20.001 °C\": The following example results in the number 20.0: The following example results in the number 20.001: The following example results in the string \"20.0 °C\": Not supported in limited templates. You can print an attribute with state_attr if state is defined. With strings: List of friendly names: List of lights that are on with a brightness of 255: Not supported in limited templates. The expand function and filter can be used to sort entities and expand groups. It outputs a sorted array of entities with no duplicates. The same thing can also be expressed as a filter: The same thing can also be expressed as a test: A common case is to conditionally return a value based on another value.\nFor example, return a “Yes” or “No” when the light is on or off. This can be written as: Or using a shorter syntax: Additionally, to the above, you can use the iif function/filter, which is\nan immediate if. Syntax: iif(condition, if_true, if_false, if_none) iif returns the value of if_true if the condition is truthy, the value of if_false if it’s falsy and the value of if_none if it’s None.\nAn empty string, an empty mapping or an an empty list, are all falsy, refer to the Python documentation for an in depth explanation. if_true is optional, if it’s omitted True is returned if the condition is truthy.\nif_false is optional, if it’s omitted False is returned if the condition is falsy.\nif_none is optional, if it’s omitted the value of if_false is returned if the condition is None. Examples using iif: The immediate if filter does not short-circuit like you might expect with a typical conditional statement. The if_true, if_false and if_none expressions will all be evaluated and the filter will simply return one of the resulting values. This means you cannot use this filter to prevent executing an expression which would result in an error. For example, if you wanted to select a field from trigger in an automation based on the platform you might go to make this template: trigger.platform == 'event' | iif(trigger.event.data.message, trigger.to_state.state). This won’t work because both expressions will be evaluated and one will fail since the field doesn’t exist. Instead you have to do this trigger.event.data.message if trigger.platform == 'event' else trigger.to_state.state. This form of the expression short-circuits so if the platform is event the expression trigger.to_state.state will never be evaluated and won’t cause an error. now(), relative_time(), today_at(), and utcnow() are not supported in limited templates. now() returns a datetime object that represents the current time in your time zone. utcnow() returns a datetime object of the current time in the UTC timezone. today_at(value) converts a string containing a military time format to a datetime object with today’s date in your time zone. as_datetime() converts a string containing a timestamp, or valid UNIX timestamp, to a datetime object. as_timestamp(value, default) converts datetime object or string to UNIX timestamp. If that fails, returns the default value, or if omitted raises an error. This function can also be used as a filter. as_local() converts datetime object to local time. This function can also be used as a filter. strptime(string, format, default) parses a string based on a format and returns a datetime object. If that fails, it returns the default value or, if omitted, raises an error. relative_time converts datetime object to its human-friendly “age” string. The age can be in second, minute, hour, day, month or year (but only the biggest unit is considered, e.g., if it’s 2 days and 3 hours, “2 days” will be returned). Note that it only works for dates in the past. timedelta returns a timedelta object and accepts the same arguments as the Python datetime.timedelta function – days, seconds, microseconds, milliseconds, minutes, hours, weeks. as_timedelta(string) converts a string to a timedelta object. Expects data in the format DD HH:MM:SS.uuuuuu, DD HH:MM:SS,uuuuuu, or as specified by ISO 8601 (e.g. P4DT1H15M20S which is equivalent to 4 1:15:20) or PostgreSQL’s day-time interval format (e.g. 3 days 04:05:06) This function can also be used as a filter. Filter timestamp_local(default) converts a UNIX timestamp to the ISO format string representation as date/time in your local timezone. If that fails, returns the default value, or if omitted raises an error. If a custom string format is needed in the string, use timestamp_custom instead. Filter timestamp_utc(default) converts a UNIX timestamp to the ISO format string representation representation as date/time in UTC timezone. If that fails, returns the default value, or if omitted raises an error. If a custom string format is needed in the string, use timestamp_custom instead. Filter timestamp_custom(format_string, local=True, default) converts an UNIX timestamp to its string representation based on a custom format, the use of a local timezone is the default. If that fails, returns the default value, or if omitted raises an error. Supports the standard Python time formatting options. UNIX timestamp is the number of seconds that have elapsed since 00:00:00 UTC on 1 January 1970. Therefore, if used as a function’s argument, it can be substituted with a numeric value (int or float). If your template is returning a timestamp that should be displayed in the frontend (e.g., as a sensor entity with device_class: timestamp), you have to ensure that it is the ISO 8601 format (meaning it has the “T” separator between the date and time portion). Otherwise, frontend rendering on macOS and iOS devices will show an error. The following value template would result in such an error: {{ states.sun.sun.last_changed }} => 2023-07-30 20:03:49.253717+00:00 (missing “T” separator) To fix it, enforce the ISO conversion via isoformat(): {{ states.sun.sun.last_changed.isoformat() }} => 2023-07-30T20:03:49.253717+00:00 (contains “T” separator) The to_json filter serializes an object to a JSON string. In some cases, it may be necessary to format a JSON string for use with a webhook, as a parameter for command-line utilities or any number of other applications. This can be complicated in a template, especially when dealing with escaping special characters. Using the to_json filter, this is handled automatically. to_json also accepts boolean arguments for pretty_print, which will pretty print the JSON with a 2-space indent to make it more human-readable, and sort_keys, which will sort the keys of the JSON object, ensuring that the resulting string is consistent for the same input. If you need to generate JSON that will be used by a parser that lacks support for Unicode characters, you can add ensure_ascii=True to have to_json generate Unicode escape sequences in strings. The from_json filter operates similarly, but in the other direction, de-serializing a JSON string back into an object. Conversely, from_json can be used to de-serialize a JSON string back into an object to make it possible to easily extract usable data. Sometimes a template should only return if a value or object is defined, if not, the supplied default value should be returned. This can be useful to validate a JSON payload.\nThe is_defined filter allows to throw an error if a value or object is not defined. Example using is_defined to parse a JSON payload: This will throw an error UndefinedError: 'value_json' is undefined if the JSON payload has no val attribute. Examples: Not supported in limited templates. If only one location is passed in, Home Assistant will measure the distance from home. The closest function and filter will find the closest entity to the Home Assistant location: Find entities closest to a coordinate or another entity. All previous arguments still apply for second argument. Since closest returns a state, we can combine it with distance too. The last argument of the closest function has an implicit expand, and can take any iterable sequence of states or entity IDs, and will expand groups: It will also work as a filter over an iterable group of entities or groups: Jinja provides by default a in operator how return True when one element is in a provided list.\nThe contains test and filter allow you to do the exact opposite and test for a list containing an element. This is particularly useful in select or selectattr filter, as well as to check if a device has a specific attribute, a supported_color_modes, a specific light effect. Some examples: Some of these functions can also be used in a filter. This means they can act as a normal function like this sqrt(2), or as part of a filter like this 2|sqrt. The numeric functions and filters raise an error if the input is not a valid number, optionally a default value can be specified which will be returned instead. The is_number function and filter can be used to check if a value is a valid number. Errors can be caught by the default filter. float(value, default) function will attempt to convert the input to a float. If that fails, returns the default value, or if omitted raises an error. float(default) filter will attempt to convert the input to a float. If that fails, returns the default value, or if omitted raises an error. is_number will return True if the input can be parsed by Python’s float function and the parsed input is not inf or nan, in all other cases returns False. Note that a Python bool will return True but the strings \"True\" and \"False\" will both return False. Can be used as a filter. int(value, default) function is similar to float, but converts to an int instead. Like float, it has a filter form, and an error is raised if the default value is omitted. Fractional part is discarded: int(\"1.5\") is 1. bool(value, default) function converts the value to either true or false.\nThe following values are considered to be true: boolean true, non-zero ints and floats, and the strings \"true\", \"yes\", \"on\", \"enable\", and \"1\" (case-insensitive). false is returned for the opposite values: boolean false, integer or floating-point 0, and the strings \"false\", \"no\", \"off\", \"disable\", and \"0\" (also case-insensitive).\nIf the value is not listed here, the function returns the default value, or if omitted raises an error.\nThis function is intended to be used on states of binary sensors, switches, or similar entities, so its behavior is different from Python’s built-in bool conversion, which would consider e.g. \"on\", \"off\", and \"unknown\" all to be true, but \"\" to be false; if that is desired, use not not value or a similar construct instead.\nLike float and int, bool has a filter form. Using none as the default value is particularly useful in combination with the immediate if filter: it can handle all three possible cases in a single line. log(value, base, default) will take the logarithm of the input. When the base is omitted, it defaults to e - the natural logarithm. If value or base can’t be converted to a float, returns the default value, or if omitted raises an error. Can also be used as a filter. sin(value, default) will return the sine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. cos(value, default) will return the cosine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. tan(value, default) will return the tangent of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. asin(value, default) will return the arcus sine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. acos(value, default) will return the arcus cosine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. atan(value, default) will return the arcus tangent of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. atan2(y, x, default) will return the four quadrant arcus tangent of y / x. If y or x can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. sqrt(value, default) will return the square root of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. max([x, y, ...]) will obtain the largest item in a sequence. Uses the same parameters as the built-in max filter. min([x, y, ...]) will obtain the smallest item in a sequence. Uses the same parameters as the built-in min filter. average([x, y, ...], default) will return the average value of the sequence. If list is empty or contains non-numeric value, returns the default value, or if omitted raises an error. Can be used as a filter. median([x, y, ...], default) will return the median value of the sequence. If list is empty or contains non-numeric value, returns the default value, or if omitted raises an error. Can be used as a filter. statistical_mode([x, y, ...], default) will return the statistical mode value (most frequent occurrence) of the sequence. If the list is empty, it returns the default value, or if omitted raises an error. It can be used as a filter. e mathematical constant, approximately 2.71828. pi mathematical constant, approximately 3.14159. tau mathematical constant, approximately 6.28318. Filter round(precision, method, default) will convert the input to a number and round it to precision decimals. Round has four modes and the default mode (with no mode specified) will round-to-even. If the input value can’t be converted to a float, returns the default value, or if omitted raises an error. Filter value_one|bitwise_and(value_two) perform a bitwise and(&) operation with two values. Filter value_one|bitwise_or(value_two) perform a bitwise or(|) operation with two values. Filter ord will return for a string of length one an integer representing the Unicode code point of the character when the argument is a Unicode object, or the value of the byte when the argument is an 8-bit string. In addition to strings and numbers, Python (and Jinja) supports lists, sets, and dictionaries. To help you with testing these types, you can use the following tests: Note that, in Home Assistant, Jinja has built-in tests for boolean (True/False), callable (any function), float (a number with a decimal), integer (a number without a decimal), iterable (a value that can be iterated over such as a list, set, string, or generator), mapping (mainly dict but also supports other dictionary like types), number (float or int), sequence (a value that can be iterated over and indexed such as list and string), and string. While Jinja natively supports the conversion of an iterable to a list, it does not support conversion to a tuple or set. To help you with using these types, you can use the following functions: Note that, in Home Assistant, to convert a value to a list, a string, an int, or a float, Jinja has built-in functions with names that correspond to each type. These functions are used to process raw value’s in a bytes format to values in a native Python type or vice-versa.\nThe pack and unpack functions can also be used as a filter. They make use of the Python 3 struct library.\nSee: Python struct library documentation Some examples: For more information on regular expressions\nSee: Python regular expression operations The other part of templating is processing incoming data. It allows you to modify incoming data and extract only the data you care about. This will only work for platforms and integrations that mention support for this in their documentation. It depends per integration or platform, but it is common to be able to define a template using the value_template configuration key. When a new value arrives, your template will be rendered while having access to the following values on top of the usual Home Assistant extensions: This means that if the incoming values looks like the sample below: The template for on would be: Nested JSON in a response is supported as well: Just use the “Square bracket notation” to get the value. The following overview contains a couple of options to get the needed values: To evaluate a response, go to Developer Tools > Template, create your output in “Template editor”, and check the result. The MQTT integration relies heavily on templates. Templates are used to transform incoming payloads (value templates) to status updates or incoming service calls (command templates) to payloads that configure the MQTT device. For incoming data a value template translates incoming JSON or raw data to a valid payload.\nIncoming payloads are rendered with possible JSON values, so when rendering the value_json can be used access the attributes in a JSON based payload. Example value template: With given payload: Template {{ value_json.temperature | round(1) }} renders to 21.9. Additional the MQTT entity attributes entity_id, name and this can be used as variables in the template. The this attribute refers to the entity state of the MQTT item. For service calls command templates are defined to format the outgoing MQTT payload to the device. When a service call is executed value can be used to generate the correct payload to the device. Example command template: With given value 21.9 template {\"temperature\": {{ value }} } renders to: Additional the MQTT entity attributes entity_id, name and this can be used as variables in the template. The this attribute refers to the entity state of the MQTT item. If your template uses an entity_id that begins with a number (example: states.device_tracker.2008_gmc) you must use a bracket syntax to avoid errors caused by rendering the entity_id improperly. In the example given, the correct syntax for the device tracker would be: states.device_tracker['2008_gmc'] The default priority of operators is that the filter (|) has priority over everything except brackets. This means that: Would round 10 to 2 decimal places, then divide states('sensor.temperature') by 10 (rounded to 2 decimal places so 10.00). This behavior is maybe not the one expected, but priority rules imply that."
    },
    {
        "url": "https://www.home-assistant.io/docs/energy/faq/",
        "content": "It’s a common mistake to take Power as an Energy value, but the two are not alike. Energy is a quantitative measurement of what it takes to produce work (e.g. heat water) while Power measures the speed at which energy is transferred. Electrical Power is measured in Watts (W) and Electrical Energy is measured in kiloWatt-hour (kWh). Think of this in a parallel to speed and distance: Power is the speed you are going and Energy is the distance driven. Therefore Energy (kiloWatt-hour) is not an average of the Power you are consuming over a given period of time (the unit of the average power would be Watt or kiloWatt again). Energy is the integral (mathematical operation) of the Power function. This difference is very important as you need to use the proper entities in our Energy Panel. Since in Home Assistant, we don’t deal with Power functions but with samples of the power being used, we can’t do the integral (mathematical operation) directly and get the true amount of energy consumed/produced. That said, if you can sample Power values fast enough (every few seconds) you can reliably measure energy transferred through mathematic approximations called Riemann Sum. Home Assistant provides this mathematical operation through the integration. If you are using a 3rd party device (e.g. not reading directly from your utility meter device or from the utility provider cloud service) you need HA to split your energy measurements into 2 (or more) tariffs, in order to track these energy consumptions separately. To accomplish such, you can use the utility_meter integration. With this integration, you define as many tariffs as required (in accordance with your utility provider contract) and HA will be able to differentiate energy consumptions in each of the tariffs. Please note that each utility provider has its own time schedules for peak and off-peak and you are required to create an automation that switches the utility_meter entity from one tariff to the other. If you do not see the Energy panel in the sidebar, make sure you have not removed default_config: from your configuration.yaml. If you have, you will need to add the energy: integration manually. You are trying to add a sensor to the energy dashboard, but it does not appear in the selection list. To find out why the sensor is not showing, check the following points: The sensor must have the appropriate attributes. Check your entity attributes in Developer Tools > States to confirm the following: If any of the attributes are not correct, please open an issue against the integration that provides your sensor, or if you are developing custom template sensors, make sure the templates have the correct settings. The entity must be a sensor. If you are trying to add something from another domain (for example an input_number), then you must first create a template sensor from it. The entity must not have any statistics errors. Go to Developer Tools > Statistics to check your specific entity. If your unit has a listed issue here, you must fix the issue before it can be added to the dashboard."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger#trigger-variables",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/using_blueprints/",
        "content": "Automation blueprints are pre-made automationsAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] that you can easily add to your Home Assistant instance. Each blueprint can be added as many times as you want. Quick links: Automations based on a blueprint need to be configured. What needs to be configured differs by blueprint. Done! If you want to revisit the configuration values, go to Settings > Automations & Scenes > Blueprints. Home Assistant can import blueprints from the Home Assistant forums, GitHub, and GitHub gists. To import a blueprint, first find a blueprint you want to import. If you just want to practice importing, you can use this URL: Go to Settings > Automations & Scenes > Blueprints. Select the blue Import Blueprint button in the bottom right. Enter the URL and select Preview. The blueprint can now be used for creating automations. Blueprints created by the community may go through multiple revisions. Sometimes a user creates a blueprint,\nthe community provides feedback, and new functionality is added. The quickest way to get these changes is by re-importing the blueprint. This will overwrite the blueprint you currently have. Blueprints created by the community may go through multiple revisions. Sometimes a user creates a blueprint,\nthe community provides feedback, and new functionality is added. If you do not want to re-import the blueprint for some reason, you can manually edit\nits YAML content to keep it up to date: The new changes will appear to your existing automations as well. The Home Assistant Community forums have a specific tag for blueprints. This tag is used to collect all blueprints. Visit the Home Assistant forums Using blueprints is nice and easy, but what if you could create that one missing\nblueprint that our community definitely needs? Learn more about blueprints by reading our tutorial on creating a blueprint. When you’re creating automations using blueprints and they don’t appear in the UI, make sure that you add back automation: !include automations.yaml from the default configuration to your configuration.yaml."
    },
    {
        "url": "https://www.home-assistant.io/docs/authentication/providers/#configuring-auth-providers",
        "content": "When you log in, an auth provider checks your credentials to make sure you are an authorized user. Home Assistant automatically configures the standard auth providers so you don’t need to specify auth_providers in your configuration.yaml file unless you are configuring more than one. Specifying auth_providers will disable all auth providers that are not listed, so you could reduce your security or create difficulties logging in if it is not configured correctly. If you decide to use trusted_networks as your auth_provider there won’t be a way to authenticate for a device outside of your listed trusted network. To overcome this ensure you add the default auth_provider with type: homeassistant back in manually. This will then present you with the default auth login screen when trusted network authentication fails as expected from outside your LAN. Authentication providers are configured in your configuration.yaml under the homeassistant: block.\nIf you are moving configuration to packages, this particular configuration must stay within ‘configuration.yaml’. See Issue 16441 in the warning block at the bottom of this page. You can supply more than one, for example: This is the default auth provider. The first user created is designated as the owner and can create other users. User details are stored in the [your config]/.storage directory. All passwords are stored hashed and with a salt, making it almost impossible for an attacker to figure out the password even if they have access to the file. Users can be managed in Home Assistant by the owner. Go to the configuration panel and click on Users. This is the entry in configuration.yaml for Home Assistant auth: If you don’t specify any auth_providers section in the configuration.yaml file then this provider will be set up automatically. The trusted networks auth provider defines a range of IP addresses for which no authentication will be required (also known as “allowlisting”). For example, you can allowlist your local network so you won’t be prompted for a password if you access Home Assistant from inside your home. When you log in from one of these networks, you will be asked which user account to use and won’t need to enter a password. The multi-factor authentication module will not participate in the login process if you are using this auth provider. You cannot trust a network that you are using in any trusted_proxies. The trusted_networks authentication will fail with the message: Your computer is not allowed Here is an example in configuration.yaml to set up Trusted Networks: A list of IP addresses or an IP network you want allowlisted. It accepts both IPv4 and IPv6 IP address or network You can also assign which users are available to select when user access login page from certain IP address or network. List of user ids available to select on this IP address or network. You can bypass login page if you have only one user available for selection. First note, for trusted_users configuration you need to use user id, which you can find through Settings -> People -> View User Detail. The trusted_users configuration will not validate the existence of the user, so please make sure you have put in the correct user id by yourself. Second note, a trusted user with an IPv6 address must put the IPv6 address in quotes as shown. In above example, if user try to access Home Assistant from 192.168.0.1, they will have only one user available to choose. They will have two users available if access from 192.168.0.38 (from 192.168.0.0/24 network). If they access from 192.168.10.0/24 network, they can choose from all available users (non-system and active users). Specially, you can use group: GROUP_ID to assign all users in certain user group to be available to choose. Group and users can be mix and match. This is a feature to allow you to bring back some of the experience before the user system was implemented. You can directly jump to the main page if you are accessing from trusted networks, the allow_bypass_login is on, and you have ONLY ONE available user to choose from in the login form. If you allow bypass login then your cookie will not be stored and every time you refresh the page in Home Assistant a new login will be created. This is because bypassing the login does not give you the option to save the login. Assuming you have only the owner created though onboarding process, no other users ever created. The above example configuration will allow you directly access Home Assistant main page if you access from your internal network (192.168.0.0/24) or from localhost (127.0.0.1). If you get a login abort error, then you can change to use Home Assistant Authentication Provider to login, if you access your Home Assistant instance from outside network. The command line auth provider executes a configurable shell command to perform user authentication. Two environment variables, username and password, are passed to the command. Access is granted when the command exits successfully (with exit code 0). This provider can be used to integrate Home Assistant with arbitrary external authentication services, from plaintext databases over LDAP to RADIUS. A compatible script for LDAP authentication is this one, for instance. Please note, this will only work when using the Home Assistant Core installation type. Here is a configuration example: When meta: true is set in the auth provider’s configuration, your command can write some variables to standard output to populate the user account created in Home Assistant with additional data. These variables have to be printed in the form: Leading and trailing whitespace, as well as lines starting with # are ignored. The following variables are supported. More may be added in the future. Stderr is not read at all and just passed through to that of the Home Assistant process, hence you can use it for status messages or suchlike."
    },
    {
        "url": "https://www.home-assistant.io/docs/tools/hass/",
        "content": "The command-line part of Home Assistant is hass."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/splitting_configuration/",
        "content": "So you’ve been using Home Assistant for a while now and your configuration.yaml file brings people to tears or you simply want to start off with the distributed approach, here’s how to split the configuration.yaml into more manageable (read: humanly readable) pieces. First off, several community members have sanitized (read: without API keys/passwords etc) versions of their configurations available for viewing, you can see a list of them here. As commenting code doesn’t always happen, please read on for the details. Now despite the logical assumption that the configuration.yaml will be replaced by this process it will in fact remain, albeit in a much less cluttered form. In this lighter version we will still need what could be called the core snippet: Note that each line after homeassistant: is indented two (2) spaces. Since the configuration files in Home Assistant are based on the YAML language, indentation and spacing are important. Also note that seemingly strange entry under customize:. !include customize.yaml is the statement that tells Home Assistant to insert the contents of customize.yaml at that point. This is how we are going to break a monolithic and hard to read file (when it gets big) into more manageable chunks. Now before we start splitting out the different components, let’s look at the other integrations (in our example) that will stay in the base file: As with the core snippet, indentation makes a difference. The integration headers (mqtt:) should be fully left aligned (aka no indent), and the key (sensor:) should be indented two (2) spaces. The list - under the key sensor should be indented another two (2) spaces followed by a single space. The mqtt sensor list contains two (2) configurations containing two (2) keys each. While some of these integrations can technically be moved to a separate file they are so small or “one off’s” where splitting them off is superfluous. Also, you’ll notice the # symbol (hash/pound). This represents a “comment” as far as the commands are interpreted. Put another way, any line prefixed with a # will be ignored. This makes breaking up files for human readability really convenient, not to mention turning off features while leaving the entry intact. Now, lets assume that a blank file has been created in the Home Assistant configuration directory for each of the following: automation.yaml will hold all the automation integration details. zone.yaml will hold the zone integration details and so forth. These files can be called anything but giving them names that match their function will make things easier to keep track of. Inside the base configuration file add the following entries: Nesting !includes (having an !include within a file that is itself !included) will also work. Some integrations support multiple top-level !includes, this includes integrations defining an IoT domain, e.g. light, switch, sensor as well as the automation, script and template integrations, if you give a different label to each one. Configuration for other integrations can instead be split up by using packages. To learn more about packages, see the Packages page. Example of multiple top-level keys for the light platform. where light-groups.yaml might look like: with light-switches.yaml containing: Alright, so we’ve got the single integrations and the include statements in the base file, what goes in those extra files? Let’s look at the device_tracker.yaml file from our example: This small example illustrates how the “split” files work. In this case, we start with two (2) device tracker entries (owntracks and nmap). These files follow “style 1” that is to say a fully left aligned leading entry (- platform: owntracks) followed by the parameter entries indented two (2) spaces. This (large) sensor configuration gives us another example: You’ll notice that this example includes a secondary parameter section (under the steam section) as well as a better example of the way comments can be used to break down files into sections. All of the above can be applied when splitting up files using packages. To\nlearn more about packages, see the Packages page. That about wraps it up. If you have issues checkout home-assistant.log in the configuration directory as well as your indentations. If all else fails, head over to our Discord chat server and ask away. If you have many configuration files, Home Assistant provides a CLI that allows you to see how it interprets them, each installation type has its own section in the common-tasks about this: We offer four advanced options to include whole directories at once. Please note that your files must have the .yaml file extension; .yml is not supported. This will allow you to !include files with .yml extensions from within the .yaml files; without those .yml files being imported by the following commands themselves. These work recursively. As an example using !include_dir_list automation, will include all 6 files shown below: configuration.yaml can be turned into: configuration.yaml automation/presence/automation1.yaml automation/presence/automation2.yaml It is important to note that each file must contain only one entry when using !include_dir_list. configuration.yaml can be turned into: configuration.yaml alexa/LocateIntent.yaml alexa/WhereAreWeIntent.yaml configuration.yaml can be turned into: configuration.yaml automation/presence.yaml It is important to note that when using !include_dir_merge_list, you must include a list in each file (each list item is denoted with a hyphen [-]). Each file may contain one or more entries. configuration.yaml can be turned into: configuration.yaml group/interior.yaml group/exterior.yaml You want to go the advanced route and split your automations, but still want to be able to create automations in the UI?\nIn a chapter above we write about nesting !includes. Here is how we can do that for automations. Using labels like manual or ui allows for using multiple keys in the config: configuration.yaml"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/",
        "content": "Home Assistant contains information about all your devicesA device is a model representing a physical or logical unit that contains entities.\n and servicesA service carries out one specific task, for example: turn on the light in the living room. A service has targets and data and can be called by actions, a dashboard, or via voice command.\n[Learn more]. This information is available for the user in the dashboard and it can be used to trigger automationsAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more]. And that’s fun! Automations in Home Assistant allow you to automatically respond to things that happen. You can turn the lights on at sunset or pause the music when you receive a call. If you are just starting out, we recommend that you start with blueprint automations. These are ready-made automations by the community that you only need to configure. If you have got the hang of blueprints and would like to explore more, it’s time for the next step. But before you start creating automations, you will need to learn about the automation basics."
    },
    {
        "url": "https://www.home-assistant.io/docs/frontend/browsers/",
        "content": "Home Assistant requires a web browser to show the frontend and supports all major modern browsers. We don’t test the web interface against all available browsers but this page tracks different browsers on various operating systems and should help you to pick a browser which works. The “Release” column contains the release number which was tested. This doesn’t mean that older or newer releases will not work. If a browser is listed as working but you are still having problems, it is possible that some add-on or extension may be the problem. Some add-ons or extension are known to cause issue with the frontend, but it’s not possible to test them all. If you are having issues with the frontend displaying correctly, you should disable all your add-ons or extensions and enable them one at a time. At last but not least, consider restarting your browser. We would appreciate if you help to keep this page up-to-date and add feedback. There are reports that devices running with iOS prior to iOS 10, especially old iPads, are having trouble. Devices running iOS 14 beta 5, you will not be able to interact with Home Assistant controls."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#event-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#persistent-notification-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/energy/water/",
        "content": "Home Assistant allows you to track your water usage in the home energy management too. Although water usage is not strictly “energy”, it is still a valuable resource to track and monitor as it is often tightly coupled with energy usage (like gas). Additionally, it can help you reduce your ecological footprint by using less water. Home Assistant will need to know the amount of water that is being consumed to be able to track usage. Several water metering (fluid flow rate sensor device) hardware options are available to do this. Depending on your setup, the required hardware is provided by your public water utility company, or you may need to buy your own. Some hardware with water meters may also provide additional practical functions or sensors, such as valve, for example, for controlling water shutoff, or temperature and pressure (to enable freeze alarms). We have the following integrations available for existing products that can provide information about water usage: There are also products for water usage monitoring that are based on existing common IoT protocol standards: Alternatively, the following shops sell ESPHome-based devices, that use a proximity sensor to detect a rotating magnet in your water meter and use that pulse to count each liter of water used. Alternatively, the following shops sell ESPHome-based devices that use a 3-phase light sensor to detect a rotating disk in your water meter and convert this to the amount of water used in milliliters (ml). Maybe you like to build one yourself? If you manually integrate your sensors, for example, using the MQTT or RESTful integrations: Make sure you set and provide the device_class, state_class, and unit_of_measurement for those sensors. For any of the above-listed options, make sure it actually works with the type of water meter you have before getting one."
    },
    {
        "url": "https://www.home-assistant.io/docs/authentication/providers/",
        "content": "When you log in, an auth provider checks your credentials to make sure you are an authorized user. Home Assistant automatically configures the standard auth providers so you don’t need to specify auth_providers in your configuration.yaml file unless you are configuring more than one. Specifying auth_providers will disable all auth providers that are not listed, so you could reduce your security or create difficulties logging in if it is not configured correctly. If you decide to use trusted_networks as your auth_provider there won’t be a way to authenticate for a device outside of your listed trusted network. To overcome this ensure you add the default auth_provider with type: homeassistant back in manually. This will then present you with the default auth login screen when trusted network authentication fails as expected from outside your LAN. Authentication providers are configured in your configuration.yaml under the homeassistant: block.\nIf you are moving configuration to packages, this particular configuration must stay within ‘configuration.yaml’. See Issue 16441 in the warning block at the bottom of this page. You can supply more than one, for example: This is the default auth provider. The first user created is designated as the owner and can create other users. User details are stored in the [your config]/.storage directory. All passwords are stored hashed and with a salt, making it almost impossible for an attacker to figure out the password even if they have access to the file. Users can be managed in Home Assistant by the owner. Go to the configuration panel and click on Users. This is the entry in configuration.yaml for Home Assistant auth: If you don’t specify any auth_providers section in the configuration.yaml file then this provider will be set up automatically. The trusted networks auth provider defines a range of IP addresses for which no authentication will be required (also known as “allowlisting”). For example, you can allowlist your local network so you won’t be prompted for a password if you access Home Assistant from inside your home. When you log in from one of these networks, you will be asked which user account to use and won’t need to enter a password. The multi-factor authentication module will not participate in the login process if you are using this auth provider. You cannot trust a network that you are using in any trusted_proxies. The trusted_networks authentication will fail with the message: Your computer is not allowed Here is an example in configuration.yaml to set up Trusted Networks: A list of IP addresses or an IP network you want allowlisted. It accepts both IPv4 and IPv6 IP address or network You can also assign which users are available to select when user access login page from certain IP address or network. List of user ids available to select on this IP address or network. You can bypass login page if you have only one user available for selection. First note, for trusted_users configuration you need to use user id, which you can find through Settings -> People -> View User Detail. The trusted_users configuration will not validate the existence of the user, so please make sure you have put in the correct user id by yourself. Second note, a trusted user with an IPv6 address must put the IPv6 address in quotes as shown. In above example, if user try to access Home Assistant from 192.168.0.1, they will have only one user available to choose. They will have two users available if access from 192.168.0.38 (from 192.168.0.0/24 network). If they access from 192.168.10.0/24 network, they can choose from all available users (non-system and active users). Specially, you can use group: GROUP_ID to assign all users in certain user group to be available to choose. Group and users can be mix and match. This is a feature to allow you to bring back some of the experience before the user system was implemented. You can directly jump to the main page if you are accessing from trusted networks, the allow_bypass_login is on, and you have ONLY ONE available user to choose from in the login form. If you allow bypass login then your cookie will not be stored and every time you refresh the page in Home Assistant a new login will be created. This is because bypassing the login does not give you the option to save the login. Assuming you have only the owner created though onboarding process, no other users ever created. The above example configuration will allow you directly access Home Assistant main page if you access from your internal network (192.168.0.0/24) or from localhost (127.0.0.1). If you get a login abort error, then you can change to use Home Assistant Authentication Provider to login, if you access your Home Assistant instance from outside network. The command line auth provider executes a configurable shell command to perform user authentication. Two environment variables, username and password, are passed to the command. Access is granted when the command exits successfully (with exit code 0). This provider can be used to integrate Home Assistant with arbitrary external authentication services, from plaintext databases over LDAP to RADIUS. A compatible script for LDAP authentication is this one, for instance. Please note, this will only work when using the Home Assistant Core installation type. Here is a configuration example: When meta: true is set in the auth provider’s configuration, your command can write some variables to standard output to populate the user account created in Home Assistant with additional data. These variables have to be printed in the form: Leading and trailing whitespace, as well as lines starting with # are ignored. The following variables are supported. More may be added in the future. Stderr is not read at all and just passed through to that of the Home Assistant process, hence you can use it for status messages or suchlike."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/basics/",
        "content": "All automationsAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] are made up of a triggerA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more] and an actionActions are used in several places in Home Assistant. As part of a script or automation, actions define what is going to happen once a trigger is activated. In scripts, an action is called sequence.\n[Learn more]. Optionally combined with a conditionConditions are an optional part of an automation that will prevent an action from firing if they are not met.[Learn more]. Take for example the automation: When Paulus arrives home and it is after sunset: Turn the lights on in the living room. We can break up this automation into the following three parts: The first part is the trigger of the automation rule. Triggers describe eventsAn event is when something happens.[Learn more] that should trigger the automation rule. In this case, it is a person arriving home, which can be observed in Home Assistant using devicesA device is a model representing a physical or logical unit that contains entities.\n/sensorsSensors return information about a thing, for instance the level of water in a tank.[Learn more] by observing the state of Paulus changing from not_home to home. The second part is the condition. Conditions are optional tests that can limit an automation rule to only work in your specific use cases. A condition will test against the current state of the system. This includes the current time, devices, people and other things like the sun. In this case, we only want to act when the sun has set. The third part is the action, which will be performed when a rule is triggered and all conditions are met. For example, it can turn a light on, set the temperature on your thermostat or activate a scene. Automation rules interact directly with the internal state of Home Assistant, so you’ll need to familiarize yourself with it. Home Assistant exposes its current state via the developer tools. These are available at the bottom of the sidebar in the frontend. Developer Tools > States will show all currently available states. An entity can be anything. A light, a switch, a person and even the sun. A state consists of the following parts: State changes can be used as the source of triggers and the current state can be used in conditions. Actions are all about calling services. To explore the available services open the Developer Tools > Services. Services allow changing anything. For example turn on a light, run a script or enable a scene. Each service has a domain and a name. For example the service light.turn_on is capable of turning on any light in your system. Parameters can be passed to a service to indicate, for example, which device to activate or which color to use. Now that you’ve got a sneak peek of what is possible, it’s time to get your feet wet and create your first automation."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/#editing-configurationyaml",
        "content": "While you can configure most of Home Assistant directly from the user interface under Settings, some parts need you to edit configuration.yaml. This file contains integrationsIntegrations connect and integrate Home Assistant with your devices, services, and more.\n[Learn more] to be loaded along with their configurations. Throughout the documentation you will find snippets that you can add to your configuration file to enable specific functionality. If you run into trouble while configuring Home Assistant, refer to the configuration troubleshooting page and the configuration.yaml examples. The easiest option to edit configuration.yaml is to use the Studio Code Server add-on. This add-on runs VS Code, which offers live syntax checking and auto-fill of various Home Assistant entities. See here for details. If unavailable on your system, use File Editor add-on instead. Again, details can be found here. If you prefer to use a file editor on your computer, use the Samba add-on to access the files as a network share. More details can be found here. The path to your configuration directory can be found in the Home Assistant frontendThe frontend is a necessary component for the UI, it is also where you can define your themes.[Learn more] by going to Settings > System > Repairs > System information from the top right menu  Right under the version you are running, you will find what path Home Assistant has loaded the configuration from.\n If you use Home Assistant Container, you can find configuration.yaml in the config folder that you mounted in your container. If you use Home Assistant Operating System, you can find configuration.yaml in the /config folder of the installation. If you use Home Assistant Core, you can find configuration.yaml in the config folder passed to the hass command (default is ~/.homeassistant). Most integrations in Home Assistant that do not interact with devicesA device is a model representing a physical or logical unit that contains entities.\n or servicesA service carries out one specific task, for example: turn on the light in the living room. A service has targets and data and can be called by actions, a dashboard, or via voice command.\n[Learn more] can reload changes made to their configuration in configuration.yaml. To do this, go to Developer Tools > YAML and scroll down to the YAML configuration reloading section (alternatively, hit “c” anywhere in the UI and search for it). If you can’t see your integration listed there, you will need to restart Home Assistant for changes to take effect. To test any changes to your configuration files from the command line, check out the common tasks for operating system, supervised, container, core for how to do that. Configuration changes can also be tested using the UI by navigating to Developer Tools > YAML and clicking “Check Configuration”. For the button to be visible, you must enable “Advanced Mode” on your User Profile. The preferred way of migrating to a new system is by making a backup. Once you have created the backup on the old system, you can download it to the system that is running the Home Assistant frontend. When setting up the new system, you may use the backup. Alternatively, you can upload it to your new system using the Upload backup menu option of the Backups menu. Then, a restore of the uploaded backup on the new system concludes the migration. If you run the container or core installation methods, you will need to manually make a backup of your configuration folder. Be aware that some of the files you need start with ., which is hidden by default from both ls (in SSH), in Windows Explorer, and macOS Finder. You’ll need to ensure that you’re viewing all files before you copy them."
    },
    {
        "url": "https://www.home-assistant.io/docs/tools/quick-bar/",
        "content": "The Quick bar allows you to quickly look up entities or run commands without needing to navigate away from your current view (Similar to the “quick open” feature in VS Code, Chrome Developer Tools, etc). It can be launched from anywhere in the frontend using hotkeys. \n\nQuick Bar for accessing entities and running commands\n Type these from anywhere in the application to launch the dialog. Hotkey: e Similar to Settings -> Devices & Services -> Entities, but more lightweight and accessible from anywhere in the frontend. \n\nFilter for entities in Quick Bar's entity filter mode\n Once launched, start typing your entity id (or “bits and pieces” of your entity id) to get back a filtered list of entities. Clicking on an entity (or hitting enter when the desired entity is highlighted) will open the “More Info” dialog for that entity. This is helpful when, say, you are in the middle of writing an automation and need some quick insight about an entity but don’t want to navigate away to Developer Tools. Hotkey: c Run various commands from anywhere without having to navigate to another view. \n\nRun commands in Quick Bar's \"command palette\"\n Hotkey: m Create my links from any supported page in the user interface, when invoked on a supported page it will open a new tab that will allow you to share the link in different formats. You can enable or disable all of Home Assistant’s keyboard shortcuts by going to your User Profile and clicking the “Keyboard Shortcuts” toggle button. \n\nToggle button for enabling/disabling keyboard shortcuts added by Home Assistant.\n We know something like “light.ch” should match “light.chandelier”. Similarly, “telev” should match “media_player.television”. But with Quick Bar, “lich” would also match “light.chandelier”, and “plyrtv” would also match “media_player.television”. It checks letter sequences rather than exact substrings. One nice use-case for this is that you can quickly filter out an entire domain of entities with just a couple letters and a period. For example, “li.” will match any “light.*” entities. Continuing with “li.ch” would bring up the chandelier right away. If “light.hue_ceiling_light” has been named “Chandelier”, you can type either “hue_ceil” or “chand” to find it. As soon as the item you wanted shows up at the top of your filtered results, just hit “enter” to activate it – no need to arrow down to the item, or click with your mouse. When in the text field, use the down arrow ↓ to navigate down the item list. Hit enter to activate the currently-highlighted row. When in the item list, use the up arrow ↑ to navigate up the item list, and to get back into the text field. Say you’ve just used arrow keys to navigate half-way down the list, and want to add more text to your filter. You don’t need to click back into the text field, just start typing new letters and they’ll append to your filter. There are a few possible reasons why the quick bar dialog won’t launch: The command list only shows commands that are available to you based on your user settings, and loaded integrations. For example, if you don’t have automations: in your config, then you won’t see the “Reload Automations” command. If “Advanced Mode” is turned off in User Settings, then any command related to advanced mode will not appear in the list. If a command is missing that you feel is in error, please create an issue on GitHub. You can disable shortcuts in your User settings. Please consider submitting an issue explaining why the shortcut was disruptive to you. Keyboard shortcuts are new to Home Assistant, and getting them right is a challenge for any Web application. We rely on user feedback to ensure the experience is minimally-disruptive."
    },
    {
        "url": "https://www.home-assistant.io/docs/authentication/providers/#legacy-api-password",
        "content": "When you log in, an auth provider checks your credentials to make sure you are an authorized user. Home Assistant automatically configures the standard auth providers so you don’t need to specify auth_providers in your configuration.yaml file unless you are configuring more than one. Specifying auth_providers will disable all auth providers that are not listed, so you could reduce your security or create difficulties logging in if it is not configured correctly. If you decide to use trusted_networks as your auth_provider there won’t be a way to authenticate for a device outside of your listed trusted network. To overcome this ensure you add the default auth_provider with type: homeassistant back in manually. This will then present you with the default auth login screen when trusted network authentication fails as expected from outside your LAN. Authentication providers are configured in your configuration.yaml under the homeassistant: block.\nIf you are moving configuration to packages, this particular configuration must stay within ‘configuration.yaml’. See Issue 16441 in the warning block at the bottom of this page. You can supply more than one, for example: This is the default auth provider. The first user created is designated as the owner and can create other users. User details are stored in the [your config]/.storage directory. All passwords are stored hashed and with a salt, making it almost impossible for an attacker to figure out the password even if they have access to the file. Users can be managed in Home Assistant by the owner. Go to the configuration panel and click on Users. This is the entry in configuration.yaml for Home Assistant auth: If you don’t specify any auth_providers section in the configuration.yaml file then this provider will be set up automatically. The trusted networks auth provider defines a range of IP addresses for which no authentication will be required (also known as “allowlisting”). For example, you can allowlist your local network so you won’t be prompted for a password if you access Home Assistant from inside your home. When you log in from one of these networks, you will be asked which user account to use and won’t need to enter a password. The multi-factor authentication module will not participate in the login process if you are using this auth provider. You cannot trust a network that you are using in any trusted_proxies. The trusted_networks authentication will fail with the message: Your computer is not allowed Here is an example in configuration.yaml to set up Trusted Networks: A list of IP addresses or an IP network you want allowlisted. It accepts both IPv4 and IPv6 IP address or network You can also assign which users are available to select when user access login page from certain IP address or network. List of user ids available to select on this IP address or network. You can bypass login page if you have only one user available for selection. First note, for trusted_users configuration you need to use user id, which you can find through Settings -> People -> View User Detail. The trusted_users configuration will not validate the existence of the user, so please make sure you have put in the correct user id by yourself. Second note, a trusted user with an IPv6 address must put the IPv6 address in quotes as shown. In above example, if user try to access Home Assistant from 192.168.0.1, they will have only one user available to choose. They will have two users available if access from 192.168.0.38 (from 192.168.0.0/24 network). If they access from 192.168.10.0/24 network, they can choose from all available users (non-system and active users). Specially, you can use group: GROUP_ID to assign all users in certain user group to be available to choose. Group and users can be mix and match. This is a feature to allow you to bring back some of the experience before the user system was implemented. You can directly jump to the main page if you are accessing from trusted networks, the allow_bypass_login is on, and you have ONLY ONE available user to choose from in the login form. If you allow bypass login then your cookie will not be stored and every time you refresh the page in Home Assistant a new login will be created. This is because bypassing the login does not give you the option to save the login. Assuming you have only the owner created though onboarding process, no other users ever created. The above example configuration will allow you directly access Home Assistant main page if you access from your internal network (192.168.0.0/24) or from localhost (127.0.0.1). If you get a login abort error, then you can change to use Home Assistant Authentication Provider to login, if you access your Home Assistant instance from outside network. The command line auth provider executes a configurable shell command to perform user authentication. Two environment variables, username and password, are passed to the command. Access is granted when the command exits successfully (with exit code 0). This provider can be used to integrate Home Assistant with arbitrary external authentication services, from plaintext databases over LDAP to RADIUS. A compatible script for LDAP authentication is this one, for instance. Please note, this will only work when using the Home Assistant Core installation type. Here is a configuration example: When meta: true is set in the auth provider’s configuration, your command can write some variables to standard output to populate the user account created in Home Assistant with additional data. These variables have to be printed in the form: Leading and trailing whitespace, as well as lines starting with # are ignored. The following variables are supported. More may be added in the future. Stderr is not read at all and just passed through to that of the Home Assistant process, hence you can use it for status messages or suchlike."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#sentence-wildcards",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/scripts/conditions/",
        "content": "Conditions can be used within a scriptScripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on.\n[Learn more] or automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] to prevent further execution. When a condition evaluates true, the script or automation will be executed. If any other value is returned, the script or automation stops executing. A condition will look at the system at that moment. For example, a condition can test if a switch is currently turned on or off. Unlike a triggerA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more], which is always or, conditions are and by default - all conditions have to be true. All conditions support an optional alias. Test multiple conditions in one condition statement. Passes if all embedded conditions are true. If you do not want to combine AND and OR conditions, you can list them sequentially. The following configuration works the same as the one listed above: Currently you need to format your conditions like this to be able to edit them using the automations editor. The AND condition also has a shorthand form. The following configuration works the same as the ones listed above: Test multiple conditions in one condition statement. Passes if any embedded condition is true. The OR condition also has a shorthand form. The following configuration works the same as the one listed above: Test multiple AND and OR conditions in one condition statement. Passes if any embedded condition is true.\nThis allows you to mix several AND and OR conditions together. Or in shorthand form: Test multiple conditions in one condition statement. Passes if all embedded conditions are not true. The NOT condition also has a shorthand form. The following configuration works the same as the one listed above: This type of condition attempts to parse the state of the specified entity or the attribute of an entity as a number, and triggers if the value matches the thresholds. If both below and above are specified, both tests have to pass. You can optionally use a value_template to process the value of the state before testing it. It is also possible to test the condition against multiple entities at once.\nThe condition will pass if all entities match the thresholds. Alternatively, the condition can test against a state attribute.\nThe condition will pass if the attribute value of the entity matches the thresholds. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below\noptions to make the condition more dynamic. Tests if an entity has a specified state. It is also possible to test the condition against multiple entities at once.\nThe condition will pass if all entities match the state. Instead of matching all, it is also possible if one of the entities matches.\nIn the following example the condition will pass if any entity matches the state. Testing if an entity is matching a set of possible conditions;\nThe condition will pass if the entity matches one of the states given. Or, combine multiple entities with multiple states. In the following example,\nboth media players need to be either paused or playing for the condition to pass. Alternatively, the condition can test against a state attribute.\nThe condition will pass if the attribute matches the given state. Finally, the state option accepts helper entities (also known as input_*\nentities). The condition will pass if the state of the entity matches the state\nof the given helper entity. You can also use templates in the for option. The for template(s) will be evaluated when the condition is tested. The sun state can be used to test if the sun has set or risen. The sun elevation can be used to test if the sun has set or risen, it is dusk, it is night, etc. when a trigger occurs.\nFor an in-depth explanation of sun elevation, see sun elevation trigger. The sun condition can also test if the sun has already set or risen when a trigger occurs. The before and after keys can only be set to sunset or sunrise. They have a corresponding optional offset value (before_offset, after_offset) that can be added, similar to the sun trigger. Note that if only before key is used, the condition will be true from midnight until sunrise/sunset. If only after key is used, the condition will be true from sunset/sunrise until midnight. If both before: sunrise and after: sunset keys are used, the condition will be true from midnight until sunrise and from sunset until midnight. If both after: sunrise and before: sunset keys are used, the condition will be true from sunrise until sunset. This is an example of 1 hour offset before sunset: This is ‘when dark’ - equivalent to a state condition on sun.sun of below_horizon: This is ‘when light’ - equivalent to a state condition on sun.sun of above_horizon: A visual timeline is provided below, showing an example of when these conditions are true. In this chart, sunrise is at 6:00, and sunset is at 18:00 (6:00 PM). The green areas of the chart indicate when the specified conditions are true.  The template condition tests if the given template renders a value equal to true. This is achieved by having the template result in a true boolean expression or by having the template render True. Within an automation, template conditions also have access to the trigger variable as described here. The template condition has a shorthand notation that can be used to make your scripts and automations shorter. For example: Or in a list of conditions, allowing to use existing conditions as described in this\nchapter and one or more shorthand template conditions This shorthand notation can be used everywhere in Home Assistant where\nconditions are accepted. For example, in and, or\nand not conditions: It’s also supported in the repeat action’s while or until option, or in a choose action’s conditions option: It’s also supported in script or automation condition actions: The time condition can test if it is after a specified time, before a specified time or if it is a certain day of the week. Valid values for weekday are mon, tue, wed, thu, fri, sat, sun.\nNote that if only before key is used, the condition will be true from midnight until the specified time.\nIf only after key is used, the condition will be true from the specified time until midnight.\nTime condition windows can span across the midnight threshold if both after and before keys are used. In the example above, the condition window is from 3pm to 2am. A better weekday condition could be by using the Workday Binary Sensor. For the after and before options a time helper (input_datetime entity)\nor another sensor entity containing a timestamp with the “timestamp” device\nclass, can be used instead. Please note that the time condition only takes the time into account. If\na referenced sensor or helper entity contains a timestamp with a date, the\ndate part is fully ignored. The trigger condition can test if an automation was triggered by a certain trigger, identified by the trigger’s id. For a trigger identified by its index, both a string and integer is allowed: It is possible to give a list of triggers: Zone conditions test if an entity is in a certain zone. For zone automation to work, you need to have set up a device tracker platform that supports reporting GPS coordinates. It is also possible to test the condition against multiple entities at once.\nThe condition will pass if all entities are in the specified zone. Testing if an entity is matching a set of possible zones;\nThe condition will pass if the entity is in one of the zones. Or, combine multiple entities with multiple zones. In the following example,\nboth entities need to be either in the home or the work zone for the condition\nto pass. Every individual condition can be disabled, without removing it.\nTo do so, add enabled: false to the condition configuration. This can be useful if you want to temporarily disable a condition, for example,\nfor testing. A disabled condition will behave as if it were removed. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/templating#sentence",
        "content": "Automations support templating in the same way as scripts do. In addition to the Home Assistant template extensions available to scripts, the trigger and this template variables are available. The template variable this is also available when evaluating any trigger_variables declared in the configuration. The variable this is the state object of the automation at the moment of triggering the actions. State objects also contain context data which can be used to identify the user that caused a scriptScripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on.\n[Learn more] or automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] to execute. Note that this will not change while executing the actionsActions are used in several places in Home Assistant. As part of a script or automation, actions define what is going to happen once a trigger is activated. In scripts, an action is called sequence.\n[Learn more]. The variable trigger is an object that contains details about which triggerA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more] triggered the automation. Templates can use the data to modify the actions performed by the automation or displayed in a message. For example, you could create an automation that multiple sensors can trigger and then use the sensor’s location to specify a light to activate; or you could send a notification containing the friendly name of the sensor that triggered it. Each trigger platform can include additional data specific to that platform. Triggers from all platforms will include the following data. These are the properties available for a Calendar trigger. These are the properties available for a Device trigger. Inherites template variables from event or state template based on the type of trigger selected for the device. These are the properties available for a Event trigger. These are the properties available for a MQTT trigger. These are the properties available for a numeric state trigger. These are the properties available for a Sentence trigger. These are the properties available for a State trigger. These are the properties available for a Sun trigger. These are the properties available for a Template trigger. These are the properties available for a Time trigger. These are the properties available for a time pattern trigger. These properties are available for a persistent notification trigger. These are the properties available for a Webhook trigger. These are the properties available for a Zone trigger."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#template-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/energy/gas/",
        "content": "Some homes are connected to gas. Gas is being used to heat water, cook and heat up the home. Home Assistant allows you to track your gas usage and easily compare it against your energy usage for the same period of time. Home Assistant will need to know the amount of gas that is being consumed. The best way to get this data is directly from your gas meter that sits between your house and the grid. In certain countries these meters contain standardized ways of reading out the information locally or provide this information via the electricity meter. The P1 port is a standardized port on electricity meters in the Netherlands, Belgium and Luxembourg which also provides gas consumption information. A P1 reader can connect to this port and receive real-time information. We have worked with creator Marcel Zuidwijk to develop SlimmeLezer+. It’s an affordable P1 reader powered by ESPHome that will seamlessly integrate this information in Home Assistant. It is being sold on his website and the firmware is open source on GitHub.  AI-on-the-edge-device is a project running on an ESP32-CAM and can be fully integrated into Home Assistant using the Home Assistant Discovery Functionality of MQTT. It digitalizes your gas/water/electricity meter display and provides its data in various ways.  Diaphragm gas meters are the most common type of gas meter, and their movement can frequently be observed with a magnetometer. The QMC5883L is a common and inexpensive option that ESPHome supports. Many posts on the forums of users having luck with this method, such as this one."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/securing/",
        "content": "One major advantage of Home Assistant is that it is not dependent on cloud services. Even if you are only using Home Assistant on a local network, you should take steps to secure your instance. Here’s the summary of what you must do to secure your Home Assistant system: If you want secure remote access, the easiest option is to use Home Assistant Cloud by which you also support the founders of Home Assistant. Another option is to use TLS/SSL via the add-on Duck DNS integrating Let’s Encrypt. To expose your instance to the internet, use a VPN, or an SSH tunnel. Make sure to expose the used port in your router. Besides the above we advise that you consider the following to improve security:"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#home-assistant-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/blueprint/",
        "content": "This section gives a high-level introduction to blueprints. To view a description of the YAML-schema used to create a valid blueprint, refer to the section About the blueprint schema. A blueprint is a scriptScripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on.\n[Learn more] or automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] configuration with certain parts marked as configurable. This allows you to create different scripts or automations based on the same blueprint. Imagine you want to control lights based on motion. A blueprint provides the generic automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] framework, while letting you select one specific motion sensor as a triggerA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more], and the exact light to control. This blueprint makes it possible to create two automations. Each automation has their own configuration and act completely independently. Yet, they share some basic automation configuration so that you do not have to set this up every time. Blueprints are shared by the community in the blueprint community forum."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#time-pattern-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/state_object/",
        "content": "Your devicesA device is a model representing a physical or logical unit that contains entities.\n are represented in Home Assistant as entities. The entitiesAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] will write their current stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more] to the state machine for other entities/templates/frontend to access. States are a current representation of the entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more]. If you overwrite a state via the states dev tool or the API, it will not impact the actual device. If the device state is being polled, it will overwrite the state in the state machine the next polling. All states will always have an entity id, a state and a timestamp when last updated and last changed. The attributes of an entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] are optional. There are a few attributes that are used by Home Assistant for representing the entity in a specific way. Each integration will also have its own attributes to represent extra state data about the entity. For example, the light integration has attributes for the current brightness and color of the light. When an attribute is not available, Home Assistant will not write it to the state. When using templates, attributes will be available by their name. For example state.attributes.assumed_state. When an attribute contains spaces, you can retrieve it like this: state_attr('sensor.livingroom', 'Battery numeric'). Context is used to tie eventsAn event is when something happens.[Learn more] and statesThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more] together in Home Assistant. Whenever an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] or user interaction causes states to change, a new context is assigned. This context will be attached to all events and states that happen as result of the change."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/yaml/#using-environment-variables",
        "content": "Home Assistant uses the YAML syntax for configuration. YAML might take a while to get used to but is powerful in allowing you to express complex configurations. While more and more integrations are configured through the UI, for some, you will add code in your configuration.yaml file to specify its settings. The following example entry assumes that you would like to set up the notify integration with the pushbullet platform. The basics of YAML syntax are block collections and mappings containing key-value pairs. Each item in a collection starts with a - while mappings have the format key: value. This is somewhat similar to a Hash table or more specifically a dictionary in Python. These can be nested as well. Beware that if you specify duplicate keys, the last value for a key is used. In YAML, indentation is important for specifying relationships. Indented lines are nested inside lines that are one level higher. In the above example, platform: pushbullet is a property of (nested inside) the notify integration. Getting the right indentation can be tricky if you’re not using an editor with a fixed-width font. Tabs are not allowed to be used for indentation. The convention is to use 2 spaces for each level of indentation. To check if your YAML syntax is correct before loading it into Home Assistant, you can use the third-party service YAML Validator (not maintained by the Home Assistant community). Pay attention to not storing private data (passwords, API keys, etc.) directly in your configuration.yaml file. Private data can be stored in either a separate file or in environmental variables, which circumvents this security problem. Strings of text following a # are comments and are ignored by the system. The next example shows an input_select integration that uses a block collection for the values of options.\nThe other properties (like name:) are specified using mappings. Note that the second line just has threat: with no value on the same line. Here threat is the name of the input_select and the values for it are everything nested below it. The following example shows nesting a collection of mappings in a mapping. In Home Assistant, this would create two sensors that each use the MQTT platform but have different values for their state_topic (one of the properties used for MQTT sensors). On Home Assistant Core installations, you can include values from your system’s environment variables with !env_var.\nNote that this will only work for Home Assistant Core installations, in a scenario where it is possible to specify these.\nRegular Home Assistant users are recommended to use !include statements instead. If an environment variable is not set, you can fall back to a default value. To improve readability, you can source out certain domains from your main configuration file with the !include-syntax. More information about this feature can also be found at splitting configuration. If you see the following message: This means that you’ve mistakenly entered a tab character, instead of spaces. Home Assistant is case sensitive, a state of 'on' is not the same as 'On' or 'ON'. Similarly an entity of group.Doors is not the same as group.doors. If you’re having trouble, check the case that Home Assistant is reporting in the dev-state menu, under Developer tools. YAML treats Y, true, Yes, ON all as true and n, FALSE, No, off as false. This means that if you want to set the state of an entity to on you must quote it as 'on' otherwise it will be translated as setting the state to true. The same applies to off. Not quoting the value may generate an error such as:"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/yaml/",
        "content": "Automations are created in Home Assistant via the UI, but are stored in a YAML format. If you want to edit the YAML of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more], select the automation, click on the menu button in the top right then on Edit in YAML. The UI will write your automations to automations.yaml. This file is managed by the UI and should not be edited manually. It is also possible to write your automations directly inside configuration.yaml or other YAML files. You can do this by adding a labeled automation block to your configuration.yaml: You can add as many labeled automation blocks as you want. Friendly name for the automation. A unique id for your automation, will allow you to make changes to the name and entity_id in the UI, and will enable debug traces. A description of the automation. Used to define the state of your automation at startup. When not set, the state will be restored from the last run. See Automation initial state. Configuration values for the traces stored, currently only stored_traces can be configured. The number of traces which will be stored. See Number of debug traces stored. Variables that will be available inside your templates, both in condition and action. The value of the variable. Any YAML is valid. Templates can also be used to pass a value to the variable. Variables that will be available inside your templates triggers. The value of the variable. Any YAML is valid. Only limited templates can be used. Controls what happens when the automation is invoked while it is still running from one or more previous invocations. See Automation modes. Controls maximum number of runs executing and/or queued up to run at a time. Only valid with modes queued and parallel. When max is exceeded (which is effectively 1 for single mode) a log message will be emitted to indicate this has happened. This option controls the severity level of that log message. See Log Levels for a list of valid options. Or silent may be specified to suppress the message from being emitted. The trigger(s) which will start the automation. Multiple triggers can be added and the automation will start when any of these triggers trigger. An ID that can be used in the automation to determine which trigger caused the automation to start. Variables that will be available in the conditions and action sequence. The value of the variable. Any YAML is valid. Templates can also be used to pass a value to the variable. Conditions that have to be true to start the automation. By default all conditions listed have to be true, you can use logical conditions to change this default behavior. The sequence of actions to be performed in the script. \n\n Example of a YAML based automation that you can add to configuration.yaml. When writing automations directly in YAML, you will have access to advanced options that are not available in the user interface. At startup, automations by default restore their last state of when Home Assistant ran. This can be controlled with the initial_state option. Set it to false or true to force initial state to be off or on. When using YAML you can configure the number of debugging traces stored for an automation. This is controlled with the stored_traces option under trace. Set stored_traces to the number of traces you wish to store for the particular automation. If not specified the default value of 5 will be used. If you want to migrate your manual automations to use the editor, you’ll have to copy them to automations.yaml. Make sure that automations.yaml remains a list! For each automation that you copy over, you’ll have to add an id. This can be any string as long as it’s unique. When automations remain visible in the Home Assistant dashboard, even after having deleted in the YAML file, you have to delete them in the UI. To delete them completely, go to UI Settings -> Devices & Services -> Entities and find the automation in the search field or by scrolling down. Check the square box aside of the automation you wish to delete and from the top-right of your screen, select ‘REMOVE SELECTED’."
    },
    {
        "url": "https://www.home-assistant.io/docs/locked_out/#to-delete-a-user",
        "content": "The sections below deal with recovering from a situation where you are not able to sign in,\nor need to recover your data. If you’ve forgotten your username, ask the owner to help you.\nIf you are the owner and have forgotten your user name, then you need to prepare the system to start a new onboarding process. If you are not the owner or do not have administrator rights, ask the owner to give you a new password. If you are the owner or have administrator, there are different methods to reset a password, depending on your setup: The method used to reset a password depends on your user rights: Use this procedure only if the following conditions are met: If you are running Home Assistant in a container, you can use the command line in the container with the hass command to change your password. The steps below refer to a Home Assistant container in Docker named homeassistant. Note that while working in the container, commands will take a few moments to execute. Only the owner can change other user’s passwords. You need to be an owner or have administrator rights to delete a user. If you lose the password associated with the owner account and the steps above do not work to reset the password, the only way to resolve this is to start a new onboarding process. If you have an external backup with an administrator account of which you still know the login credentials, you can restore that backup. If you do not have a backup, resetting the device will erase all data. If you have a Home Assistant Green, reset the Green. If you have a Home Assistant Yellow, reset the Yellow. Unless your SD card/data is corrupted, you can still get to your files or troubleshoot further.\nThere are a few routes: If you’re using a Raspberry Pi, you’re likely going to have to pull the power in order to get your monitor recognized at boot. Pulling power has a risk of corrupting the SD, but you may not have another option. Most standard USB keyboards should be recognized easily. Once you’re connected, you’ll see a running dmesg log. Hit the enter key to interrupt the log.\nSign in as “root”. There is no password. You will then be at the Home Assistant CLI, where you can run the custom commands. These are the same as you would run using the SSH add-on but without using ha in front of it. For example: The files are on an EXT4 partition (hassos-data) and the path is /mnt/data/supervisor.\nThese are easily accessed using another Linux machine with EXT support. For Windows or macOS you will need third party software. Below are some options."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/templating/#state",
        "content": "Automations support templating in the same way as scripts do. In addition to the Home Assistant template extensions available to scripts, the trigger and this template variables are available. The template variable this is also available when evaluating any trigger_variables declared in the configuration. The variable this is the state object of the automation at the moment of triggering the actions. State objects also contain context data which can be used to identify the user that caused a scriptScripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on.\n[Learn more] or automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] to execute. Note that this will not change while executing the actionsActions are used in several places in Home Assistant. As part of a script or automation, actions define what is going to happen once a trigger is activated. In scripts, an action is called sequence.\n[Learn more]. The variable trigger is an object that contains details about which triggerA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more] triggered the automation. Templates can use the data to modify the actions performed by the automation or displayed in a message. For example, you could create an automation that multiple sensors can trigger and then use the sensor’s location to specify a light to activate; or you could send a notification containing the friendly name of the sensor that triggered it. Each trigger platform can include additional data specific to that platform. Triggers from all platforms will include the following data. These are the properties available for a Calendar trigger. These are the properties available for a Device trigger. Inherites template variables from event or state template based on the type of trigger selected for the device. These are the properties available for a Event trigger. These are the properties available for a MQTT trigger. These are the properties available for a numeric state trigger. These are the properties available for a Sentence trigger. These are the properties available for a State trigger. These are the properties available for a Sun trigger. These are the properties available for a Template trigger. These are the properties available for a Time trigger. These are the properties available for a time pattern trigger. These properties are available for a persistent notification trigger. These are the properties available for a Webhook trigger. These are the properties available for a Zone trigger."
    },
    {
        "url": "https://www.home-assistant.io/docs/backend/",
        "content": "The backend of Home Assistant is running with Python 3. The Architecture page show the details about the elements running in the background of Home Assistant. To implement a new platform or component, please refer to the Development documentation."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/services/",
        "content": "The automation integration has services to control automations, like turning automations on and off. This can be useful if you want to disable an automation from another automation. This service enables the automation’s triggersA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more]. This service disables the automation’s triggersA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more], and optionally stops any currently active actionsActions are used in several places in Home Assistant. As part of a script or automation, actions define what is going to happen once a trigger is activated. In scripts, an action is called sequence.\n[Learn more]. This service enables the automation’s triggers if they were disabled, or disables the automation’s triggers, and stops any currently active actions, if the triggers were enabled. This service will trigger the actionActions are used in several places in Home Assistant. As part of a script or automation, actions define what is going to happen once a trigger is activated. In scripts, an action is called sequence.\n[Learn more] of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more]. By default it bypasses any conditions, though that can be changed via the skip_condition attribute. This service is only required if you create/edit automations in YAML. Automations via the UI do this automatically. This service reloads all automations, stopping all currently active automation actions."
    },
    {
        "url": "https://www.home-assistant.io/docs/tools/",
        "content": "Home Assistant ships a couple of helpers for the command-line and the frontend which simplify common tasks, are helping with migrations, and ensure that Home Assistant runs properly."
    },
    {
        "url": "https://www.home-assistant.io/docs/blueprint/selectors/",
        "content": "Selectors can be used to specify what values are accepted for a blueprint\ninput. The selector also defines how the input is shown in the user interface. Some selectors can, for example, show a toggle button to turn something\non or off, while another select can filter a list of devices to show\nonly devices that have motion-sensing capabilities. Having good selectors set on your blueprint automation inputs makes a\nblueprint easier to use from the UI. The following selectors are currently available: Interactive demos of each of these selectors can be found on the\nHome Assistant Design portal. If no selector is defined, a text input for a single line will be shown. The action selector allows the user to input one or more sequences of actions.\nOn the user interface, the action part of the automation editor will be shown.\nThe value of the input will contain a list of actions to perform.  This selector does not have any other options; therefore, it only has its key. The output of this selector is a list of actions. For example: This can only be used on an installation with a Supervisor. For installations\nthat do not have that, an error will be displayed. The add-on selector allows the user to input an add-on slug.\nOn the user interface, it will list all installed add-ons and use the slug of the\nselected add-on.  This selector does not have any other options; therefore, it only has its key. The output of this selector is the slug of the selected add-on.\nFor example: core_ssh. The area selector shows an area finder that can pick a single or multiple areas\nbased on the selector configuration. The value of the input will be the area ID,\nor a list of area IDs, based on if multiple is set to true. An area selector can filter the list of areas, based on properties of the devices\nand entities that are assigned to those areas. For example, the areas list could\nbe limited to areas with entities provided by the ZHA\nintegration. In its most basic form, this selector doesn’t require any options, which will show\nall areas.  When device options are provided, the list of areas is filtered by areas that at least provide one device that matches the given conditions. Can be either a object or a list of object. Can be set to an integration domain. Limits the list of areas that provide devices by the set integration domain, for example, zha. When set, it limits the list of areas that provide devices by the set manufacturer name. When set, it limits the list of areas that provide devices that have the set model. When entity options are provided, the list of areas is filtered by areas that at least provide one entity that matches the given conditions. Can be either a object or a list of object. Can be set to an integration domain. Limits the list of areas that provide entities by the set integration domain, for example, zha. Limits the list of areas that provide entities of a certain domain(s), for example, light or binary_sensor. Can be either a string with a single domain, or a list of string domains to limit the selection to. Limits the list of areas to areas that have entities with a certain device class(es), for example, motion or window. Can be either a string with a single device_class, or a list of string device_class to limit the selection to. Limits the list of areas to areas that have entities with a certain supported feature, for example, light.LightEntityFeature.TRANSITION or climate.ClimateEntityFeature.TARGET_TEMPERATURE. Should be a list of features. Allows selecting multiple areas. If set to true, the resulting value of this selector will be a list instead of a single string value. The output of this selector is the area ID, or (in case multiple is set to\ntrue) a list of area IDs. An example area selector only shows areas that provide one or more lights or\nswitches provided by the ZHA integration. Another example uses the area selector, which only shows areas that provide one\nor more remote controls provided by the deCONZ\nintegration. Multiple areas can be selected. The attributes selector shows a list of state attributes from a provided entity\nof which one can be selected. This allows for selecting, e.g., the “Effect” attribute from a light entity, or the\n“Next dawn” attribute from the sun entity.  The entity ID of which an state attribute can be selected from. The output of this selector is the selected attribute key (not the translated or\nprettified name shown in the frontend).\nFor example: next_dawn. The assist pipeline selector shows all available assist pipelines (assistants) of which one can be selected.  This selector does not have any other options; therefore, it only has its key. This can only be used on an installation with a Supervisor (Operating System or\nSupervised). For installations of type Home Assistant Core or Container, an error\nwill be displayed. The backup location selector shows a list of places a backup could go, depending\non what you have configured in storage.  The output of this selector is the name of the selected network storage. It may\nalso be the value /backup, if the user chooses to use the local data disk option\ninstead of one of the configured network storage locations. The boolean selector shows a toggle that allows the user to turn on or off\nthe selected option.  The boolean selector is suitable for adding feature switches\nto, for example, blueprints. This selector does not have any other options; therefore, it only has its key. The output of this selector is true when the toggle is on, false otherwise. The color temperature selector allows you to select a color temperature from a gradient using a slider.  The chosen unit for the color temperature. This can be either kelvin or mired. mired is the default for historical reasons. The minimum color temperature in the chosen unit. 2700 for kelvin 153 for mired The maximum color temperature in the chosen unit. 6500 for kelvin 500 for mired The output of this selector is the number representing the chosen color temperature for the unit used. The condition selector allows the user to input one or more conditions.\nOn the user interface, the condition part of the automation editor will be shown.\nThe value of the input will contain a list of conditions.  This selector does not have any other options; therefore, it only has its key. The output of this selector is a list of conditions. For example: The config entry selector allows the user to select an integration\nconfiguration entry. The selector returns the entry ID of the selected\nintegration configuration entry.  Limits the list of selectable configuration entries to a single integration domain. The output of this selector is the entry ID of the config entry, for example, 6b68b250388cbe0d620c92dd3acc93ec. The constant selector shows a toggle that allows the user to enable the selected option.\nThis is similar to the boolean selector, the difference\nis that the constant selector has no value when it’s not enabled.  The selector’s value must be configured, and optionally, a label. The output of this selector is the configured value when the toggle is on, it has no output otherwise. The conversation agent selector allows picking a conversation agent.  The selector has 1 option, language. This filters the conversation agents shown, depending on the language. Limits the list of conversation agents to those supporting the specified language. The output of this selector is the ID of the conversation agent. The date selector shows a date input that allows the user to specify a date.  This selector does not have any other options; therefore, it only has its key. The output of this selector will contain the date in Year-Month-Day\n(YYYY-MM-DD) format, for example, 2022-02-22. The country selector allows a user to pick a country from a list of countries.  A list of countries to pick from, this should be ISO 3166 country codes. The available countries in the Home Assistant frontend Should the options be sorted by name, if set to true, the order of the provided countries is kept. The output of this selector is an ISO 3166 country code. The date selector shows a date and time input that allows the user to specify a\ndate with a specific time.  This selector does not have any other options; therefore, it only has its key. The output of this selector will contain the date in Year-Month-Day\n(YYYY-MM-DD) format and the time in 24-hour format, for example:\n2022-02-22 13:30:00. The device selector shows a device finder that can pick a single or multiple\ndevices based on the selector configuration. The value of the input will contain\nthe device ID or a list of device IDs, based on if multiple is set to true. A device selector can filter the list of devices, based on things like the\nmanufacturer or model of the device, the entities the device provides or based\non the domain that provided the device.  In its most basic form, this selector doesn’t require any options, which will show\nall devices. When entity options are provided, the list of devices is filtered by devices that at least provide one entity that matches the given conditions. Can be either a object or a list of object. Can be set to an integration domain. Limits the list of devices that provide entities by the set integration domain, for example, zha. Limits the list of devices that provide entities of a certain domain(s), for example, light or binary_sensor. Can be either a string with a single domain, or a list of string domains to limit the selection to. Limits the list of devices to devices that have entities with a certain device class(es), for example, motion or window. Can be either a string with a single device_class, or a list of string device_class to limit the selection to. Limits the list of devices to devices that have entities with a certain supported feature, for example, light.LightEntityFeature.TRANSITION or climate.ClimateEntityFeature.TARGET_TEMPERATURE. Should be a list of features. When filter options are provided, the list of devices is filtered by devices that at least provide one entity that matches the given conditions. Can be either a object or a list of object. Can be set to an integration domain. Limits the list of devices to devices provided by the set integration domain. When set, it limits the list of devices to devices provided by the set manufacturer name. When set, it limits the list of devices to devices that have the set model. Allows selecting multiple devices. If set to true, the resulting value of this selector will be a list instead of a single string value. The output of this selector is the device ID, or (in case multiple is set to\ntrue) a list of devices IDs. An example entity selector that, will only show devices that are: And this is what is looks like in YAML: The duration select allow the user to select a time duration. This can be\nhelpful for, e.g., delays or offsets.  When true, the duration selector will allow selecting days. The output of this selector is a mapping of the time values the user selected.\nFor example: The entity selector shows an entity finder that can pick a single entity or a\nlist of entities based on the selector configuration. The value of the input\nwill contain the entity ID, or list of entity IDs, based on if multiple is\nset to true. An entity selector can filter the list of entities, based on things like the\nclass of the device, the domain of the entity or the domain that provided the\nentity.  In its most basic form, this selector doesn’t require any options, which will show\nall entities. List of entity IDs to exclude from the selectable list. List of entity IDs to limit the selectable list to. When filter options are provided, the entities are limited by entities that at least match the given conditions. Can be either an object or a list of objects. Can be set to an integration domain. Limits the list of entities to entities provided by the set integration domain, for example, zha. Limits the list of entities to entities of a certain domain(s), for example, light or binary_sensor. Can be either a string with a single domain, or a list of string domains to limit the selection to. Limits the list of entities to entities that have a certain device class(es), for example, motion or window. Can be either a string with a single device_class, or a list of string device_class to limit the selection to. Limits the list of entities to entities that have a certain supported feature, for example, light.LightEntityFeature.TRANSITION or climate.ClimateEntityFeature.TARGET_TEMPERATURE. Should be a list of features. Allows selecting multiple entities. If set to true, the resulting value of this selector will be a list instead of a single string value. The output of this selector is the entity ID, or (in case multiple is set to\ntrue) a list of entity IDs. An example entity selector that, will only show entities that are: And this is what it looks like in YAML: The icon selector shows an icon picker that allows the user to select an icon. Placeholder icon to show, when no icon is selected. The output of this selector is a string containing the selected icon,\nfor example: mdi:bell. The language selector allows a user to pick a language from a list of languages.  A list of languages to pick from, this should be RFC 5646 languages codes. The available languages in the Home Assistant frontend Should the name of the languages be shown in the language of the user, or in the language itself. Should the options be sorted by name, if set to true, the order of the provided languages is kept. The output of this selector is a RFC 5646 language code. The location selector allow a user to pick a location from a map and returns\nthe matching longitude and latitude coordinators. Optionally it supports\nselecting the radius of the location.  An optional icon to show on the map. Allow selecting the radius of the location. If enabled, the radius will be returned in meters. The output of this selector is a mapping containing the latitude and longitude\nof the selected location, and, if enabled, the radius.\nFor example: The media selector is a powerful selector that allows a user to easily select\nmedia to play on a media device. Media can be a lot of things, for example,\ncameras, local media, text-to-speech, Home Assistant Dashboards, and many more. The user selects the device to play media on, and automatically limits the\nselectable media suitable for the selected device.  The output of the media selector, is an mapping with information about\nthe selected media device and the selected media to play. There is also\nmetadata, which is used by the frontend and should not be used in the\nbackend. Example output: The number selector shows either a number input or a slider input, that allows\nthe user to specify a numeric value. The value of the input will contain\nthe select value.  On the user interface, the input can either be in a slider or number mode.\nBoth modes limit the user input by a minimum and maximum value, and can\nhave a unit of measurement to go with it. In its most basic form, this selector requires a minimum and maximum value: The minimum user-settable number value. The maximum user-settable number value. The step size of the number value. Set to \"any\" to allow any number. Unit of measurement in which the number value is expressed in. This can be either box or slider mode. The output of this selector is a number, for example: 42 An example number selector that allows a user a percentage, directly in a\nregular number input box. A more visual variant of this example could be achieved using a slider.\nThis can be helpful for things like allowing the user to select a\nbrightness level of lights. Additionally, this example changes the brightness\nin incremental steps of 10%. The object selector can be used to input arbitrary data in YAML form. This is useful for e.g. lists and dictionaries like service data. The value of the input will contain the provided data.  This selector does not have any other options; therefore, it only has its key. The output of this selector is a YAML object. The RGB color selector allows the user to select an color from a color picker\nfrom the user interface, and returns the RGB color value.  This selector does not have any other options; therefore, it only has its key. The output of this selector is a list with the three (RGB) color value, for example: [255, 0, 0]. The select selector shows a list of available options from which the user can choose. The value of the input contains the value of the selected option. Only a single option can be selected at a time.  The selector requires a list of options that the user can choose from. List of options that the user can choose from. Small lists (5 items or less), are displayed as radio buttons. When more items are added, a dropdown list is used. Allows selecting multiple options. If set to true, the resulting value of this selector will be a list instead of a single string value. Allows the user to enter and select a custom value (or multiple custom values in addition to the listed options if multiple is set to true). This can be either list (radio buttons) or dropdown (combobox) mode. When not specified, small lists (5 items or less), are displayed as radio buttons. When more items are added, a dropdown list is used. If custom_value is true, this setting will be ignored and the frontend will use a dropdown input. Allows translations provided by an integration where translation_key is the translation key that is providing the selector option strings translation. See the documentation on Backend Localization for more information. Display options in alphabetical order. Alternatively, a mapping can be used for the options. When you want to return\na different value compared to how it is displayed to the user. List of options that the user can choose from. Small lists (5 items or less), are displayed as radio buttons. When more items are added, a dropdown list is used. The description to show in the UI for this item. The value to return when this label is selected. When multiple is false, the output of this selector is the string of\nthe selected option value. When selecting Green in the last example,\nit returns: g, in the first example it would return Green. When multiple is true, the output of this selector is the list of selected\noption values. In this case, if Green was selected, in the first example it\nwould return [“Green”] and in the last example it returns [“g”]. The state selector shows a list of states for a provided entity of which\none can be selected.  The entity ID of which an state can be selected from. The output of this selector is the select state (not the translated or\nprettified name shown in the frontend). For example: heat_cool. The target selector is a rather special selector, allowing the user to select\ntargeted entities, devices or areas for service calls. The value of\nthe input will contain a special target format, that is accepted by\nservice calls. The selectable targets can be filtered, based on entity or device properties.\nAreas are only selectable as a target, if some entities or devices match\nthose properties in those areas.  In its most basic form, this selector does not require any options, which will allow the\nuser to target any entity, device or area available in the system. When device options are provided, the targets are limited by devices that at least match the given conditions. Can be either a object or a list of object. Can be set to an integration domain. Limits the device targets that are provided devices by the set integration domain, for example, zha. When set, it limits the targets to devices provided by the set manufacturer name. When set, it limits the targets to devices by the set model. When entity options are provided, the targets are limited by entities that at least match the given conditions. Can be either a object or a list of object. Can be set to an integration domain. Limits targets to entities provided by the set integration domain, for example, zha. Limits the targets to entities of a certain domain(s), for example, light or binary_sensor. Can be either a with a single domain, or a list of string domains to limit the selection to. Limits the targets to entities with a certain device class(es), for example, motion or window. Can be either a string with a single device_class, or a list of string device_class to limit the selection to. Targets are meant to be used with the target property of a service call in\na script sequence. For example: An example target selector that only shows targets that at least provide one\nor more lights, provided by the ZHA integration. Another example using the target selector, which only shows targets that\nprovide one or more remote controls, provided by the\ndeCONZ integration. The template selector can be used to input a Jinja2 template. This is useful\nfor allowing more advanced user-input that use Jinja2 templates.  This selector does not have any other options; therefore, it only has its key. The output of this selector is a template string. The text selector can be used to enter a text string. It can also be used to enter a list of text strings; if multiple is set to true. The value of the input will contain the selected text. This can be used in shopping lists, for example.  Unless multiline is set to true, this selector behaves exactly like if no selector at all was specified, and will display a single line text input box on the user interface. Set to true to display the input as a multi-line text box on the user interface. An optional prefix to show before the text input box. An optional suffix to show after the text input box. The type of input. This supplies the HTML type attribute, which controls how the browser displays and validates the field. A subset of types available to the attribute are supported, since some are handled by other selectors. Possible types are: color, date, datetime-local, email, month, number, password, search, tel, text, time, url, week. Guides the browser on the type of information which should automatically fill the field. This supplies the HTML autocomplete attribute. Any value supported by the HTML attribute is valid. Allows adding list of text strings. If set to true, the resulting value of this selector will be a list instead of a single string value. The output of this selector is a single string value. The theme selector allows for selecting a theme from the available themes\ninstalled in Home Assistant.  Includes Home Assistant default theme in the list. The output of this selector will contain the selected theme, for example:\nwaves_dark. The time selector shows a time input that allows the user to specify a time\nof the day.  This selector does not have any other options; therefore, it only has its key. The output of this selector will contain the time in 24-hour format,\nfor example, 23:59:59. The triggers selector allows the user to input one or more triggers.\nOn the user interface, the trigger part of the automation editor is shown.\nThe value of the input contains a list of triggers.  This selector does not have any other options; therefore, it only has its key. The output of this selector is a list of triggers. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/scripts/conditions/#template-condition-shorthand-notation",
        "content": "Conditions can be used within a scriptScripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on.\n[Learn more] or automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] to prevent further execution. When a condition evaluates true, the script or automation will be executed. If any other value is returned, the script or automation stops executing. A condition will look at the system at that moment. For example, a condition can test if a switch is currently turned on or off. Unlike a triggerA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more], which is always or, conditions are and by default - all conditions have to be true. All conditions support an optional alias. Test multiple conditions in one condition statement. Passes if all embedded conditions are true. If you do not want to combine AND and OR conditions, you can list them sequentially. The following configuration works the same as the one listed above: Currently you need to format your conditions like this to be able to edit them using the automations editor. The AND condition also has a shorthand form. The following configuration works the same as the ones listed above: Test multiple conditions in one condition statement. Passes if any embedded condition is true. The OR condition also has a shorthand form. The following configuration works the same as the one listed above: Test multiple AND and OR conditions in one condition statement. Passes if any embedded condition is true.\nThis allows you to mix several AND and OR conditions together. Or in shorthand form: Test multiple conditions in one condition statement. Passes if all embedded conditions are not true. The NOT condition also has a shorthand form. The following configuration works the same as the one listed above: This type of condition attempts to parse the state of the specified entity or the attribute of an entity as a number, and triggers if the value matches the thresholds. If both below and above are specified, both tests have to pass. You can optionally use a value_template to process the value of the state before testing it. It is also possible to test the condition against multiple entities at once.\nThe condition will pass if all entities match the thresholds. Alternatively, the condition can test against a state attribute.\nThe condition will pass if the attribute value of the entity matches the thresholds. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below\noptions to make the condition more dynamic. Tests if an entity has a specified state. It is also possible to test the condition against multiple entities at once.\nThe condition will pass if all entities match the state. Instead of matching all, it is also possible if one of the entities matches.\nIn the following example the condition will pass if any entity matches the state. Testing if an entity is matching a set of possible conditions;\nThe condition will pass if the entity matches one of the states given. Or, combine multiple entities with multiple states. In the following example,\nboth media players need to be either paused or playing for the condition to pass. Alternatively, the condition can test against a state attribute.\nThe condition will pass if the attribute matches the given state. Finally, the state option accepts helper entities (also known as input_*\nentities). The condition will pass if the state of the entity matches the state\nof the given helper entity. You can also use templates in the for option. The for template(s) will be evaluated when the condition is tested. The sun state can be used to test if the sun has set or risen. The sun elevation can be used to test if the sun has set or risen, it is dusk, it is night, etc. when a trigger occurs.\nFor an in-depth explanation of sun elevation, see sun elevation trigger. The sun condition can also test if the sun has already set or risen when a trigger occurs. The before and after keys can only be set to sunset or sunrise. They have a corresponding optional offset value (before_offset, after_offset) that can be added, similar to the sun trigger. Note that if only before key is used, the condition will be true from midnight until sunrise/sunset. If only after key is used, the condition will be true from sunset/sunrise until midnight. If both before: sunrise and after: sunset keys are used, the condition will be true from midnight until sunrise and from sunset until midnight. If both after: sunrise and before: sunset keys are used, the condition will be true from sunrise until sunset. This is an example of 1 hour offset before sunset: This is ‘when dark’ - equivalent to a state condition on sun.sun of below_horizon: This is ‘when light’ - equivalent to a state condition on sun.sun of above_horizon: A visual timeline is provided below, showing an example of when these conditions are true. In this chart, sunrise is at 6:00, and sunset is at 18:00 (6:00 PM). The green areas of the chart indicate when the specified conditions are true.  The template condition tests if the given template renders a value equal to true. This is achieved by having the template result in a true boolean expression or by having the template render True. Within an automation, template conditions also have access to the trigger variable as described here. The template condition has a shorthand notation that can be used to make your scripts and automations shorter. For example: Or in a list of conditions, allowing to use existing conditions as described in this\nchapter and one or more shorthand template conditions This shorthand notation can be used everywhere in Home Assistant where\nconditions are accepted. For example, in and, or\nand not conditions: It’s also supported in the repeat action’s while or until option, or in a choose action’s conditions option: It’s also supported in script or automation condition actions: The time condition can test if it is after a specified time, before a specified time or if it is a certain day of the week. Valid values for weekday are mon, tue, wed, thu, fri, sat, sun.\nNote that if only before key is used, the condition will be true from midnight until the specified time.\nIf only after key is used, the condition will be true from the specified time until midnight.\nTime condition windows can span across the midnight threshold if both after and before keys are used. In the example above, the condition window is from 3pm to 2am. A better weekday condition could be by using the Workday Binary Sensor. For the after and before options a time helper (input_datetime entity)\nor another sensor entity containing a timestamp with the “timestamp” device\nclass, can be used instead. Please note that the time condition only takes the time into account. If\na referenced sensor or helper entity contains a timestamp with a date, the\ndate part is fully ignored. The trigger condition can test if an automation was triggered by a certain trigger, identified by the trigger’s id. For a trigger identified by its index, both a string and integer is allowed: It is possible to give a list of triggers: Zone conditions test if an entity is in a certain zone. For zone automation to work, you need to have set up a device tracker platform that supports reporting GPS coordinates. It is also possible to test the condition against multiple entities at once.\nThe condition will pass if all entities are in the specified zone. Testing if an entity is matching a set of possible zones;\nThe condition will pass if the entity is in one of the zones. Or, combine multiple entities with multiple zones. In the following example,\nboth entities need to be either in the home or the work zone for the condition\nto pass. Every individual condition can be disabled, without removing it.\nTo do so, add enabled: false to the condition configuration. This can be useful if you want to temporarily disable a condition, for example,\nfor testing. A disabled condition will behave as if it were removed. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/scene/editor/",
        "content": "From the UI choose Settings which is located in the sidebar, then click on Automations & Scenes to go to the scene editor. Press the Add Scene button in the lower right corner to get started. Choose a meaningful name for your scene.  Select all the devicesA device is a model representing a physical or logical unit that contains entities.\n (or entitiesAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] when advanced mode is enabled on your user profile) you want to include in your scene.\nThe state of your devices will be saved, so it can be restored when you are finished creating your scene.\nSet the state of the devices to how you want them to be in your scene, this can be done by clicking on it and edit the state from the popup, or any other method that changes the state.\nOn the moment you save the scene, all the states of your devices are stored in the scene.\nWhen you leave the editor the states of the devices are restored to the state from before you started editing.\nThe menu on the top-right has options to Duplicate scene and Delete scene. A scene can be called in automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] action and scriptsScripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on.\n[Learn more] using a turn on scene serviceA service carries out one specific task, for example: turn on the light in the living room. A service has targets and data and can be called by actions, a dashboard, or via voice command.\n[Learn more]: First, check that you have activated the configuration editor. The scene editor reads and writes to the file scenes.yaml in the root of your configuration folder.\nCurrently, both the name of this file and its location are fixed.\nMake sure that you have set up the scene integration to read from it: If you still want to use your old scene section, add a label to the old entry: You can use the scene: and scene old: sections at the same time: If you want to migrate your old scenes to use the editor, you’ll have to copy them to scenes.yaml. Make sure that scenes.yaml remains a list! For each scene that you copy over, you’ll have to add an id. This can be any string as long as it’s unique. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/locked_out/#to-reset-a-users-password-as-an-owner-via-the-web-interface",
        "content": "The sections below deal with recovering from a situation where you are not able to sign in,\nor need to recover your data. If you’ve forgotten your username, ask the owner to help you.\nIf you are the owner and have forgotten your user name, then you need to prepare the system to start a new onboarding process. If you are not the owner or do not have administrator rights, ask the owner to give you a new password. If you are the owner or have administrator, there are different methods to reset a password, depending on your setup: The method used to reset a password depends on your user rights: Use this procedure only if the following conditions are met: If you are running Home Assistant in a container, you can use the command line in the container with the hass command to change your password. The steps below refer to a Home Assistant container in Docker named homeassistant. Note that while working in the container, commands will take a few moments to execute. Only the owner can change other user’s passwords. You need to be an owner or have administrator rights to delete a user. If you lose the password associated with the owner account and the steps above do not work to reset the password, the only way to resolve this is to start a new onboarding process. If you have an external backup with an administrator account of which you still know the login credentials, you can restore that backup. If you do not have a backup, resetting the device will erase all data. If you have a Home Assistant Green, reset the Green. If you have a Home Assistant Yellow, reset the Yellow. Unless your SD card/data is corrupted, you can still get to your files or troubleshoot further.\nThere are a few routes: If you’re using a Raspberry Pi, you’re likely going to have to pull the power in order to get your monitor recognized at boot. Pulling power has a risk of corrupting the SD, but you may not have another option. Most standard USB keyboards should be recognized easily. Once you’re connected, you’ll see a running dmesg log. Hit the enter key to interrupt the log.\nSign in as “root”. There is no password. You will then be at the Home Assistant CLI, where you can run the custom commands. These are the same as you would run using the SSH add-on but without using ha in front of it. For example: The files are on an EXT4 partition (hassos-data) and the path is /mnt/data/supervisor.\nThese are easily accessed using another Linux machine with EXT support. For Windows or macOS you will need third party software. Below are some options."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/packages",
        "content": "Packages in Home Assistant provide a way to bundle different integration’s configuration together. With packages we have a way to include different integrations, or different configuration parts using any of the !include directives introduced in splitting the configuration. Packages are configured under the core homeassistant/packages in the configuration and take the format of a package name (no spaces, all lower case) followed by a dictionary with the package configuration. For example, package pack_1 would be created as: The package configuration can include: switch, light, automation, groups, or most other Home Assistant integrations including hardware platforms. It can be specified inline or in a separate YAML file using !include. Inline example, main configuration.yaml: Include example, main configuration.yaml: The file my_package.yaml contains the “top-level” configuration: There are some rules for packages that will be merged: Platform based integrations (light, switch, etc) can always be merged. Integrations where entities are identified by a key that will represent the entity_id ({key: config}) need to have unique ‘keys’ between packages and the main configuration file. For example if we have the following in the main configuration. You are not allowed to re-use “my_input” again for input_boolean in a package: Any integration that is not a platform [1], or dictionaries with Entity ID keys [2] can only be merged if its keys, except those for lists, are solely defined once. One way to organize packages is to create a folder named “packages” in your Home Assistant configuration directory. In the packages directory, you can store any number of packages in a YAML file. This entry in your configuration.yaml will load all YAML-files in this packages folder and its subfolders: The benefit of this approach is to pull all configurations required to integrate a system into one file—rather than keeping them spread across several files.\nYou can use other !include methods for packages; for example !include_dir_merge_named. However, unlike !include_dir_merge_named, the !include_dir_named method uses the same indentation as the ‘configuration.yaml’. This means that you can copy and paste elements from the config file. With !include_dir_named, the file name is used as the package name. File names must be unique. With the !include_dir_merge_named method, the package name has to be included in the file. The configuration below then needs to be indented accordingly. This means you cannot directly copy and paste from the configuration file. and in packages/subsystem1/functionality1.yaml: It is possible to customize entities within packages. Just create your customization entries under: If you are moving configuration to packages, auth_providers must stay within ‘configuration.yaml’. See the general documentation for Authentication Providers. This is because Home Assistant processes the authentication provided early in the start-up process, even before packages are processed."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#sun-elevation-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/blueprint/tutorial/",
        "content": "While the tutorial only shows how to create an automation blueprint, scriptsScripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on.\n[Learn more] also support blueprints in the same way. In this tutorial, we’re going to create an automation blueprint that controls a light based on a motion sensor. We will do this by taking an existing automation and converting it to a blueprint. To create a blueprint, we first need to have a working automation.\nFor this tutorial, we use a simple automation. The process for converting a complex automation is no different. The automation we’re going to use in this tutorial controls a light based on a motion sensor: The options that can be used with the trigger object are listed under automation trigger variables.\nIn this example, a state trigger is used.\nturn_on and turn_off are homeassistant services. They are not tied to a specific domain. You can use them on lights, switches, and other domains. Automation blueprints are YAML files (with the .yaml extension) and live in the <config>/blueprints/automation/ folder. You can create as many subdirectories in this folder as you want. To get started with our blueprint, we’re going to copy the above automation YAML and save it in that directory with the name motion_light_tutorial.yaml. Home Assistant needs to know about the blueprint. This is achieved by adding a blueprint: section. It should contain the domain of the integration it is for (automation) and name, the name of your blueprint. Optionally, you can also include a description for your blueprint. Add this to the top of the file: Now we have to decide what steps we want to make configurable. We want to make it as re-usable as possible, without losing its original intent of turning on a light-based on a motion sensor. Configurable parts in blueprints are called inputs. To make the motion sensor entity configurable, we’re replacing the entity ID with a custom YAML tag !input. This YAML tag has to be combined with the name of the input: For the light, we can offer some more flexibility. We want to allow the user to be able to define any device or area as the target. The target property in the service action can contain references to areas, devices and/or entities, so that’s what we will use. Inputs are not limited to strings. They can contain complex objects too. So in this case, we’re going to mark the whole target as input: All parts that are marked as inputs need to be added to the metadata. The minimum is that we add their names as used in the automation: For more information on blueprint inputs, refer to the documentation of the blueprint schema With the bare minimum metadata added, your blueprint is ready to use. Open your configuration.yaml and add the following: Reload automations and your new automation should pop up. Because we configured the exact values as the original automation, they should work exactly the same. Blueprints are easier to use if it’s easy to see what each field is used for. We can improve this experience by adding names and descriptions to our inputs: Our blueprint doesn’t currently describe what the inputs should contain. Without this information, Home Assistant will offer the user an empty text box. To instead allow Home Assistant to offer more assistance, we will use selectors. Selectors describe a type and can be used to help the user pick a matching value. The selector for the motion sensor entity should describe that we want entities from the binary sensor domain that have the device class motion. The selector for the target light should describe that we want to target light entities. By limiting our blueprint to working with lights and motion sensors, we unlock a couple of benefits: the UI will be able to limit suggested values to lights and motion sensors instead of all devices. It will also allow the user to pick an area to control the lights in. After we have added all the steps, our blueprint will look like this:  This video tutorial explains how to create a blueprint that toggles a light on motion when the lux value is below a certain threshold.  The final step is to share this blueprint with others. For this tutorial we’re going to share it on GitHub Gists. For this tutorial, we’re going to share it on GitHub Gists. This is a good option if you don’t want to publish your blueprint to a larger audience. If you follow the Rules and format for posting, you can share your blueprint on the Home Assistant Blueprint Exchange forum. This option is accessible to the general Home Assistant community but recommended only for your original blueprints. Please don’t post this tutorial to the Blueprint Exchange, but instead, remember this as an option for releasing your real blueprints. Prerequisites Blueprints"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/using_blueprints/#re-importing-a-blueprint",
        "content": "Automation blueprints are pre-made automationsAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] that you can easily add to your Home Assistant instance. Each blueprint can be added as many times as you want. Quick links: Automations based on a blueprint need to be configured. What needs to be configured differs by blueprint. Done! If you want to revisit the configuration values, go to Settings > Automations & Scenes > Blueprints. Home Assistant can import blueprints from the Home Assistant forums, GitHub, and GitHub gists. To import a blueprint, first find a blueprint you want to import. If you just want to practice importing, you can use this URL: Go to Settings > Automations & Scenes > Blueprints. Select the blue Import Blueprint button in the bottom right. Enter the URL and select Preview. The blueprint can now be used for creating automations. Blueprints created by the community may go through multiple revisions. Sometimes a user creates a blueprint,\nthe community provides feedback, and new functionality is added. The quickest way to get these changes is by re-importing the blueprint. This will overwrite the blueprint you currently have. Blueprints created by the community may go through multiple revisions. Sometimes a user creates a blueprint,\nthe community provides feedback, and new functionality is added. If you do not want to re-import the blueprint for some reason, you can manually edit\nits YAML content to keep it up to date: The new changes will appear to your existing automations as well. The Home Assistant Community forums have a specific tag for blueprints. This tag is used to collect all blueprints. Visit the Home Assistant forums Using blueprints is nice and easy, but what if you could create that one missing\nblueprint that our community definitely needs? Learn more about blueprints by reading our tutorial on creating a blueprint. When you’re creating automations using blueprints and they don’t appear in the UI, make sure that you add back automation: !include automations.yaml from the default configuration to your configuration.yaml."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/templating#available-trigger-data",
        "content": "Automations support templating in the same way as scripts do. In addition to the Home Assistant template extensions available to scripts, the trigger and this template variables are available. The template variable this is also available when evaluating any trigger_variables declared in the configuration. The variable this is the state object of the automation at the moment of triggering the actions. State objects also contain context data which can be used to identify the user that caused a scriptScripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on.\n[Learn more] or automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] to execute. Note that this will not change while executing the actionsActions are used in several places in Home Assistant. As part of a script or automation, actions define what is going to happen once a trigger is activated. In scripts, an action is called sequence.\n[Learn more]. The variable trigger is an object that contains details about which triggerA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more] triggered the automation. Templates can use the data to modify the actions performed by the automation or displayed in a message. For example, you could create an automation that multiple sensors can trigger and then use the sensor’s location to specify a light to activate; or you could send a notification containing the friendly name of the sensor that triggered it. Each trigger platform can include additional data specific to that platform. Triggers from all platforms will include the following data. These are the properties available for a Calendar trigger. These are the properties available for a Device trigger. Inherites template variables from event or state template based on the type of trigger selected for the device. These are the properties available for a Event trigger. These are the properties available for a MQTT trigger. These are the properties available for a numeric state trigger. These are the properties available for a Sentence trigger. These are the properties available for a State trigger. These are the properties available for a Sun trigger. These are the properties available for a Template trigger. These are the properties available for a Time trigger. These are the properties available for a time pattern trigger. These properties are available for a persistent notification trigger. These are the properties available for a Webhook trigger. These are the properties available for a Zone trigger."
    },
    {
        "url": "https://www.home-assistant.io/docs/blueprint/schema/#input",
        "content": "The configuration schema of a blueprint consists of 2 parts: The first part is referred to as the blueprint schema. It contains the\nblueprint’s metadata. The only requirement for a blueprint is a name. In its most basic form,\na blueprint would look like: Although this is a valid blueprint, it is not very useful. The second part depends on the use case of the blueprint. For example, if you create a blueprint for an automation, the full\nschema for an automation applies. You can add a description of the blueprint’s use case and user inputs. This is the full blueprint schema: The name of the blueprint. Keep this short and descriptive. The description of the blueprint. While optional, this field is highly recommended. Describe what the blueprint does and describe the inputs the blueprint provide. The description can include Markdown. The domain in which this blueprint is used. Currently, only automation and script are supported. The name of the blueprint author. Home Assistant requirements to be able to use the blueprint successfully. Minimum required version of Home Assistant to use the blueprint. For example, 2022.4.0. It is important to set this if the blueprint uses any features introduced in recent releases to head off issues. A dictionary of defined user inputs. These are the input fields that the consumer of your blueprint can provide using YAML definition, or via a configuration form in the UI. The name of the input field. A short description of the input field. Keep this short and descriptive. The description can include Markdown. The selector to use for this input. A selector defines how the input is displayed in the frontend UI. The default value of this input, in case the input is not provided by the user of this blueprint. As described above, a blueprint can accept one (or multiple)\ninputs from the blueprint user. These inputs can be of any type (string, boolean, list, dictionary). They can have\na default value and also provide a selector that\nensures a matching input field in the user interface. Each input field can be referred to, outside of the blueprint metadata, using\nthe !input custom YAML tag. The following example shows a minimal blueprint with a single input: In the above example, my_input is the identifier of the input. It can be\nreferenced by using the !input my_input custom tag. In this example, no selector was provided. In the user interface, a text input field would be shown to the user.\nIt is then up to the user to find out what to enter there. Blueprints that come with selectors are easier to use. A blueprint can have as many inputs as you like. The inputs are available as custom YAML tags, but not as template variables.\nTo use a blueprint input in a template, it first needs to be exposed as either\na script level variable or in\na variable script step. The built-in blueprints\nare great examples to get a bit of a feeling of how blueprints work. Here is the built-in motion light automation blueprint:"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#trigger-id",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/customizing-devices/#device-class",
        "content": "You can use the UI to change the entity ID and friendly name of supported entities. To do this: If your entity is not supported, or you cannot customize what you need via this method, please see below for more options. By default, all of your devices will be visible and have a default icon determined by their domain. You can customize the look and feel of your front page by altering some of these parameters. This can be done by overriding attributes of specific entities. Name of the entity as displayed in the UI. URL to use as picture for entity. Any icon from Material Design Icons. Prefix name with mdi:, ie mdi:home. Note: Newer icons may not yet be available in the current Home Assistant release. For switches with an assumed state two buttons are shown (turn off, turn on) instead of a switch. By setting assumed_state to false you will get the default switch icon. Sets the class of the device, changing the device state and icon that is displayed on the UI (see below). It does not set the unit_of_measurement. Defines the units of measurement, if any. This will also influence the graphical presentation in the history visualization as continuous value. Sensors with missing unit_of_measurement are showing as discrete values. Sets the initial state for automations, on or off. Device class is currently supported by the following platforms: If you implement customize, customize_domain, or customize_glob you must make sure it is done inside of homeassistant: or it will fail. Home Assistant offers a service to reload the core configuration while Home Assistant is running. This allows you to change your customize section and see your changes being applied without having to restart Home Assistant. To reload customizations, navigate to Developer Tools > YAML and then press the “Reload Location & Customizations” button. If you don’t see this, enable Advanced Mode on your user profile page first. You can also use the Quick bar, and choose “Reload Location & Customizations”. Alternatively, you can reload via service call. Navigate to Developer Tools > Services tab, select homeassistant.reload_core_config from the dropdown and press the “Call Service” button."
    },
    {
        "url": "https://www.home-assistant.io/docs/energy/electricity-grid/",
        "content": "Energy management is all about knowing how much energy you’re consuming, where it’s coming from and where it’s going. Almost all houses are connected to the electricity grid which provides the energy your home will need. The energy usage is being tracked by your energy meter and is billed to you by your energy provider. Energy prices can differ based on a schedule or change according to market price. It has become popular for energy utilities to split the price of energy based on time of the day; this is done in order to incentivise consumers to shift their power needs towards times where the grid has lower loads. These periods of time are commonly referred to as Peak and Off Peak, exactly because they match periods of time where everyone is consuming energy (Peak) and periods of time where the energy is abundant but no one is using it (Off Peak). Therefore Peak energy is more expensive then Off Peak energy. If you want to split energy usage into multiple tariffs, read this. Home Assistant will need to know the amount of energy flowing through your meter. This data can be tracked in various ways. The best way to get this data is directly from your electricity meter that sits between your house and the grid. In certain countries these meters contain standardized ways of reading out the information locally. The P1 port is a standardized port in the Netherlands, Belgium and Luxembourg. A P1 reader can connect to this port and receive real-time information. We have worked with creator Marcel Zuidwijk to develop SlimmeLezer+. It’s an affordable P1 reader powered by ESPHome that will seamlessly integrate this information in Home Assistant. It is being sold on his website and the firmware is open source on GitHub.  The Zigbee Energy Profile is a wireless energy standard to provide real-time information about electricity usage. This standard is available in some meters in the US, UK and Australia. This is not “normal” Zigbee as implemented by Home Assistant but requires special certified hardware. We are not currently aware of a device that implements this which supports a local API and is compatible with Home Assistant. Many meters, including older ones, have an LED that will flash whenever energy passes through it. For example, each flash is a 1/1000th kWh. By monitoring the time between flashes it’s possible to determine the energy consumption. We have developed Home Assistant Glow, an open source solution powered by ESPHome’s pulse meter sensor. You put it on top of the activity LED of your electricity meter and it will bring your consumption into Home Assistant.  The IEC62056-21 is a common protocol not only for electric meters. It uses an infrared port to read data.\nAquaticus has created an ESPHome component for reading this data. PiggyMeter is a complete project that allows easy installation.\n In countries like Germany, SML (Smart Message Language) is used typically. ESPHome’s SML (Smart Message Language) is one way to integrate it. If you prefer to integrate it via MQTT, sml2mqtt is another open source option. AI-on-the-edge-device is a project running on an ESP32-CAM and can be fully integrated into Home Assistant using the Home Assistant discovery functionality of MQTT. It digitalizes your gas/water/electricity meter display and provides its data in various ways.  Current transformer (CT) clamp sensors measure your energy usage by looking at the current passing through an electrical wire. This makes it possible to calculate the energy usage. In Home Assistant we have support for off-the-shelf CT clamp sensors or you can build your own. Attention! Installing CT clamp sensor devices requires opening your electrical cabinet. This work should be done by someone familiar with electrical wiring and may require a licensed professional in some regions. Your qualified installer will know how to do this. Disclaimer: Some links in this section are affiliate links. Some energy providers will provide you real-time information about your usage and have this data integrated into Home Assistant. If you manually integrate your sensors, for example, using the MQTT or Template integrations: Make sure you set and provide the device_class, state_class, and unit_of_measurement for those sensors. If you are unable to select your energy sensor in the grid consumption drop-down, make sure that its value is being recorded in the Recorder settings. Energy integrations Disclaimer: Some links on this page are affiliate links helping support the Home Assistant project."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/action/",
        "content": "The action of an automation rule is what is being executed when a rule fires. The action part follows the script syntax which can be used to interact with anything via services or events. For servicesA service carries out one specific task, for example: turn on the light in the living room. A service has targets and data and can be called by actions, a dashboard, or via voice command.\n[Learn more], you can specify the entity_id that it should apply to and optional service parameters (to specify for example the brightness). You can also call the serviceA service carries out one specific task, for example: turn on the light in the living room. A service has targets and data and can be called by actions, a dashboard, or via voice command.\n[Learn more] to activate a scene which will allow you to define how you want your devices to be and have Home Assistant call the right services. Conditions can also be part of an action. You can combine multiple service calls and conditions in a single action, and they will be processed in the order you put them in. If the result of a condition is false, the action will stop there so any service calls after that condition will not be executed."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#zone-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/troubleshooting/",
        "content": "It can happen that you run into trouble while installing Home Assistant. This page is here to help you solve the most common problems. This utility should have been installed as part of the Python installation. Check if Python is installed by running python3 --version. If it is not installed, download it here. If you are able to successfully run python3 --version but not pip3, install Home Assistant by running the following command instead: On a Debian system, you can also install python3 by sudo apt-get install python3, and pip3 by sudo apt-get install python3-pip. Pip should come bundled with the latest Python 3 but is omitted by some distributions. If you are unable to run python3 -m pip --version you can install pip by downloading the installer and running it with Python 3: In newer Linux distributions the access to a host is very limited. This means that you can’t access the Home Assistant frontend that is running on a host outside of the host machine. To fix this you will need to open your machine’s firewall for TCP traffic to port 8123. The method for doing this will vary depending on your operating system and the firewall you have installed. Below are some suggestions to try. Google is your friend here. For UFW systems (Ubuntu, Debian, Raspberry Pi OS, etc.): For iptables systems (was the default for older distributions): On small systems (such as a Pi2), not directly supported by binaries (Python Wheels) you may run out of memory.\nUpon the first run or after an upgrade, Home Assistant uses a lot of resources to (re)compile all the integrations.\nIf you run out of memory and/or swap memory, your system will freeze.\nIncreasing swap memory can help: Modify the line the sets the swapfile size. Set it equal to your memory or double your current setting: CONF_SWAPSIZE = 925 then:"
    },
    {
        "url": "https://www.home-assistant.io/docs/scripts/service-calls/#homeassistant-services",
        "content": "Various integrations allow calling servicesA service carries out one specific task, for example: turn on the light in the living room. A service has targets and data and can be called by actions, a dashboard, or via voice command.\n[Learn more] when a certain event occurs. The most common one is calling a service when an automation triggerA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more] happens. But a service can also be called from a scriptScripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on.\n[Learn more], a dashboard or via voice command devices such as Amazon Echo. The configuration options to call a configuration are the same between all integrations and are described on this page. Examples on this page will be given as part of an automation integration configuration but different approaches can be used for other integrations too. Call the service homeassistant.turn_on on the entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] group.living_room. This will turn all members of group.living_room on. You can also use entity_id: all and it will turn on all possible entities. Instead of targeting an entity, you can also target an areaAn area in Home Assistant is a logical grouping of devices and entities that are meant to match areas (or rooms) in the physical world: your home. For example, the living room area groups devices and entities in your living room. or deviceA device is a model representing a physical or logical unit that contains entities.\n. Or a combination of these.\nThis is done with the target key. A target is a map that contains at least one of the following: area_id, device_id, entity_id.\nEach of these can be a list. The following example uses a single service call to turn on the lights in the\nliving room area, 2 additional light devices and 2 additional light entities: You can also specify other parameters beside the entity to target. For example, the light.turn_on service allows specifying the brightness. A full list of the parameters for a service can be found on the documentation page of each integration, in the same way as it’s done for the light.turn_on service. You can use templating support to dynamically choose which service to call. For example, you can call a certain service based on if a light is on. You can use the Services Developer Tool to test data to pass in a service call.\nFor example, you may test turning on or off a ‘group’ (See [groups] for more info) To turn a group on or off, pass the following info: Templates can also be used for the data that you pass to the service call. You can use a template returning a native dictionary as well, which is useful if the attributes to be set depend on the situation. Some services may respond with data that can be used in automation. This data is called service response data. Service response data\nis typically used for data that is dynamic or large and which may not be suited for use in entity state.\nExamples of service response data are upcoming calendar events for the next week or detailed driving directions. Templates can also be used for handling response data. The service call can specify\na response_variable. This is the variable\nthat contains the response data. You can define any name for your response_variable. This example calls a service and stores the response in the variable called agenda. You may then use the response data in the variable agenda in another action\nin the same script. The example below sends a notification using the response\ndata. There are four homeassistant services that aren’t tied to any single domain, these are: Complete service details and examples can be found on the Home Assistant integration page."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/troubleshooting/",
        "content": "It can happen that you run into trouble while configuring Home Assistant. Perhaps an integration is not showing up or is acting strangely. This page will discuss a few of the most common problems. Before we dive into common issues, make sure you know where your configuration directory is. Home Assistant will print out the configuration directory it is using when starting up. Whenever an integration or configuration option results in a warning, it will be stored in home-assistant.log in the configuration directory. This file is reset on start of Home Assistant. When an integration does not show up, many different things can be the case. Before you try any of these steps, make sure to look at the home-assistant.log file and see if there are any errors related to your integration you are trying to set up. If you have incorrect entries in your configuration files you can use the configuration check command (below) to assist in identifying them. One of the most common problems with Home Assistant is an invalid configuration.yaml or other configuration file. Home Assistant provides a CLI that allows you to see how it interprets them, each installation type has its own section in the common-tasks about this: The configuration files, including configuration.yaml must be UTF-8 encoded. If you see error like 'utf-8' codec can't decode byte, edit the offending configuration and re-save it as UTF-8. You can verify your configuration’s YAML structure using this online YAML parser or YAML Validator. To learn more about the quirks of YAML, read YAML IDIOSYNCRASIES by SaltStack (the examples there are specific to SaltStack, but do explain YAML issues well). configuration.yaml does not allow multiple sections to have the same name. If you want to load multiple platforms for one integration, you can append a number or string to the name or nest them: Another common problem is that a required configuration setting is missing. If this is the case, the integration will report this to home-assistant.log. You can have a look at the various integration pages for instructions on how to setup the integrations. See the logger integration for instructions on how to define the level of logging you require for specific modules. If you find any errors or want to expand the documentation, please let us know. Almost all integrations have external dependencies to communicate with your devices and services. Sometimes Home Assistant is unable to install the necessary dependencies. If this is the case, it should show up in home-assistant.log. The first step is trying to restart Home Assistant and see if the problem persists. If it does, look at the log to see what the error is. If you can’t figure it out, please report it so we can investigate what is going on. It can happen that some integrations either do not work right away or stop working after Home Assistant has been running for a while. If this happens to you, please report it so that we can have a look. If you are using multiple files for your setup, make sure that the pointers are correct and the format of the files is valid. It’s important to understand the different types of !include and how the contents of each file should be structured - more information on the various methods of splitting your configuration into multiple files can be found here. Contents of lights.yaml (notice it does not contain light:): Contents of sensors.yaml: The only characters valid in entity names are: If you create an entity with other characters then Home Assistant may not generate an error for that entity. However you will find that attempts to use that entity will generate errors (or possibly fail silently). The first thing you will need before reporting an issue online is debug logs and diagnostics (if available) for the integration giving you trouble. Getting those ahead of time will ensure someone can help resolve your issue in the fastest possible manner. To enable debug logging for an integration, go to Settings > Devices & Services > Integrations and go to the detail page of the integration. Select the Enable Debug Logging button on the left side of the integration detail page. \n\nExample of Enable debug logging.\n Once you enable debug logging, you ideally need to make the error happen. Run your automation, change up your device or whatever was giving you an error and then come back and disable the debug logging. Disabling the debug logging is the same as enabling, but now the button says Disable Debug Logging. After you disable it, you will be automatically prompted you to download your log file. Save this to a safe location to upload later. After you download logs, you will also want to download the diagnostics for the integration giving you trouble. If the integration provides diagnostics, it will appear in the three dot menu next to the integration configuration. \n\nExample of Download Diagnostics.\n"
    },
    {
        "url": "https://www.home-assistant.io/docs/tools/quick-bar/#command-palette",
        "content": "The Quick bar allows you to quickly look up entities or run commands without needing to navigate away from your current view (Similar to the “quick open” feature in VS Code, Chrome Developer Tools, etc). It can be launched from anywhere in the frontend using hotkeys. \n\nQuick Bar for accessing entities and running commands\n Type these from anywhere in the application to launch the dialog. Hotkey: e Similar to Settings -> Devices & Services -> Entities, but more lightweight and accessible from anywhere in the frontend. \n\nFilter for entities in Quick Bar's entity filter mode\n Once launched, start typing your entity id (or “bits and pieces” of your entity id) to get back a filtered list of entities. Clicking on an entity (or hitting enter when the desired entity is highlighted) will open the “More Info” dialog for that entity. This is helpful when, say, you are in the middle of writing an automation and need some quick insight about an entity but don’t want to navigate away to Developer Tools. Hotkey: c Run various commands from anywhere without having to navigate to another view. \n\nRun commands in Quick Bar's \"command palette\"\n Hotkey: m Create my links from any supported page in the user interface, when invoked on a supported page it will open a new tab that will allow you to share the link in different formats. You can enable or disable all of Home Assistant’s keyboard shortcuts by going to your User Profile and clicking the “Keyboard Shortcuts” toggle button. \n\nToggle button for enabling/disabling keyboard shortcuts added by Home Assistant.\n We know something like “light.ch” should match “light.chandelier”. Similarly, “telev” should match “media_player.television”. But with Quick Bar, “lich” would also match “light.chandelier”, and “plyrtv” would also match “media_player.television”. It checks letter sequences rather than exact substrings. One nice use-case for this is that you can quickly filter out an entire domain of entities with just a couple letters and a period. For example, “li.” will match any “light.*” entities. Continuing with “li.ch” would bring up the chandelier right away. If “light.hue_ceiling_light” has been named “Chandelier”, you can type either “hue_ceil” or “chand” to find it. As soon as the item you wanted shows up at the top of your filtered results, just hit “enter” to activate it – no need to arrow down to the item, or click with your mouse. When in the text field, use the down arrow ↓ to navigate down the item list. Hit enter to activate the currently-highlighted row. When in the item list, use the up arrow ↑ to navigate up the item list, and to get back into the text field. Say you’ve just used arrow keys to navigate half-way down the list, and want to add more text to your filter. You don’t need to click back into the text field, just start typing new letters and they’ll append to your filter. There are a few possible reasons why the quick bar dialog won’t launch: The command list only shows commands that are available to you based on your user settings, and loaded integrations. For example, if you don’t have automations: in your config, then you won’t see the “Reload Automations” command. If “Advanced Mode” is turned off in User Settings, then any command related to advanced mode will not appear in the list. If a command is missing that you feel is in error, please create an issue on GitHub. You can disable shortcuts in your User settings. Please consider submitting an issue explaining why the shortcut was disruptive to you. Keyboard shortcuts are new to Home Assistant, and getting them right is a challenge for any Web application. We rely on user feedback to ensure the experience is minimally-disruptive."
    },
    {
        "url": "https://www.home-assistant.io/docs/glossary/",
        "content": "Actions are used in several places in Home Assistant. As part of a script or automation, actions define what is going to happen once a trigger is activated. In scripts, an action is called sequence.\nActions use service calls and/or scenes to interact with entities and cause these entities to do something. Actions can also include conditions and a delay. An action can call multiple services at the same time. For example, if your presence is detected in a room, an action may call one service to turn on a light and call another service to start playing music after a delay.\nActions are also used on the dashboard, for example as tap or hold action on a UI element. When triggered, the action calls a service. Add-ons are additional standalone third-party software packages that can be installed on Home Assistant OS. Most of these, add-on provided, applications can be integrated into Home Assistant using integrations. Examples of add-ons are: an MQTT broker, database service or a file server. An area in Home Assistant is a logical grouping of devices and entities that are meant to match areas (or rooms) in the physical world: your home. For example, the living room area groups devices and entities in your living room. Areas allow you to target service calls at an entire group of devices. For example, turning off all the lights in the living room. Locations within your home such as living room, dance floor, etc. Areas can also be used for automatically generated cards, such as the Area card. Automations connect one or more triggers to one or more actions in a ‘when trigger then do action’ fashion with additional optional conditions. For example, an automation might connect the trigger ‘sunset’ to the action ‘turn the lights on’ but only if the condition ‘someone is home’ is met. Pre-made automations for common use-cases are available via the blueprints feature. Home Assistant has built-in functionality to create files containing a copy of your configuration. This can be used to restore your Home Assistant as well as migrate to a new system. The backup feature is available on some installation types. A binary sensor returns information about things that only have two states - such as on or off. A blueprint is a script or automation configuration with certain parts marked as configurable. This allows users to create multiple scripts or automations based on the same blueprint, with each having its own configuration-specific settings. Blueprints are shared by the community on the blueprints exchange in the forum. In the context of Matter devices, commissioning is the process of adding a device to a Matter controller. It is the equivalent of pairing a device in Zigbee or Z-Wave. Commissioning is done by scanning a QR code or entering a code manually. The code is printed on the device or its packaging. The code contains information about the device, such as its type, manufacturer, and serial number. The controller uses this information to identify the device and to download the required information to control the device. For example, the controller downloads the device’s capabilities, such as the supported commands and the available attributes. The controller also downloads the device’s configuration, such as the device’s name and location. Better known as: Integrations. Integrations used to be known as components. Conditions are an optional part of an automation that will prevent an action from firing if they are not met. Covers are devices such as blinds, garage doors, etc that can be opened and closed and optionally set to a specific position. Customization allows you to overwrite the default parameters of your devices in the configuration. A device is a model representing a physical or logical unit that contains entities.\nExample for a device as a physical unit\nA smart plug named ‘Coffee machine’ which provides 2 entities: a switch entity to turn power on or off (‘Coffee machine power switch’) and a sensor entity for power monitoring (‘Coffee machine power sensor’).\nExample for a device as a logical unit\nAn ecobee thermostat with 4 room sensors. This thermostat is seen as 5 devices in Home Assistant: 1 device for the thermostat with 4 sensors, and 1 device for each room sensor. Each device can be in a different area and may have more than one input or output within that area.\nDevices have properties such as ID, manufacturer, name, model, hardware version, firmware version, connections, etc. Device trackers are used to track the presence, or location, of a device. Discovery is the automatic setup of zeroconf/mDNS and uPnP devices after they are discovered. Each integration in Home Assistant has a unique identifier: a domain. All of the entities and services available in Home Assistant are provided by integrations and thus belong to such a domain. The first part of the entity or service, before the . shows the domain they belong to. For example light.kitchen is an entity in the light domain from the light integration, while hue.activate_scene is the activate_scene service for the hue domain which belongs to the Hue integration. An entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service. Entities have states.\nExample for entities as part of a device\nA combined temperature and humidity sensor device provides two sensor entities. One for temperature (e.g. sensor.temperature with state 21.0 and unit °C) and one for humidity\n(e.g. sensor.humidity with state 65.4 and unit %).\nExample for entities as part of a service\nA weather service that provides 3 entities: wind speed, air pressure, and ozon level.\nExample of an entity used for control\nA fan that is turned on when the temperature exceeds 30 °C.\nThere are standardized types of entities for common integrations such as light, switch, camera, sensor, fan, or vacuum.\nSome entities are not part of a device or service. Examples of standalone entities are automation, script, scene entities, and helper entities (e.g. input helpers).\nMost properties of entities are related to the state. Entities have optional attributes such as friendly name, unit of measurement, and an icon or picture that can be displayed in the frontend. An event is when something happens. The frontend is a necessary component for the UI, it is also where you can define your themes. Groups are a way to organize your entities into a single unit. HASS or hass is often used as an abbreviation for Home Assistant. It is also the command-line tool. Another name for Home Assistant Operating System Home Assistant Core is a Python program. It can be run on various operating systems and is the basis for Home Assistant. When people are talking about Home Assistant Core they usually refer to a standalone installation method that can be installed using a Virtual Environment or Docker. Home Assistant Core does not use the Home Assistant Supervisor. Home Assistant OS, the Home Assistant Operating System, is an embedded, minimalistic, operating system designed to run the Home Assistant ecosystem on single board computers (like the Raspberry Pi) or Virtual Machines. The Home Assistant Supervisor can keep it up to date, removing the need for you to manage an operating system. Home Assistant Operating System is the recommended installation method for most users. Home Assistant Supervised is a full UI managed home automation ecosystem that runs Home Assistant, the Home Assistant Supervisor and add-ons. It comes pre-installed on Home Assistant OS, but can be installed on any Linux system. It leverages Docker, which is managed by the Home Assistant Supervisor. The Home Assistant Supervisor is a program that manages a Home Assistant installation, taking care of installing and updating Home Assistant, add-ons, itself and, if used, updating the Home Assistant Operating System. A device that can communicate with other devices on a network. During setup and configuration, an input requesting a Host typically refers to a device’s network address so that Home Assistant can attempt to connect to it. This may be in the form of a hostname, URL, IP address or some other type of network identifier. If you do not know the hostname or IP address of a device, you can find it in your router’s webinterface. For example, if your device is connected wirelessly, somewhere there is a page listing all the devices that are connected to your network. It depends on your router, where exactly this page is. It could be under Network > Wireless. Integrations connect and integrate Home Assistant with devices, services, and more. They contain all the logic to handle vendor- and device-specific implementations, such as authentication or specific protocols. The integration brings such device-specific elements into Home Assistant in a standardized way. For example, the Hue integration integrates the Philips Hue bridge and its connected bulbs into Home Assistant, making them available as Home Assistant light entities you can control. Intent is a term used with voice assistants. The intent is what Home Assistant thinks you want it to do when it extracts a command from your voice or text utterance. Currently, the following intents are supported out of the box: HassTurnOn, HassTurnOff, HassGetState, and HassLightSet. These intents allow you to turn things on or off, inquire about a state, or change the brightness or color of a light. A light has a brightness you can control, and optionally color temperature or RGB color control. Lovelace is the original code name of the UI that is now known as Home Assistant dashboards. Matter is an open-source standard that defines how to control smart home devices on a Wi-Fi or Thread network. The aim of the standard is to improve security and to make devices interoperable across vendors, replacing proprietary protocols for smart home ecosystems. Unlike other standards, Matter allows joining the same device to multiple controllers. For example, you can add a light to Google Home, Apple Home, and Home Assistant at the same time. A bridge device can be used to connect devices running on other smart home technologies such as Zigbee or Z-Wave. You can use notifications to send messages, pictures, and more, to devices. Packages allow you to bundle different component configurations together. Platforms are building blocks provided by some integrations to be used by other integrations. For example, the Light integration provides the light platform that is utilized by all integrations providing light entities such as e.g. Hue. Applies the changes made to the Home Assistant configuration files. Changes are normally automatically updated. However, changes made outside of the front end will not be reflected in Home Assistant and require a reload. To perform a manual reload, go to Settings > System > Restart Home Assistant (top right) > Quick reload. If you do not see the Quick reload option in the menu, you need to enable Advanced mode in your user settings. More granular reload options are available in YAML configuration reloading section in Developer tools > YAML. Scenes capture the states you want certain entities to be. For example, a scene can specify that light A should be turned on and light B should be bright red. Scripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on. Selectors are components for the user interface. Some selectors can, for example, show a toggle button to turn something on or off, while another select can filter a list of devices to show only devices that have motion-sensing capabilities. Sensors return information about a thing, for instance the level of water in a tank. The term service has 2 meanings in Home Assistant:\nThe information service\nFor example, the municipal waste management service that provides entities for organic, paper, and packaging waste. In terms of functionality, the information service is like a device. It is called service to avoid confusion, as it does not come with a piece of hardware.\nThe software function that interacts with targets to make something happen\nA service carries out one specific task, for example: turning on the light in the living room or sending a notification to a mobile phone.\nA service has targets and data. Service targets are: areas, devices, and entities. Service data carries the information required to define the desired state change in the target. For example, the target, together with brightness 150 and RGB color [255,0,0], or the message “Your coffee is ready”.\nServices can be used in, for example, automation, scripts, dashboards, or voice commands to control your home.\nHome Assistant provides a series of predefined services, such as homeassistant.turn_on, homeassistant.toggle, or homeassistant.reload. The state holds the information of interest of an entity. For example, if a light is on or off, the current temperature, or the amount of energy used. The data type of state is string (a textual value). Entities store 2 timestamps related to the state: last_updated and last_changed. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state. For example, the state of a light is on, and the related state attributes could be its current brightness and color values.\nState changes can be used as the source of triggers. The current state can be used in conditions. Switches are things that have two states you can select between, such as turning on or off a socket. TTS (text-to-speech) allows Home Assistant to talk to you. A template is an automation definition that can include variables for the service or data from the trigger values. This allows automations to generate dynamic actions. Thread is a low-power mesh networking standard that is specifically designed for smart home applications. It is a protocol that defines how devices communicate. Mesh topology means that the devices can communicate with each other directly, without going through a central controller first. Thread uses the same radio frequency (RF) technology as Zigbee, but provides IP connectivity similar to Wi-Fi. Unlike Zigbee, Thread does not specify how to control devices. How Thread-enabled devices are controlled is specified in a higher level protocol such as HomeKit or Matter. A Thread border router forwards data packets between your local network and the Thread network. This enables smart home devices within a Thread network to communicate with IPv6-capable devices in your local network. A Thread border router is connected to your network either via Wi-Fi or Ethernet and uses its radio frequency (RF) radio to communicate with the Thread mesh network. In case of Matter, the data that is forwarded is encrypted. Examples of Thread border routers are the Nest Hub (2nd gen), the HomePod mini, and the Home Assistant SkyConnect together with the OpenThread Border Router add-on. A trigger is a set of values or conditions of a platform that are defined to cause an automation to run. Valves are devices to control the flow of liquids and gases. All valves in Home Assistant can be opened and closed. Some valves can also be set to a specific position. Variables are used to store values in memory that can be processed for example, in a script. Zones are areas that can be used for presence detection."
    },
    {
        "url": "https://www.home-assistant.io/docs/energy/individual-devices/",
        "content": "Home Assistant can integrate the energy usage of individual devices into Home Assistant. That way you can see the impact of individual devices on your total energy consumption. Smart plugs sit between the device and the outlet and measure the energy flowing through the device. Depending on what protocols you use at home, you can use Zigbee, Z-Wave or Wi-Fi based plugs. Smart relays sit behind your “normal” switches and make them smart. It allows you to control the devices via Home Assistant and via the connected buttons/switches. Some smart devices, such as air conditioning, boilers, and others, may provide a power sensor, measured in Watts. You can use the Integration (Riemann sum integral) integration to calculate the energy your device is using. You can then use the energy sensor in the Energy Dashboard, as individual devices."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#calendar-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/authentication/",
        "content": "The authentication system secures access to Home Assistant. You are greeted with a log in screen, asking you for user name and password. When you start Home Assistant for the first time, the owner user account is created. This account has some special privileges and can: Once you’re logged in, you can see the details of your account at the Profile page by clicking on the circular at the very bottom of the sidebar. You can: Make sure to choose a secure password! At some time in the future, you will probably want to access Home Assistant from outside your local network. This means you are also exposed to random black-hats trying to do the same. Treat the password like the key to your house. As an extra level of security, you can turn on multi-factor authentication. Home Assistant provides several ways to authenticate. See the Auth providers section. If you’re seeing authentication failures from 127.0.0.1 and you’re using the nmap device tracker, you should exclude the Home Assistant IP from being scanned. Under the new authentication system you’ll see the following warning logged when the legacy API password is supplied, but not configured in Home Assistant: If you see this, you need to add an api_password to your http: configuration. If you see the following, then this is a message for integration developers, to tell them they need to update how they authenticate to Home Assistant. As an end user you don’t need to do anything: If you lose the password associated with the owner account, you need to start a new onboarding process. You have to use a domain name, not IP address, to remote access Home Assistant otherwise you will get Error: invalid client id or redirect url error on the login form. However, you can use the IP address to access Home Assistant in your home network. This is because we only allow an IP address as a client ID when your IP address is an internal network address (e.g., 192.168.0.1) or loopback address (e.g., 127.0.0.1). If you don’t have a valid domain name for your Home Assistant instance, you can modify the hosts file on your computer to fake one.\nOn Linux edit the /etc/hosts file, and add following entry: Replace 12.34.56.78 with your Home Assistant’s public IP address. This will allow you to open Home Assistant at http://homeassistant.home:8123/ Some ad blocking software, such as Wipr, also blocks WebSockets. If you’re stuck on the Loading data screen, try disabling your ad blocker. If you were using the authentication system before 0.77, you’d likely have auth: and auth_providers: defined. You’ll need to remove these and let Home Assistant handle it automatically."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#state-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/scripts/service-calls/",
        "content": "Various integrations allow calling servicesA service carries out one specific task, for example: turn on the light in the living room. A service has targets and data and can be called by actions, a dashboard, or via voice command.\n[Learn more] when a certain event occurs. The most common one is calling a service when an automation triggerA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more] happens. But a service can also be called from a scriptScripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on.\n[Learn more], a dashboard or via voice command devices such as Amazon Echo. The configuration options to call a configuration are the same between all integrations and are described on this page. Examples on this page will be given as part of an automation integration configuration but different approaches can be used for other integrations too. Call the service homeassistant.turn_on on the entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] group.living_room. This will turn all members of group.living_room on. You can also use entity_id: all and it will turn on all possible entities. Instead of targeting an entity, you can also target an areaAn area in Home Assistant is a logical grouping of devices and entities that are meant to match areas (or rooms) in the physical world: your home. For example, the living room area groups devices and entities in your living room. or deviceA device is a model representing a physical or logical unit that contains entities.\n. Or a combination of these.\nThis is done with the target key. A target is a map that contains at least one of the following: area_id, device_id, entity_id.\nEach of these can be a list. The following example uses a single service call to turn on the lights in the\nliving room area, 2 additional light devices and 2 additional light entities: You can also specify other parameters beside the entity to target. For example, the light.turn_on service allows specifying the brightness. A full list of the parameters for a service can be found on the documentation page of each integration, in the same way as it’s done for the light.turn_on service. You can use templating support to dynamically choose which service to call. For example, you can call a certain service based on if a light is on. You can use the Services Developer Tool to test data to pass in a service call.\nFor example, you may test turning on or off a ‘group’ (See [groups] for more info) To turn a group on or off, pass the following info: Templates can also be used for the data that you pass to the service call. You can use a template returning a native dictionary as well, which is useful if the attributes to be set depend on the situation. Some services may respond with data that can be used in automation. This data is called service response data. Service response data\nis typically used for data that is dynamic or large and which may not be suited for use in entity state.\nExamples of service response data are upcoming calendar events for the next week or detailed driving directions. Templates can also be used for handling response data. The service call can specify\na response_variable. This is the variable\nthat contains the response data. You can define any name for your response_variable. This example calls a service and stores the response in the variable called agenda. You may then use the response data in the variable agenda in another action\nin the same script. The example below sends a notification using the response\ndata. There are four homeassistant services that aren’t tied to any single domain, these are: Complete service details and examples can be found on the Home Assistant integration page."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/templating/",
        "content": "Automations support templating in the same way as scripts do. In addition to the Home Assistant template extensions available to scripts, the trigger and this template variables are available. The template variable this is also available when evaluating any trigger_variables declared in the configuration. The variable this is the state object of the automation at the moment of triggering the actions. State objects also contain context data which can be used to identify the user that caused a scriptScripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on.\n[Learn more] or automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] to execute. Note that this will not change while executing the actionsActions are used in several places in Home Assistant. As part of a script or automation, actions define what is going to happen once a trigger is activated. In scripts, an action is called sequence.\n[Learn more]. The variable trigger is an object that contains details about which triggerA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more] triggered the automation. Templates can use the data to modify the actions performed by the automation or displayed in a message. For example, you could create an automation that multiple sensors can trigger and then use the sensor’s location to specify a light to activate; or you could send a notification containing the friendly name of the sensor that triggered it. Each trigger platform can include additional data specific to that platform. Triggers from all platforms will include the following data. These are the properties available for a Calendar trigger. These are the properties available for a Device trigger. Inherites template variables from event or state template based on the type of trigger selected for the device. These are the properties available for a Event trigger. These are the properties available for a MQTT trigger. These are the properties available for a numeric state trigger. These are the properties available for a Sentence trigger. These are the properties available for a State trigger. These are the properties available for a Sun trigger. These are the properties available for a Template trigger. These are the properties available for a Time trigger. These are the properties available for a time pattern trigger. These properties are available for a persistent notification trigger. These are the properties available for a Webhook trigger. These are the properties available for a Zone trigger."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/troubleshooting/",
        "content": "When an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] is run, all steps are recorded and a trace is made. From the UI, open Settings, which is located in the sidebar, then select Automations & Scenes to go to the automation editor or click this button directly:  Click on the clock icon next to an automation to enter the debugging screen. Alternatively, click on Show trace directly from a Logbook automation entry.  The above screenshot shows a previous run of an automation. The automation is displayed using an interactive graph, highlighting which path the automation took. Each node in the graph can be clicked to view the details on what happened with the automation during that specific step. It traces the complete run of an automation. The debugging screen is split into four features, the first being the Step Details which provides all details for each step of the automation. The second feature is the Trace Timeline which the screenshot above shows and where the automation can be followed on a timeline. The next is Related logbook entries, as the name says a logbook for all the entries related to the specific trace. The last two features are Automation Config and optionally Blueprint Config for the automation YAML code. Automations created in YAML must have an id assigned in order for debugging traces to be stored. The last 5 traces are recorded for all automations. It is possible to change this by adding the following code to your automation. It is generally a difficult task to test an automation, especially if it includes several triggers and some conditions. Please note that if you click on Trigger of an automation in the frontend, only the action part will be executed by Home Assistant. That means you can’t test your trigger or condition part that way. It also means that if your automation uses some data from triggers, it won’t work properly as well just because trigger is not defined in this scenario. All this makes that Trigger feature pretty limited and nearly useless for debugging purposes so you need to find another way.\nMake sure you check and adapt to your circumstances appropriate examples from Automation Trigger, Conditions and Actions. It is also useful to go to Developer Tools -> YAML and click on Check Configuration button in Configuration validation section to make sure there are no syntax errors before restarting Home Assistant. In order for Check configuration to be visible, you must enable Advanced Mode on your user profile. If your automation uses templates in any part, you can do the following to make sure it works as expected:"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger#event-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/scripts/conditions/#logical-conditions",
        "content": "Conditions can be used within a scriptScripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on.\n[Learn more] or automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] to prevent further execution. When a condition evaluates true, the script or automation will be executed. If any other value is returned, the script or automation stops executing. A condition will look at the system at that moment. For example, a condition can test if a switch is currently turned on or off. Unlike a triggerA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more], which is always or, conditions are and by default - all conditions have to be true. All conditions support an optional alias. Test multiple conditions in one condition statement. Passes if all embedded conditions are true. If you do not want to combine AND and OR conditions, you can list them sequentially. The following configuration works the same as the one listed above: Currently you need to format your conditions like this to be able to edit them using the automations editor. The AND condition also has a shorthand form. The following configuration works the same as the ones listed above: Test multiple conditions in one condition statement. Passes if any embedded condition is true. The OR condition also has a shorthand form. The following configuration works the same as the one listed above: Test multiple AND and OR conditions in one condition statement. Passes if any embedded condition is true.\nThis allows you to mix several AND and OR conditions together. Or in shorthand form: Test multiple conditions in one condition statement. Passes if all embedded conditions are not true. The NOT condition also has a shorthand form. The following configuration works the same as the one listed above: This type of condition attempts to parse the state of the specified entity or the attribute of an entity as a number, and triggers if the value matches the thresholds. If both below and above are specified, both tests have to pass. You can optionally use a value_template to process the value of the state before testing it. It is also possible to test the condition against multiple entities at once.\nThe condition will pass if all entities match the thresholds. Alternatively, the condition can test against a state attribute.\nThe condition will pass if the attribute value of the entity matches the thresholds. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below\noptions to make the condition more dynamic. Tests if an entity has a specified state. It is also possible to test the condition against multiple entities at once.\nThe condition will pass if all entities match the state. Instead of matching all, it is also possible if one of the entities matches.\nIn the following example the condition will pass if any entity matches the state. Testing if an entity is matching a set of possible conditions;\nThe condition will pass if the entity matches one of the states given. Or, combine multiple entities with multiple states. In the following example,\nboth media players need to be either paused or playing for the condition to pass. Alternatively, the condition can test against a state attribute.\nThe condition will pass if the attribute matches the given state. Finally, the state option accepts helper entities (also known as input_*\nentities). The condition will pass if the state of the entity matches the state\nof the given helper entity. You can also use templates in the for option. The for template(s) will be evaluated when the condition is tested. The sun state can be used to test if the sun has set or risen. The sun elevation can be used to test if the sun has set or risen, it is dusk, it is night, etc. when a trigger occurs.\nFor an in-depth explanation of sun elevation, see sun elevation trigger. The sun condition can also test if the sun has already set or risen when a trigger occurs. The before and after keys can only be set to sunset or sunrise. They have a corresponding optional offset value (before_offset, after_offset) that can be added, similar to the sun trigger. Note that if only before key is used, the condition will be true from midnight until sunrise/sunset. If only after key is used, the condition will be true from sunset/sunrise until midnight. If both before: sunrise and after: sunset keys are used, the condition will be true from midnight until sunrise and from sunset until midnight. If both after: sunrise and before: sunset keys are used, the condition will be true from sunrise until sunset. This is an example of 1 hour offset before sunset: This is ‘when dark’ - equivalent to a state condition on sun.sun of below_horizon: This is ‘when light’ - equivalent to a state condition on sun.sun of above_horizon: A visual timeline is provided below, showing an example of when these conditions are true. In this chart, sunrise is at 6:00, and sunset is at 18:00 (6:00 PM). The green areas of the chart indicate when the specified conditions are true.  The template condition tests if the given template renders a value equal to true. This is achieved by having the template result in a true boolean expression or by having the template render True. Within an automation, template conditions also have access to the trigger variable as described here. The template condition has a shorthand notation that can be used to make your scripts and automations shorter. For example: Or in a list of conditions, allowing to use existing conditions as described in this\nchapter and one or more shorthand template conditions This shorthand notation can be used everywhere in Home Assistant where\nconditions are accepted. For example, in and, or\nand not conditions: It’s also supported in the repeat action’s while or until option, or in a choose action’s conditions option: It’s also supported in script or automation condition actions: The time condition can test if it is after a specified time, before a specified time or if it is a certain day of the week. Valid values for weekday are mon, tue, wed, thu, fri, sat, sun.\nNote that if only before key is used, the condition will be true from midnight until the specified time.\nIf only after key is used, the condition will be true from the specified time until midnight.\nTime condition windows can span across the midnight threshold if both after and before keys are used. In the example above, the condition window is from 3pm to 2am. A better weekday condition could be by using the Workday Binary Sensor. For the after and before options a time helper (input_datetime entity)\nor another sensor entity containing a timestamp with the “timestamp” device\nclass, can be used instead. Please note that the time condition only takes the time into account. If\na referenced sensor or helper entity contains a timestamp with a date, the\ndate part is fully ignored. The trigger condition can test if an automation was triggered by a certain trigger, identified by the trigger’s id. For a trigger identified by its index, both a string and integer is allowed: It is possible to give a list of triggers: Zone conditions test if an entity is in a certain zone. For zone automation to work, you need to have set up a device tracker platform that supports reporting GPS coordinates. It is also possible to test the condition against multiple entities at once.\nThe condition will pass if all entities are in the specified zone. Testing if an entity is matching a set of possible zones;\nThe condition will pass if the entity is in one of the zones. Or, combine multiple entities with multiple zones. In the following example,\nboth entities need to be either in the home or the work zone for the condition\nto pass. Every individual condition can be disabled, without removing it.\nTo do so, add enabled: false to the condition configuration. This can be useful if you want to temporarily disable a condition, for example,\nfor testing. A disabled condition will behave as if it were removed. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/",
        "content": "The documentation covers beginner to advanced topics around the installation, setup, configuration, and usage of Home Assistant. To see what Home Assistant can do, take a look at the demo page."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/templating",
        "content": "This is an advanced feature of Home Assistant. You’ll need a basic understanding of: Templating is a powerful feature that allows you to control information going into and out of the system. It is used for: Templating in Home Assistant is powered by the Jinja2 templating engine. This means that we are using their syntax and make some custom Home Assistant variables available to templates during rendering. Jinja2 supports a wide variety of operations: We will not go over the basics of the syntax, as Jinja2 does a great job of this in their templates documentation. The frontend has a template editor tool to help develop and debug templates. Navigate to Developer Tools > Template, create your template in the Template editor and check the results on the right. Templates can get big pretty fast. To keep a clear overview, consider using YAML multiline strings to define your templates: There are a few very important rules to remember when adding templates to YAML: Remembering these simple rules will help save you from many headaches and endless hours of frustration when using automation templates. Jinja supports a set of language extensions that add new functionality to the language.\nTo improve the experience of writing Jinja templates, we have enabled the following\nextensions: You can write reusable Jinja templates by adding them to a custom_templates folder under your\nconfiguration directory. All template files must have the .jinja extension and be less than 5MiB.\nTemplates in this folder will be loaded at startup. To reload the templates without\nrestarting Home Assistant, invoke the homeassistant.reload_custom_templates service. Once the templates are loaded, Jinja includes and imports will work\nusing config/custom_templates as the base directory. For example, you might define a macro in a template in config/custom_templates/formatter.jinja: In your automations, you could then reuse this macro by importing it: Extensions allow templates to access all of the Home Assistant specific states and adds other convenience functions and filters. Templates for some triggers as well as trigger_variables only support a subset of the Home Assistant template extensions. This subset is referred to as “Limited Templates”. Not supported in limited templates. Avoid using states.sensor.temperature.state, instead use states('sensor.temperature'). It is strongly advised to use the states(), is_state(), state_attr() and is_state_attr() as much as possible, to avoid errors and error message when the entity isn’t ready yet (e.g., during Home Assistant startup). The next two statements result in the same value if the state exists. The second one will result in an error if the state does not exist. Print out a list of all the sensor states: Print out a list of all the sensor states sorted by entity_id: Entities that are on: Other state examples: The examples below show the output of a temperature sensor with state 20.001, unit °C and user configured presentation rounding set to 1 decimal. The following example results in the number 20.001: The following example results in the string \"20.0 °C\": The following example result in the string \"20.001 °C\": The following example results in the number 20.0: The following example results in the number 20.001: The following example results in the string \"20.0 °C\": Not supported in limited templates. You can print an attribute with state_attr if state is defined. With strings: List of friendly names: List of lights that are on with a brightness of 255: Not supported in limited templates. The expand function and filter can be used to sort entities and expand groups. It outputs a sorted array of entities with no duplicates. The same thing can also be expressed as a filter: The same thing can also be expressed as a test: A common case is to conditionally return a value based on another value.\nFor example, return a “Yes” or “No” when the light is on or off. This can be written as: Or using a shorter syntax: Additionally, to the above, you can use the iif function/filter, which is\nan immediate if. Syntax: iif(condition, if_true, if_false, if_none) iif returns the value of if_true if the condition is truthy, the value of if_false if it’s falsy and the value of if_none if it’s None.\nAn empty string, an empty mapping or an an empty list, are all falsy, refer to the Python documentation for an in depth explanation. if_true is optional, if it’s omitted True is returned if the condition is truthy.\nif_false is optional, if it’s omitted False is returned if the condition is falsy.\nif_none is optional, if it’s omitted the value of if_false is returned if the condition is None. Examples using iif: The immediate if filter does not short-circuit like you might expect with a typical conditional statement. The if_true, if_false and if_none expressions will all be evaluated and the filter will simply return one of the resulting values. This means you cannot use this filter to prevent executing an expression which would result in an error. For example, if you wanted to select a field from trigger in an automation based on the platform you might go to make this template: trigger.platform == 'event' | iif(trigger.event.data.message, trigger.to_state.state). This won’t work because both expressions will be evaluated and one will fail since the field doesn’t exist. Instead you have to do this trigger.event.data.message if trigger.platform == 'event' else trigger.to_state.state. This form of the expression short-circuits so if the platform is event the expression trigger.to_state.state will never be evaluated and won’t cause an error. now(), relative_time(), today_at(), and utcnow() are not supported in limited templates. now() returns a datetime object that represents the current time in your time zone. utcnow() returns a datetime object of the current time in the UTC timezone. today_at(value) converts a string containing a military time format to a datetime object with today’s date in your time zone. as_datetime() converts a string containing a timestamp, or valid UNIX timestamp, to a datetime object. as_timestamp(value, default) converts datetime object or string to UNIX timestamp. If that fails, returns the default value, or if omitted raises an error. This function can also be used as a filter. as_local() converts datetime object to local time. This function can also be used as a filter. strptime(string, format, default) parses a string based on a format and returns a datetime object. If that fails, it returns the default value or, if omitted, raises an error. relative_time converts datetime object to its human-friendly “age” string. The age can be in second, minute, hour, day, month or year (but only the biggest unit is considered, e.g., if it’s 2 days and 3 hours, “2 days” will be returned). Note that it only works for dates in the past. timedelta returns a timedelta object and accepts the same arguments as the Python datetime.timedelta function – days, seconds, microseconds, milliseconds, minutes, hours, weeks. as_timedelta(string) converts a string to a timedelta object. Expects data in the format DD HH:MM:SS.uuuuuu, DD HH:MM:SS,uuuuuu, or as specified by ISO 8601 (e.g. P4DT1H15M20S which is equivalent to 4 1:15:20) or PostgreSQL’s day-time interval format (e.g. 3 days 04:05:06) This function can also be used as a filter. Filter timestamp_local(default) converts a UNIX timestamp to the ISO format string representation as date/time in your local timezone. If that fails, returns the default value, or if omitted raises an error. If a custom string format is needed in the string, use timestamp_custom instead. Filter timestamp_utc(default) converts a UNIX timestamp to the ISO format string representation representation as date/time in UTC timezone. If that fails, returns the default value, or if omitted raises an error. If a custom string format is needed in the string, use timestamp_custom instead. Filter timestamp_custom(format_string, local=True, default) converts an UNIX timestamp to its string representation based on a custom format, the use of a local timezone is the default. If that fails, returns the default value, or if omitted raises an error. Supports the standard Python time formatting options. UNIX timestamp is the number of seconds that have elapsed since 00:00:00 UTC on 1 January 1970. Therefore, if used as a function’s argument, it can be substituted with a numeric value (int or float). If your template is returning a timestamp that should be displayed in the frontend (e.g., as a sensor entity with device_class: timestamp), you have to ensure that it is the ISO 8601 format (meaning it has the “T” separator between the date and time portion). Otherwise, frontend rendering on macOS and iOS devices will show an error. The following value template would result in such an error: {{ states.sun.sun.last_changed }} => 2023-07-30 20:03:49.253717+00:00 (missing “T” separator) To fix it, enforce the ISO conversion via isoformat(): {{ states.sun.sun.last_changed.isoformat() }} => 2023-07-30T20:03:49.253717+00:00 (contains “T” separator) The to_json filter serializes an object to a JSON string. In some cases, it may be necessary to format a JSON string for use with a webhook, as a parameter for command-line utilities or any number of other applications. This can be complicated in a template, especially when dealing with escaping special characters. Using the to_json filter, this is handled automatically. to_json also accepts boolean arguments for pretty_print, which will pretty print the JSON with a 2-space indent to make it more human-readable, and sort_keys, which will sort the keys of the JSON object, ensuring that the resulting string is consistent for the same input. If you need to generate JSON that will be used by a parser that lacks support for Unicode characters, you can add ensure_ascii=True to have to_json generate Unicode escape sequences in strings. The from_json filter operates similarly, but in the other direction, de-serializing a JSON string back into an object. Conversely, from_json can be used to de-serialize a JSON string back into an object to make it possible to easily extract usable data. Sometimes a template should only return if a value or object is defined, if not, the supplied default value should be returned. This can be useful to validate a JSON payload.\nThe is_defined filter allows to throw an error if a value or object is not defined. Example using is_defined to parse a JSON payload: This will throw an error UndefinedError: 'value_json' is undefined if the JSON payload has no val attribute. Examples: Not supported in limited templates. If only one location is passed in, Home Assistant will measure the distance from home. The closest function and filter will find the closest entity to the Home Assistant location: Find entities closest to a coordinate or another entity. All previous arguments still apply for second argument. Since closest returns a state, we can combine it with distance too. The last argument of the closest function has an implicit expand, and can take any iterable sequence of states or entity IDs, and will expand groups: It will also work as a filter over an iterable group of entities or groups: Jinja provides by default a in operator how return True when one element is in a provided list.\nThe contains test and filter allow you to do the exact opposite and test for a list containing an element. This is particularly useful in select or selectattr filter, as well as to check if a device has a specific attribute, a supported_color_modes, a specific light effect. Some examples: Some of these functions can also be used in a filter. This means they can act as a normal function like this sqrt(2), or as part of a filter like this 2|sqrt. The numeric functions and filters raise an error if the input is not a valid number, optionally a default value can be specified which will be returned instead. The is_number function and filter can be used to check if a value is a valid number. Errors can be caught by the default filter. float(value, default) function will attempt to convert the input to a float. If that fails, returns the default value, or if omitted raises an error. float(default) filter will attempt to convert the input to a float. If that fails, returns the default value, or if omitted raises an error. is_number will return True if the input can be parsed by Python’s float function and the parsed input is not inf or nan, in all other cases returns False. Note that a Python bool will return True but the strings \"True\" and \"False\" will both return False. Can be used as a filter. int(value, default) function is similar to float, but converts to an int instead. Like float, it has a filter form, and an error is raised if the default value is omitted. Fractional part is discarded: int(\"1.5\") is 1. bool(value, default) function converts the value to either true or false.\nThe following values are considered to be true: boolean true, non-zero ints and floats, and the strings \"true\", \"yes\", \"on\", \"enable\", and \"1\" (case-insensitive). false is returned for the opposite values: boolean false, integer or floating-point 0, and the strings \"false\", \"no\", \"off\", \"disable\", and \"0\" (also case-insensitive).\nIf the value is not listed here, the function returns the default value, or if omitted raises an error.\nThis function is intended to be used on states of binary sensors, switches, or similar entities, so its behavior is different from Python’s built-in bool conversion, which would consider e.g. \"on\", \"off\", and \"unknown\" all to be true, but \"\" to be false; if that is desired, use not not value or a similar construct instead.\nLike float and int, bool has a filter form. Using none as the default value is particularly useful in combination with the immediate if filter: it can handle all three possible cases in a single line. log(value, base, default) will take the logarithm of the input. When the base is omitted, it defaults to e - the natural logarithm. If value or base can’t be converted to a float, returns the default value, or if omitted raises an error. Can also be used as a filter. sin(value, default) will return the sine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. cos(value, default) will return the cosine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. tan(value, default) will return the tangent of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. asin(value, default) will return the arcus sine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. acos(value, default) will return the arcus cosine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. atan(value, default) will return the arcus tangent of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. atan2(y, x, default) will return the four quadrant arcus tangent of y / x. If y or x can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. sqrt(value, default) will return the square root of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. max([x, y, ...]) will obtain the largest item in a sequence. Uses the same parameters as the built-in max filter. min([x, y, ...]) will obtain the smallest item in a sequence. Uses the same parameters as the built-in min filter. average([x, y, ...], default) will return the average value of the sequence. If list is empty or contains non-numeric value, returns the default value, or if omitted raises an error. Can be used as a filter. median([x, y, ...], default) will return the median value of the sequence. If list is empty or contains non-numeric value, returns the default value, or if omitted raises an error. Can be used as a filter. statistical_mode([x, y, ...], default) will return the statistical mode value (most frequent occurrence) of the sequence. If the list is empty, it returns the default value, or if omitted raises an error. It can be used as a filter. e mathematical constant, approximately 2.71828. pi mathematical constant, approximately 3.14159. tau mathematical constant, approximately 6.28318. Filter round(precision, method, default) will convert the input to a number and round it to precision decimals. Round has four modes and the default mode (with no mode specified) will round-to-even. If the input value can’t be converted to a float, returns the default value, or if omitted raises an error. Filter value_one|bitwise_and(value_two) perform a bitwise and(&) operation with two values. Filter value_one|bitwise_or(value_two) perform a bitwise or(|) operation with two values. Filter ord will return for a string of length one an integer representing the Unicode code point of the character when the argument is a Unicode object, or the value of the byte when the argument is an 8-bit string. In addition to strings and numbers, Python (and Jinja) supports lists, sets, and dictionaries. To help you with testing these types, you can use the following tests: Note that, in Home Assistant, Jinja has built-in tests for boolean (True/False), callable (any function), float (a number with a decimal), integer (a number without a decimal), iterable (a value that can be iterated over such as a list, set, string, or generator), mapping (mainly dict but also supports other dictionary like types), number (float or int), sequence (a value that can be iterated over and indexed such as list and string), and string. While Jinja natively supports the conversion of an iterable to a list, it does not support conversion to a tuple or set. To help you with using these types, you can use the following functions: Note that, in Home Assistant, to convert a value to a list, a string, an int, or a float, Jinja has built-in functions with names that correspond to each type. These functions are used to process raw value’s in a bytes format to values in a native Python type or vice-versa.\nThe pack and unpack functions can also be used as a filter. They make use of the Python 3 struct library.\nSee: Python struct library documentation Some examples: For more information on regular expressions\nSee: Python regular expression operations The other part of templating is processing incoming data. It allows you to modify incoming data and extract only the data you care about. This will only work for platforms and integrations that mention support for this in their documentation. It depends per integration or platform, but it is common to be able to define a template using the value_template configuration key. When a new value arrives, your template will be rendered while having access to the following values on top of the usual Home Assistant extensions: This means that if the incoming values looks like the sample below: The template for on would be: Nested JSON in a response is supported as well: Just use the “Square bracket notation” to get the value. The following overview contains a couple of options to get the needed values: To evaluate a response, go to Developer Tools > Template, create your output in “Template editor”, and check the result. The MQTT integration relies heavily on templates. Templates are used to transform incoming payloads (value templates) to status updates or incoming service calls (command templates) to payloads that configure the MQTT device. For incoming data a value template translates incoming JSON or raw data to a valid payload.\nIncoming payloads are rendered with possible JSON values, so when rendering the value_json can be used access the attributes in a JSON based payload. Example value template: With given payload: Template {{ value_json.temperature | round(1) }} renders to 21.9. Additional the MQTT entity attributes entity_id, name and this can be used as variables in the template. The this attribute refers to the entity state of the MQTT item. For service calls command templates are defined to format the outgoing MQTT payload to the device. When a service call is executed value can be used to generate the correct payload to the device. Example command template: With given value 21.9 template {\"temperature\": {{ value }} } renders to: Additional the MQTT entity attributes entity_id, name and this can be used as variables in the template. The this attribute refers to the entity state of the MQTT item. If your template uses an entity_id that begins with a number (example: states.device_tracker.2008_gmc) you must use a bracket syntax to avoid errors caused by rendering the entity_id improperly. In the example given, the correct syntax for the device tracker would be: states.device_tracker['2008_gmc'] The default priority of operators is that the filter (|) has priority over everything except brackets. This means that: Would round 10 to 2 decimal places, then divide states('sensor.temperature') by 10 (rounded to 2 decimal places so 10.00). This behavior is maybe not the one expected, but priority rules imply that."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#mqtt-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/locked_out/#to-prepare-the-system-to-start-a-new-onboarding-process",
        "content": "The sections below deal with recovering from a situation where you are not able to sign in,\nor need to recover your data. If you’ve forgotten your username, ask the owner to help you.\nIf you are the owner and have forgotten your user name, then you need to prepare the system to start a new onboarding process. If you are not the owner or do not have administrator rights, ask the owner to give you a new password. If you are the owner or have administrator, there are different methods to reset a password, depending on your setup: The method used to reset a password depends on your user rights: Use this procedure only if the following conditions are met: If you are running Home Assistant in a container, you can use the command line in the container with the hass command to change your password. The steps below refer to a Home Assistant container in Docker named homeassistant. Note that while working in the container, commands will take a few moments to execute. Only the owner can change other user’s passwords. You need to be an owner or have administrator rights to delete a user. If you lose the password associated with the owner account and the steps above do not work to reset the password, the only way to resolve this is to start a new onboarding process. If you have an external backup with an administrator account of which you still know the login credentials, you can restore that backup. If you do not have a backup, resetting the device will erase all data. If you have a Home Assistant Green, reset the Green. If you have a Home Assistant Yellow, reset the Yellow. Unless your SD card/data is corrupted, you can still get to your files or troubleshoot further.\nThere are a few routes: If you’re using a Raspberry Pi, you’re likely going to have to pull the power in order to get your monitor recognized at boot. Pulling power has a risk of corrupting the SD, but you may not have another option. Most standard USB keyboards should be recognized easily. Once you’re connected, you’ll see a running dmesg log. Hit the enter key to interrupt the log.\nSign in as “root”. There is no password. You will then be at the Home Assistant CLI, where you can run the custom commands. These are the same as you would run using the SSH add-on but without using ha in front of it. For example: The files are on an EXT4 partition (hassos-data) and the path is /mnt/data/supervisor.\nThese are easily accessed using another Linux machine with EXT support. For Windows or macOS you will need third party software. Below are some options."
    },
    {
        "url": "https://www.home-assistant.io/docs/tools/check_config/",
        "content": "Test any changes to your configuration.yaml file before launching Home Assistant. This scriptScripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on.\n[Learn more] allows you to test changes without the need to restart Home Assistant. The script has further options like checking configuration files which are not located in the default directory or showing your secrets for debugging."
    },
    {
        "url": "https://www.home-assistant.io/docs/frontend/",
        "content": "The Home Assistant frontend allows users to browse and control the state of their house, manage their automations and configure integrations.\nThe frontend is built with Polymer. \n\n If you’re looking to contribute to the frontend, please refer to the Frontend Development documentation. Home Assistant utilizes the community-driven Material Design Icons project for icons in the frontend. The Icons section has more information on how to use icons and suggest new ones. The User Interface section can give you some starting points to expand the frontend."
    },
    {
        "url": "https://www.home-assistant.io/docs/energy/",
        "content": "Home Assistant allows you to get on top of your energy use with its home energy management feature. Gain new insights, optimize your solar panel production, plan energy usage and save money.   Home energy management works with three different types of information sources. You can start using it even if you just have one source connected to Home Assistant. Every source you add will complement the other sources, giving you even more insight into energy in your home. Home Assistant is an open platform and so home energy management is not restricted to specific hardware. Any energy monitoring hardware that integrates with Home Assistant can be used as a data source. Check out the following sections for in-depth explanations and hardware recommendations. If you have a sensor that returns instantaneous power readings (W or kW), then to add a sensor that returns energy usage or generation (kWh), refer to the Riemann sum integral integration."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/customizing-devices/#icon",
        "content": "You can use the UI to change the entity ID and friendly name of supported entities. To do this: If your entity is not supported, or you cannot customize what you need via this method, please see below for more options. By default, all of your devices will be visible and have a default icon determined by their domain. You can customize the look and feel of your front page by altering some of these parameters. This can be done by overriding attributes of specific entities. Name of the entity as displayed in the UI. URL to use as picture for entity. Any icon from Material Design Icons. Prefix name with mdi:, ie mdi:home. Note: Newer icons may not yet be available in the current Home Assistant release. For switches with an assumed state two buttons are shown (turn off, turn on) instead of a switch. By setting assumed_state to false you will get the default switch icon. Sets the class of the device, changing the device state and icon that is displayed on the UI (see below). It does not set the unit_of_measurement. Defines the units of measurement, if any. This will also influence the graphical presentation in the history visualization as continuous value. Sensors with missing unit_of_measurement are showing as discrete values. Sets the initial state for automations, on or off. Device class is currently supported by the following platforms: If you implement customize, customize_domain, or customize_glob you must make sure it is done inside of homeassistant: or it will fail. Home Assistant offers a service to reload the core configuration while Home Assistant is running. This allows you to change your customize section and see your changes being applied without having to restart Home Assistant. To reload customizations, navigate to Developer Tools > YAML and then press the “Reload Location & Customizations” button. If you don’t see this, enable Advanced Mode on your user profile page first. You can also use the Quick bar, and choose “Reload Location & Customizations”. Alternatively, you can reload via service call. Navigate to Developer Tools > Services tab, select homeassistant.reload_core_config from the dropdown and press the “Call Service” button."
    },
    {
        "url": "https://www.home-assistant.io/docs/scripts/",
        "content": "Scripts are a sequence of actionsActions are used in several places in Home Assistant. As part of a script or automation, actions define what is going to happen once a trigger is activated. In scripts, an action is called sequence.\n[Learn more] that Home Assistant will execute. Scripts are available as an entity through the standalone Script integration but can also be embedded in automationsAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] and Alexa/Amazon Echo configurations. When the script is executed within an automation the trigger variable is available. See Available-Trigger-Data. The script syntax basic structure is a list of key/value maps that contain actions. If a script contains only 1 action, the wrapping list can be omitted. All actions support an optional alias. The most important one is the action to call a service. This can be done in various ways. For all the different possibilities, have a look at the service calls page. Scripts may also use a shortcut syntax for activating scenes instead of calling the scene.turn_on service. The variables action allows you to set/override variables that will be accessible by templates in actions after it. See also script variables for how to define variables accessible in the entire script. Variables can be templated. Variables have local scope. This means that if a variable is changed in a nested sequence block, that change will not be visible in an outer sequence block. Inside the if sequence the variables action will only alter the people variable for that sequence. While executing a script you can add a condition in the main sequence to stop further execution. When a condition does not return true, the script will stop executing. There are many different conditions which are documented at the conditions page. The condition action only stops executing the current sequence block. When it is used inside a repeat action, only the current iteration of the repeat loop will stop. When it is used inside a choose action, only the actions within that choose will stop. condition can also be a list of conditions and execution will then only continue if ALL conditions return true. Delays are useful for temporarily suspending your script and start it at a later moment. We support different syntaxes for a delay as shown below. All forms accept templates. These actions allow a script to wait for entities in the system to be in a certain state as specified by a template, or some event to happen as expressed by one or more triggers. This action evaluates the template, and if true, the script will continue. If not, then it will wait until it is true. The template is re-evaluated whenever an entity ID that it references changes state. If you use non-deterministic functions like now() in the template it will not be continuously re-evaluated, but only when an entity ID that is referenced is changed. If you need to periodically re-evaluate the template, reference a sensor from the Time and Date integration that will update minutely or daily. This action can use the same triggers that are available in an automation’s trigger section. See Automation Trigger. The script will continue whenever any of the triggers fires. All previously defined trigger variables, variables and script variables are passed to the trigger. With both types of waits it is possible to set a timeout after which the script will continue its execution if the condition/event is not satisfied. Timeout has the same syntax as delay, and like delay, also accepts templates. You can also get the script to abort after the timeout by using optional continue_on_timeout: false. Without continue_on_timeout: false the script will always continue since the default for continue_on_timeout is true. After each time a wait completes, either because the condition was met, the event happened, or the timeout expired, the variable wait will be created/updated to indicate the result. This can be used to take different actions based on whether or not the condition was met, or to use more than one wait sequentially while implementing a single timeout overall. This action allows you to fire an event. Events can be used for many things. It could trigger an automation or indicate to another integration that something is happening. For instance, in the below example it is used to create an entry in the logbook. You can also use event_data to fire an event with custom data. This could be used to pass data to another script awaiting\nan event trigger. The event_data accepts templates. The following automation example shows how to raise a custom event called event_light_state_changed with entity_id as the event data. The action part could be inside a script or an automation. The following automation example shows how to capture the custom event event_light_state_changed with an Event Automation Trigger, and retrieve corresponding entity_id that was passed as the event trigger data, see Available-Trigger-Data for more details. This action allows you to repeat a sequence of other actions. Nesting is fully supported.\nThere are three ways to control how many times the sequence will be run. This form accepts a count value. The value may be specified by a template, in which case\nthe template is rendered when the repeat step is reached. This repeat form accepts a list of items to iterate over. The list of items\ncan be a pre-defined list, or a list created by a template. The sequence is ran for each item in the list, and current item in the\niteration is available as repeat.item. The following example will turn a list of lights: Other types are accepted as list items, for example, each item can be a\ntemplate, or even an mapping of key/value pairs. This form accepts a list of conditions (see conditions page for available options) that are evaluated before each time the sequence\nis run. The sequence will be run as long as the condition(s) evaluate to true. The while also accepts a shorthand notation of a template condition.\nFor example: This form accepts a list of conditions that are evaluated after each time the sequence\nis run. Therefore the sequence will always run at least once. The sequence will be run\nuntil the condition(s) evaluate to true. until also accepts a shorthand notation of a template condition.\nFor example: A variable named repeat is defined within the repeat action (i.e., it is available inside sequence, while & until.)\nIt contains the following fields: This action allow you to conditionally (if) run a sequence of actions (then)\nand optionally supports running other sequence when the condition didn’t\npass (else). This action supports nesting, however, if you find yourself using nested if-then\nactions in the else part, you may want to consider using\nchoose instead. This action allows you to select a sequence of other actions from a list of sequences.\nNesting is fully supported. Each sequence is paired with a list of conditions. (See the conditions page for available options and how multiple conditions are handled.) The first sequence whose conditions are all true will be run.\nAn optional default sequence can be included which will be run only if none of the sequences from the list are run. An optional alias can be added to each of the sequences, excluding the default sequence. The choose action can be used like an “if/then/elseif/then…/else” statement. The first conditions/sequence pair is like the “if/then”, and can be used just by itself. Or additional pairs can be added, each of which is like an “elif/then”. And lastly, a default can be added, which would be like the “else.” conditions also accepts a shorthand notation of a template condition.\nFor example: More choose can be used together. This is the case of an IF-IF. The following example shows how a single automation can control entities that aren’t related to each other but have in common the same trigger. When the sun goes below the horizon, the porch and garden lights must turn on. If someone is watching the TV in the living room, there is a high chance that someone is in that room, therefore the living room lights have to turn on too. The same concept applies to the studio room. By default, all sequences of actions in Home Assistant run sequentially. This\nmeans the next action is started after the current action has been completed. This is not always needed, for example, if the sequence of actions doesn’t rely\non each other and order doesn’t matter. For those cases, the parallel action\ncan be used to run the actions in the sequence in parallel, meaning all\nthe actions are started at the same time. The following example shows sending messages out at the same time (in parallel): It is also possible to run a group of actions sequentially inside the parallel\nactions. The example below demonstrates that: Running actions in parallel can be helpful in many cases, but use it with\ncaution and only if you need it. There are some caveats (see below) when using parallel actions. While it sounds attractive to parallelize, most of the time, just the regular\nsequential actions will work just fine. Some of the caveats of running actions in parallel: It is possible to halt a script sequence at any point and return script responses\nusing the stop action. The stop action takes a text as input explaining the reason for halting the\nsequence. This text will be logged and shows up in the automations and\nscript traces. stop can be useful to halt a script halfway through a sequence when,\nfor example, a condition is not met. To return a response from a script, use the response_variable option. This\noption expects the name of the variable that contains the data to return. The\nresponse data must contains a mapping of key/value pairs. There is also an error option, to indicate we are stopping because of\nan unexpected error. It stops the sequence as well, but marks the automation\nor script as failed to run. By default, a sequence of actions will be halted when one of the actions in\nthat sequence encounters an error. The automation or script will be halted,\nan error is logged, and the automation or script run is marked as errored. Sometimes these errors are expected, for example, because you know the service\nyou call can be problematic at times, and it doesn’t matter if it fails.\nYou can set continue_on_error for those cases on such an action. The continue_on_error is available on all actions and is set to\nfalse. You can set it to true if you’d like to continue the action\nsequence, regardless of whether that action encounters an error. The example below shows the continue_on_error set on the first action. If\nit encounters an error; it will continue to the next action. Please note that continue_on_error will not suppress/ignore misconfiguration\nor errors that Home Assistant does not handle. Every individual action in a sequence can be disabled, without removing it.\nTo do so, add enabled: false to the action. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/secrets/",
        "content": "The configuration.yaml file is a plain-text file, thus it is readable by anyone who has access to the file. The file contains passwords and API tokens which need to be redacted if you want to share your configuration. By using !secret you can remove any private information from your configuration files. This separation can also help you to keep easier track of your passwords and API keys, as they are all stored at one place and no longer spread across the configuration.yaml file or even multiple YAML files if you split up your configuration. The workflow for moving private information to secrets.yaml is very similar to the splitting of the configuration. Create a secrets.yaml file in your Home Assistant configuration directory. The entries for password and API keys in the configuration.yaml file usually looks like the example below. Those entries need to be replaced with !secret and an identifier. The secrets.yaml file contains the corresponding password assigned to the identifier. When you start splitting your configuration into multiple files, you might end up with configuration in sub folders. Secrets will be resolved in this order: To see where secrets are being loaded from, you can either add an option to your secrets.yaml file or use the check_config script. The latter is only available for Home Assistant Core installations given it’s available through hass. Option 1: Print where secrets are retrieved from to the Home Assistant log by adding the following to secrets.yaml: This will not print the actual secret’s value to the log. Option 2: For Home Assistant Core installations, you can also view where secrets are retrieved from and the contents of all secrets.yaml files using the check_config script from the command line: This will print all your secrets."
    },
    {
        "url": "https://www.home-assistant.io/docs/blueprint/schema/#blueprint-inputs",
        "content": "The configuration schema of a blueprint consists of 2 parts: The first part is referred to as the blueprint schema. It contains the\nblueprint’s metadata. The only requirement for a blueprint is a name. In its most basic form,\na blueprint would look like: Although this is a valid blueprint, it is not very useful. The second part depends on the use case of the blueprint. For example, if you create a blueprint for an automation, the full\nschema for an automation applies. You can add a description of the blueprint’s use case and user inputs. This is the full blueprint schema: The name of the blueprint. Keep this short and descriptive. The description of the blueprint. While optional, this field is highly recommended. Describe what the blueprint does and describe the inputs the blueprint provide. The description can include Markdown. The domain in which this blueprint is used. Currently, only automation and script are supported. The name of the blueprint author. Home Assistant requirements to be able to use the blueprint successfully. Minimum required version of Home Assistant to use the blueprint. For example, 2022.4.0. It is important to set this if the blueprint uses any features introduced in recent releases to head off issues. A dictionary of defined user inputs. These are the input fields that the consumer of your blueprint can provide using YAML definition, or via a configuration form in the UI. The name of the input field. A short description of the input field. Keep this short and descriptive. The description can include Markdown. The selector to use for this input. A selector defines how the input is displayed in the frontend UI. The default value of this input, in case the input is not provided by the user of this blueprint. As described above, a blueprint can accept one (or multiple)\ninputs from the blueprint user. These inputs can be of any type (string, boolean, list, dictionary). They can have\na default value and also provide a selector that\nensures a matching input field in the user interface. Each input field can be referred to, outside of the blueprint metadata, using\nthe !input custom YAML tag. The following example shows a minimal blueprint with a single input: In the above example, my_input is the identifier of the input. It can be\nreferenced by using the !input my_input custom tag. In this example, no selector was provided. In the user interface, a text input field would be shown to the user.\nIt is then up to the user to find out what to enter there. Blueprints that come with selectors are easier to use. A blueprint can have as many inputs as you like. The inputs are available as custom YAML tags, but not as template variables.\nTo use a blueprint input in a template, it first needs to be exposed as either\na script level variable or in\na variable script step. The built-in blueprints\nare great examples to get a bit of a feeling of how blueprints work. Here is the built-in motion light automation blueprint:"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/blueprint/schema/",
        "content": "The configuration schema of a blueprint consists of 2 parts: The first part is referred to as the blueprint schema. It contains the\nblueprint’s metadata. The only requirement for a blueprint is a name. In its most basic form,\na blueprint would look like: Although this is a valid blueprint, it is not very useful. The second part depends on the use case of the blueprint. For example, if you create a blueprint for an automation, the full\nschema for an automation applies. You can add a description of the blueprint’s use case and user inputs. This is the full blueprint schema: The name of the blueprint. Keep this short and descriptive. The description of the blueprint. While optional, this field is highly recommended. Describe what the blueprint does and describe the inputs the blueprint provide. The description can include Markdown. The domain in which this blueprint is used. Currently, only automation and script are supported. The name of the blueprint author. Home Assistant requirements to be able to use the blueprint successfully. Minimum required version of Home Assistant to use the blueprint. For example, 2022.4.0. It is important to set this if the blueprint uses any features introduced in recent releases to head off issues. A dictionary of defined user inputs. These are the input fields that the consumer of your blueprint can provide using YAML definition, or via a configuration form in the UI. The name of the input field. A short description of the input field. Keep this short and descriptive. The description can include Markdown. The selector to use for this input. A selector defines how the input is displayed in the frontend UI. The default value of this input, in case the input is not provided by the user of this blueprint. As described above, a blueprint can accept one (or multiple)\ninputs from the blueprint user. These inputs can be of any type (string, boolean, list, dictionary). They can have\na default value and also provide a selector that\nensures a matching input field in the user interface. Each input field can be referred to, outside of the blueprint metadata, using\nthe !input custom YAML tag. The following example shows a minimal blueprint with a single input: In the above example, my_input is the identifier of the input. It can be\nreferenced by using the !input my_input custom tag. In this example, no selector was provided. In the user interface, a text input field would be shown to the user.\nIt is then up to the user to find out what to enter there. Blueprints that come with selectors are easier to use. A blueprint can have as many inputs as you like. The inputs are available as custom YAML tags, but not as template variables.\nTo use a blueprint input in a template, it first needs to be exposed as either\na script level variable or in\na variable script step. The built-in blueprints\nare great examples to get a bit of a feeling of how blueprints work. Here is the built-in motion light automation blueprint:"
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/templating/",
        "content": "This is an advanced feature of Home Assistant. You’ll need a basic understanding of: Templating is a powerful feature that allows you to control information going into and out of the system. It is used for: Templating in Home Assistant is powered by the Jinja2 templating engine. This means that we are using their syntax and make some custom Home Assistant variables available to templates during rendering. Jinja2 supports a wide variety of operations: We will not go over the basics of the syntax, as Jinja2 does a great job of this in their templates documentation. The frontend has a template editor tool to help develop and debug templates. Navigate to Developer Tools > Template, create your template in the Template editor and check the results on the right. Templates can get big pretty fast. To keep a clear overview, consider using YAML multiline strings to define your templates: There are a few very important rules to remember when adding templates to YAML: Remembering these simple rules will help save you from many headaches and endless hours of frustration when using automation templates. Jinja supports a set of language extensions that add new functionality to the language.\nTo improve the experience of writing Jinja templates, we have enabled the following\nextensions: You can write reusable Jinja templates by adding them to a custom_templates folder under your\nconfiguration directory. All template files must have the .jinja extension and be less than 5MiB.\nTemplates in this folder will be loaded at startup. To reload the templates without\nrestarting Home Assistant, invoke the homeassistant.reload_custom_templates service. Once the templates are loaded, Jinja includes and imports will work\nusing config/custom_templates as the base directory. For example, you might define a macro in a template in config/custom_templates/formatter.jinja: In your automations, you could then reuse this macro by importing it: Extensions allow templates to access all of the Home Assistant specific states and adds other convenience functions and filters. Templates for some triggers as well as trigger_variables only support a subset of the Home Assistant template extensions. This subset is referred to as “Limited Templates”. Not supported in limited templates. Avoid using states.sensor.temperature.state, instead use states('sensor.temperature'). It is strongly advised to use the states(), is_state(), state_attr() and is_state_attr() as much as possible, to avoid errors and error message when the entity isn’t ready yet (e.g., during Home Assistant startup). The next two statements result in the same value if the state exists. The second one will result in an error if the state does not exist. Print out a list of all the sensor states: Print out a list of all the sensor states sorted by entity_id: Entities that are on: Other state examples: The examples below show the output of a temperature sensor with state 20.001, unit °C and user configured presentation rounding set to 1 decimal. The following example results in the number 20.001: The following example results in the string \"20.0 °C\": The following example result in the string \"20.001 °C\": The following example results in the number 20.0: The following example results in the number 20.001: The following example results in the string \"20.0 °C\": Not supported in limited templates. You can print an attribute with state_attr if state is defined. With strings: List of friendly names: List of lights that are on with a brightness of 255: Not supported in limited templates. The expand function and filter can be used to sort entities and expand groups. It outputs a sorted array of entities with no duplicates. The same thing can also be expressed as a filter: The same thing can also be expressed as a test: A common case is to conditionally return a value based on another value.\nFor example, return a “Yes” or “No” when the light is on or off. This can be written as: Or using a shorter syntax: Additionally, to the above, you can use the iif function/filter, which is\nan immediate if. Syntax: iif(condition, if_true, if_false, if_none) iif returns the value of if_true if the condition is truthy, the value of if_false if it’s falsy and the value of if_none if it’s None.\nAn empty string, an empty mapping or an an empty list, are all falsy, refer to the Python documentation for an in depth explanation. if_true is optional, if it’s omitted True is returned if the condition is truthy.\nif_false is optional, if it’s omitted False is returned if the condition is falsy.\nif_none is optional, if it’s omitted the value of if_false is returned if the condition is None. Examples using iif: The immediate if filter does not short-circuit like you might expect with a typical conditional statement. The if_true, if_false and if_none expressions will all be evaluated and the filter will simply return one of the resulting values. This means you cannot use this filter to prevent executing an expression which would result in an error. For example, if you wanted to select a field from trigger in an automation based on the platform you might go to make this template: trigger.platform == 'event' | iif(trigger.event.data.message, trigger.to_state.state). This won’t work because both expressions will be evaluated and one will fail since the field doesn’t exist. Instead you have to do this trigger.event.data.message if trigger.platform == 'event' else trigger.to_state.state. This form of the expression short-circuits so if the platform is event the expression trigger.to_state.state will never be evaluated and won’t cause an error. now(), relative_time(), today_at(), and utcnow() are not supported in limited templates. now() returns a datetime object that represents the current time in your time zone. utcnow() returns a datetime object of the current time in the UTC timezone. today_at(value) converts a string containing a military time format to a datetime object with today’s date in your time zone. as_datetime() converts a string containing a timestamp, or valid UNIX timestamp, to a datetime object. as_timestamp(value, default) converts datetime object or string to UNIX timestamp. If that fails, returns the default value, or if omitted raises an error. This function can also be used as a filter. as_local() converts datetime object to local time. This function can also be used as a filter. strptime(string, format, default) parses a string based on a format and returns a datetime object. If that fails, it returns the default value or, if omitted, raises an error. relative_time converts datetime object to its human-friendly “age” string. The age can be in second, minute, hour, day, month or year (but only the biggest unit is considered, e.g., if it’s 2 days and 3 hours, “2 days” will be returned). Note that it only works for dates in the past. timedelta returns a timedelta object and accepts the same arguments as the Python datetime.timedelta function – days, seconds, microseconds, milliseconds, minutes, hours, weeks. as_timedelta(string) converts a string to a timedelta object. Expects data in the format DD HH:MM:SS.uuuuuu, DD HH:MM:SS,uuuuuu, or as specified by ISO 8601 (e.g. P4DT1H15M20S which is equivalent to 4 1:15:20) or PostgreSQL’s day-time interval format (e.g. 3 days 04:05:06) This function can also be used as a filter. Filter timestamp_local(default) converts a UNIX timestamp to the ISO format string representation as date/time in your local timezone. If that fails, returns the default value, or if omitted raises an error. If a custom string format is needed in the string, use timestamp_custom instead. Filter timestamp_utc(default) converts a UNIX timestamp to the ISO format string representation representation as date/time in UTC timezone. If that fails, returns the default value, or if omitted raises an error. If a custom string format is needed in the string, use timestamp_custom instead. Filter timestamp_custom(format_string, local=True, default) converts an UNIX timestamp to its string representation based on a custom format, the use of a local timezone is the default. If that fails, returns the default value, or if omitted raises an error. Supports the standard Python time formatting options. UNIX timestamp is the number of seconds that have elapsed since 00:00:00 UTC on 1 January 1970. Therefore, if used as a function’s argument, it can be substituted with a numeric value (int or float). If your template is returning a timestamp that should be displayed in the frontend (e.g., as a sensor entity with device_class: timestamp), you have to ensure that it is the ISO 8601 format (meaning it has the “T” separator between the date and time portion). Otherwise, frontend rendering on macOS and iOS devices will show an error. The following value template would result in such an error: {{ states.sun.sun.last_changed }} => 2023-07-30 20:03:49.253717+00:00 (missing “T” separator) To fix it, enforce the ISO conversion via isoformat(): {{ states.sun.sun.last_changed.isoformat() }} => 2023-07-30T20:03:49.253717+00:00 (contains “T” separator) The to_json filter serializes an object to a JSON string. In some cases, it may be necessary to format a JSON string for use with a webhook, as a parameter for command-line utilities or any number of other applications. This can be complicated in a template, especially when dealing with escaping special characters. Using the to_json filter, this is handled automatically. to_json also accepts boolean arguments for pretty_print, which will pretty print the JSON with a 2-space indent to make it more human-readable, and sort_keys, which will sort the keys of the JSON object, ensuring that the resulting string is consistent for the same input. If you need to generate JSON that will be used by a parser that lacks support for Unicode characters, you can add ensure_ascii=True to have to_json generate Unicode escape sequences in strings. The from_json filter operates similarly, but in the other direction, de-serializing a JSON string back into an object. Conversely, from_json can be used to de-serialize a JSON string back into an object to make it possible to easily extract usable data. Sometimes a template should only return if a value or object is defined, if not, the supplied default value should be returned. This can be useful to validate a JSON payload.\nThe is_defined filter allows to throw an error if a value or object is not defined. Example using is_defined to parse a JSON payload: This will throw an error UndefinedError: 'value_json' is undefined if the JSON payload has no val attribute. Examples: Not supported in limited templates. If only one location is passed in, Home Assistant will measure the distance from home. The closest function and filter will find the closest entity to the Home Assistant location: Find entities closest to a coordinate or another entity. All previous arguments still apply for second argument. Since closest returns a state, we can combine it with distance too. The last argument of the closest function has an implicit expand, and can take any iterable sequence of states or entity IDs, and will expand groups: It will also work as a filter over an iterable group of entities or groups: Jinja provides by default a in operator how return True when one element is in a provided list.\nThe contains test and filter allow you to do the exact opposite and test for a list containing an element. This is particularly useful in select or selectattr filter, as well as to check if a device has a specific attribute, a supported_color_modes, a specific light effect. Some examples: Some of these functions can also be used in a filter. This means they can act as a normal function like this sqrt(2), or as part of a filter like this 2|sqrt. The numeric functions and filters raise an error if the input is not a valid number, optionally a default value can be specified which will be returned instead. The is_number function and filter can be used to check if a value is a valid number. Errors can be caught by the default filter. float(value, default) function will attempt to convert the input to a float. If that fails, returns the default value, or if omitted raises an error. float(default) filter will attempt to convert the input to a float. If that fails, returns the default value, or if omitted raises an error. is_number will return True if the input can be parsed by Python’s float function and the parsed input is not inf or nan, in all other cases returns False. Note that a Python bool will return True but the strings \"True\" and \"False\" will both return False. Can be used as a filter. int(value, default) function is similar to float, but converts to an int instead. Like float, it has a filter form, and an error is raised if the default value is omitted. Fractional part is discarded: int(\"1.5\") is 1. bool(value, default) function converts the value to either true or false.\nThe following values are considered to be true: boolean true, non-zero ints and floats, and the strings \"true\", \"yes\", \"on\", \"enable\", and \"1\" (case-insensitive). false is returned for the opposite values: boolean false, integer or floating-point 0, and the strings \"false\", \"no\", \"off\", \"disable\", and \"0\" (also case-insensitive).\nIf the value is not listed here, the function returns the default value, or if omitted raises an error.\nThis function is intended to be used on states of binary sensors, switches, or similar entities, so its behavior is different from Python’s built-in bool conversion, which would consider e.g. \"on\", \"off\", and \"unknown\" all to be true, but \"\" to be false; if that is desired, use not not value or a similar construct instead.\nLike float and int, bool has a filter form. Using none as the default value is particularly useful in combination with the immediate if filter: it can handle all three possible cases in a single line. log(value, base, default) will take the logarithm of the input. When the base is omitted, it defaults to e - the natural logarithm. If value or base can’t be converted to a float, returns the default value, or if omitted raises an error. Can also be used as a filter. sin(value, default) will return the sine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. cos(value, default) will return the cosine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. tan(value, default) will return the tangent of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. asin(value, default) will return the arcus sine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. acos(value, default) will return the arcus cosine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. atan(value, default) will return the arcus tangent of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. atan2(y, x, default) will return the four quadrant arcus tangent of y / x. If y or x can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. sqrt(value, default) will return the square root of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. max([x, y, ...]) will obtain the largest item in a sequence. Uses the same parameters as the built-in max filter. min([x, y, ...]) will obtain the smallest item in a sequence. Uses the same parameters as the built-in min filter. average([x, y, ...], default) will return the average value of the sequence. If list is empty or contains non-numeric value, returns the default value, or if omitted raises an error. Can be used as a filter. median([x, y, ...], default) will return the median value of the sequence. If list is empty or contains non-numeric value, returns the default value, or if omitted raises an error. Can be used as a filter. statistical_mode([x, y, ...], default) will return the statistical mode value (most frequent occurrence) of the sequence. If the list is empty, it returns the default value, or if omitted raises an error. It can be used as a filter. e mathematical constant, approximately 2.71828. pi mathematical constant, approximately 3.14159. tau mathematical constant, approximately 6.28318. Filter round(precision, method, default) will convert the input to a number and round it to precision decimals. Round has four modes and the default mode (with no mode specified) will round-to-even. If the input value can’t be converted to a float, returns the default value, or if omitted raises an error. Filter value_one|bitwise_and(value_two) perform a bitwise and(&) operation with two values. Filter value_one|bitwise_or(value_two) perform a bitwise or(|) operation with two values. Filter ord will return for a string of length one an integer representing the Unicode code point of the character when the argument is a Unicode object, or the value of the byte when the argument is an 8-bit string. In addition to strings and numbers, Python (and Jinja) supports lists, sets, and dictionaries. To help you with testing these types, you can use the following tests: Note that, in Home Assistant, Jinja has built-in tests for boolean (True/False), callable (any function), float (a number with a decimal), integer (a number without a decimal), iterable (a value that can be iterated over such as a list, set, string, or generator), mapping (mainly dict but also supports other dictionary like types), number (float or int), sequence (a value that can be iterated over and indexed such as list and string), and string. While Jinja natively supports the conversion of an iterable to a list, it does not support conversion to a tuple or set. To help you with using these types, you can use the following functions: Note that, in Home Assistant, to convert a value to a list, a string, an int, or a float, Jinja has built-in functions with names that correspond to each type. These functions are used to process raw value’s in a bytes format to values in a native Python type or vice-versa.\nThe pack and unpack functions can also be used as a filter. They make use of the Python 3 struct library.\nSee: Python struct library documentation Some examples: For more information on regular expressions\nSee: Python regular expression operations The other part of templating is processing incoming data. It allows you to modify incoming data and extract only the data you care about. This will only work for platforms and integrations that mention support for this in their documentation. It depends per integration or platform, but it is common to be able to define a template using the value_template configuration key. When a new value arrives, your template will be rendered while having access to the following values on top of the usual Home Assistant extensions: This means that if the incoming values looks like the sample below: The template for on would be: Nested JSON in a response is supported as well: Just use the “Square bracket notation” to get the value. The following overview contains a couple of options to get the needed values: To evaluate a response, go to Developer Tools > Template, create your output in “Template editor”, and check the result. The MQTT integration relies heavily on templates. Templates are used to transform incoming payloads (value templates) to status updates or incoming service calls (command templates) to payloads that configure the MQTT device. For incoming data a value template translates incoming JSON or raw data to a valid payload.\nIncoming payloads are rendered with possible JSON values, so when rendering the value_json can be used access the attributes in a JSON based payload. Example value template: With given payload: Template {{ value_json.temperature | round(1) }} renders to 21.9. Additional the MQTT entity attributes entity_id, name and this can be used as variables in the template. The this attribute refers to the entity state of the MQTT item. For service calls command templates are defined to format the outgoing MQTT payload to the device. When a service call is executed value can be used to generate the correct payload to the device. Example command template: With given value 21.9 template {\"temperature\": {{ value }} } renders to: Additional the MQTT entity attributes entity_id, name and this can be used as variables in the template. The this attribute refers to the entity state of the MQTT item. If your template uses an entity_id that begins with a number (example: states.device_tracker.2008_gmc) you must use a bracket syntax to avoid errors caused by rendering the entity_id improperly. In the example given, the correct syntax for the device tracker would be: states.device_tracker['2008_gmc'] The default priority of operators is that the filter (|) has priority over everything except brackets. This means that: Would round 10 to 2 decimal places, then divide states('sensor.temperature') by 10 (rounded to 2 decimal places so 10.00). This behavior is maybe not the one expected, but priority rules imply that."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/yaml/",
        "content": "Home Assistant uses the YAML syntax for configuration. YAML might take a while to get used to but is powerful in allowing you to express complex configurations. While more and more integrations are configured through the UI, for some, you will add code in your configuration.yaml file to specify its settings. The following example entry assumes that you would like to set up the notify integration with the pushbullet platform. The basics of YAML syntax are block collections and mappings containing key-value pairs. Each item in a collection starts with a - while mappings have the format key: value. This is somewhat similar to a Hash table or more specifically a dictionary in Python. These can be nested as well. Beware that if you specify duplicate keys, the last value for a key is used. In YAML, indentation is important for specifying relationships. Indented lines are nested inside lines that are one level higher. In the above example, platform: pushbullet is a property of (nested inside) the notify integration. Getting the right indentation can be tricky if you’re not using an editor with a fixed-width font. Tabs are not allowed to be used for indentation. The convention is to use 2 spaces for each level of indentation. To check if your YAML syntax is correct before loading it into Home Assistant, you can use the third-party service YAML Validator (not maintained by the Home Assistant community). Pay attention to not storing private data (passwords, API keys, etc.) directly in your configuration.yaml file. Private data can be stored in either a separate file or in environmental variables, which circumvents this security problem. Strings of text following a # are comments and are ignored by the system. The next example shows an input_select integration that uses a block collection for the values of options.\nThe other properties (like name:) are specified using mappings. Note that the second line just has threat: with no value on the same line. Here threat is the name of the input_select and the values for it are everything nested below it. The following example shows nesting a collection of mappings in a mapping. In Home Assistant, this would create two sensors that each use the MQTT platform but have different values for their state_topic (one of the properties used for MQTT sensors). On Home Assistant Core installations, you can include values from your system’s environment variables with !env_var.\nNote that this will only work for Home Assistant Core installations, in a scenario where it is possible to specify these.\nRegular Home Assistant users are recommended to use !include statements instead. If an environment variable is not set, you can fall back to a default value. To improve readability, you can source out certain domains from your main configuration file with the !include-syntax. More information about this feature can also be found at splitting configuration. If you see the following message: This means that you’ve mistakenly entered a tab character, instead of spaces. Home Assistant is case sensitive, a state of 'on' is not the same as 'On' or 'ON'. Similarly an entity of group.Doors is not the same as group.doors. If you’re having trouble, check the case that Home Assistant is reporting in the dev-state menu, under Developer tools. YAML treats Y, true, Yes, ON all as true and n, FALSE, No, off as false. This means that if you want to set the state of an entity to on you must quote it as 'on' otherwise it will be translated as setting the state to true. The same applies to off. Not quoting the value may generate an error such as:"
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/templating/#using-templates-with-the-mqtt-integration",
        "content": "This is an advanced feature of Home Assistant. You’ll need a basic understanding of: Templating is a powerful feature that allows you to control information going into and out of the system. It is used for: Templating in Home Assistant is powered by the Jinja2 templating engine. This means that we are using their syntax and make some custom Home Assistant variables available to templates during rendering. Jinja2 supports a wide variety of operations: We will not go over the basics of the syntax, as Jinja2 does a great job of this in their templates documentation. The frontend has a template editor tool to help develop and debug templates. Navigate to Developer Tools > Template, create your template in the Template editor and check the results on the right. Templates can get big pretty fast. To keep a clear overview, consider using YAML multiline strings to define your templates: There are a few very important rules to remember when adding templates to YAML: Remembering these simple rules will help save you from many headaches and endless hours of frustration when using automation templates. Jinja supports a set of language extensions that add new functionality to the language.\nTo improve the experience of writing Jinja templates, we have enabled the following\nextensions: You can write reusable Jinja templates by adding them to a custom_templates folder under your\nconfiguration directory. All template files must have the .jinja extension and be less than 5MiB.\nTemplates in this folder will be loaded at startup. To reload the templates without\nrestarting Home Assistant, invoke the homeassistant.reload_custom_templates service. Once the templates are loaded, Jinja includes and imports will work\nusing config/custom_templates as the base directory. For example, you might define a macro in a template in config/custom_templates/formatter.jinja: In your automations, you could then reuse this macro by importing it: Extensions allow templates to access all of the Home Assistant specific states and adds other convenience functions and filters. Templates for some triggers as well as trigger_variables only support a subset of the Home Assistant template extensions. This subset is referred to as “Limited Templates”. Not supported in limited templates. Avoid using states.sensor.temperature.state, instead use states('sensor.temperature'). It is strongly advised to use the states(), is_state(), state_attr() and is_state_attr() as much as possible, to avoid errors and error message when the entity isn’t ready yet (e.g., during Home Assistant startup). The next two statements result in the same value if the state exists. The second one will result in an error if the state does not exist. Print out a list of all the sensor states: Print out a list of all the sensor states sorted by entity_id: Entities that are on: Other state examples: The examples below show the output of a temperature sensor with state 20.001, unit °C and user configured presentation rounding set to 1 decimal. The following example results in the number 20.001: The following example results in the string \"20.0 °C\": The following example result in the string \"20.001 °C\": The following example results in the number 20.0: The following example results in the number 20.001: The following example results in the string \"20.0 °C\": Not supported in limited templates. You can print an attribute with state_attr if state is defined. With strings: List of friendly names: List of lights that are on with a brightness of 255: Not supported in limited templates. The expand function and filter can be used to sort entities and expand groups. It outputs a sorted array of entities with no duplicates. The same thing can also be expressed as a filter: The same thing can also be expressed as a test: A common case is to conditionally return a value based on another value.\nFor example, return a “Yes” or “No” when the light is on or off. This can be written as: Or using a shorter syntax: Additionally, to the above, you can use the iif function/filter, which is\nan immediate if. Syntax: iif(condition, if_true, if_false, if_none) iif returns the value of if_true if the condition is truthy, the value of if_false if it’s falsy and the value of if_none if it’s None.\nAn empty string, an empty mapping or an an empty list, are all falsy, refer to the Python documentation for an in depth explanation. if_true is optional, if it’s omitted True is returned if the condition is truthy.\nif_false is optional, if it’s omitted False is returned if the condition is falsy.\nif_none is optional, if it’s omitted the value of if_false is returned if the condition is None. Examples using iif: The immediate if filter does not short-circuit like you might expect with a typical conditional statement. The if_true, if_false and if_none expressions will all be evaluated and the filter will simply return one of the resulting values. This means you cannot use this filter to prevent executing an expression which would result in an error. For example, if you wanted to select a field from trigger in an automation based on the platform you might go to make this template: trigger.platform == 'event' | iif(trigger.event.data.message, trigger.to_state.state). This won’t work because both expressions will be evaluated and one will fail since the field doesn’t exist. Instead you have to do this trigger.event.data.message if trigger.platform == 'event' else trigger.to_state.state. This form of the expression short-circuits so if the platform is event the expression trigger.to_state.state will never be evaluated and won’t cause an error. now(), relative_time(), today_at(), and utcnow() are not supported in limited templates. now() returns a datetime object that represents the current time in your time zone. utcnow() returns a datetime object of the current time in the UTC timezone. today_at(value) converts a string containing a military time format to a datetime object with today’s date in your time zone. as_datetime() converts a string containing a timestamp, or valid UNIX timestamp, to a datetime object. as_timestamp(value, default) converts datetime object or string to UNIX timestamp. If that fails, returns the default value, or if omitted raises an error. This function can also be used as a filter. as_local() converts datetime object to local time. This function can also be used as a filter. strptime(string, format, default) parses a string based on a format and returns a datetime object. If that fails, it returns the default value or, if omitted, raises an error. relative_time converts datetime object to its human-friendly “age” string. The age can be in second, minute, hour, day, month or year (but only the biggest unit is considered, e.g., if it’s 2 days and 3 hours, “2 days” will be returned). Note that it only works for dates in the past. timedelta returns a timedelta object and accepts the same arguments as the Python datetime.timedelta function – days, seconds, microseconds, milliseconds, minutes, hours, weeks. as_timedelta(string) converts a string to a timedelta object. Expects data in the format DD HH:MM:SS.uuuuuu, DD HH:MM:SS,uuuuuu, or as specified by ISO 8601 (e.g. P4DT1H15M20S which is equivalent to 4 1:15:20) or PostgreSQL’s day-time interval format (e.g. 3 days 04:05:06) This function can also be used as a filter. Filter timestamp_local(default) converts a UNIX timestamp to the ISO format string representation as date/time in your local timezone. If that fails, returns the default value, or if omitted raises an error. If a custom string format is needed in the string, use timestamp_custom instead. Filter timestamp_utc(default) converts a UNIX timestamp to the ISO format string representation representation as date/time in UTC timezone. If that fails, returns the default value, or if omitted raises an error. If a custom string format is needed in the string, use timestamp_custom instead. Filter timestamp_custom(format_string, local=True, default) converts an UNIX timestamp to its string representation based on a custom format, the use of a local timezone is the default. If that fails, returns the default value, or if omitted raises an error. Supports the standard Python time formatting options. UNIX timestamp is the number of seconds that have elapsed since 00:00:00 UTC on 1 January 1970. Therefore, if used as a function’s argument, it can be substituted with a numeric value (int or float). If your template is returning a timestamp that should be displayed in the frontend (e.g., as a sensor entity with device_class: timestamp), you have to ensure that it is the ISO 8601 format (meaning it has the “T” separator between the date and time portion). Otherwise, frontend rendering on macOS and iOS devices will show an error. The following value template would result in such an error: {{ states.sun.sun.last_changed }} => 2023-07-30 20:03:49.253717+00:00 (missing “T” separator) To fix it, enforce the ISO conversion via isoformat(): {{ states.sun.sun.last_changed.isoformat() }} => 2023-07-30T20:03:49.253717+00:00 (contains “T” separator) The to_json filter serializes an object to a JSON string. In some cases, it may be necessary to format a JSON string for use with a webhook, as a parameter for command-line utilities or any number of other applications. This can be complicated in a template, especially when dealing with escaping special characters. Using the to_json filter, this is handled automatically. to_json also accepts boolean arguments for pretty_print, which will pretty print the JSON with a 2-space indent to make it more human-readable, and sort_keys, which will sort the keys of the JSON object, ensuring that the resulting string is consistent for the same input. If you need to generate JSON that will be used by a parser that lacks support for Unicode characters, you can add ensure_ascii=True to have to_json generate Unicode escape sequences in strings. The from_json filter operates similarly, but in the other direction, de-serializing a JSON string back into an object. Conversely, from_json can be used to de-serialize a JSON string back into an object to make it possible to easily extract usable data. Sometimes a template should only return if a value or object is defined, if not, the supplied default value should be returned. This can be useful to validate a JSON payload.\nThe is_defined filter allows to throw an error if a value or object is not defined. Example using is_defined to parse a JSON payload: This will throw an error UndefinedError: 'value_json' is undefined if the JSON payload has no val attribute. Examples: Not supported in limited templates. If only one location is passed in, Home Assistant will measure the distance from home. The closest function and filter will find the closest entity to the Home Assistant location: Find entities closest to a coordinate or another entity. All previous arguments still apply for second argument. Since closest returns a state, we can combine it with distance too. The last argument of the closest function has an implicit expand, and can take any iterable sequence of states or entity IDs, and will expand groups: It will also work as a filter over an iterable group of entities or groups: Jinja provides by default a in operator how return True when one element is in a provided list.\nThe contains test and filter allow you to do the exact opposite and test for a list containing an element. This is particularly useful in select or selectattr filter, as well as to check if a device has a specific attribute, a supported_color_modes, a specific light effect. Some examples: Some of these functions can also be used in a filter. This means they can act as a normal function like this sqrt(2), or as part of a filter like this 2|sqrt. The numeric functions and filters raise an error if the input is not a valid number, optionally a default value can be specified which will be returned instead. The is_number function and filter can be used to check if a value is a valid number. Errors can be caught by the default filter. float(value, default) function will attempt to convert the input to a float. If that fails, returns the default value, or if omitted raises an error. float(default) filter will attempt to convert the input to a float. If that fails, returns the default value, or if omitted raises an error. is_number will return True if the input can be parsed by Python’s float function and the parsed input is not inf or nan, in all other cases returns False. Note that a Python bool will return True but the strings \"True\" and \"False\" will both return False. Can be used as a filter. int(value, default) function is similar to float, but converts to an int instead. Like float, it has a filter form, and an error is raised if the default value is omitted. Fractional part is discarded: int(\"1.5\") is 1. bool(value, default) function converts the value to either true or false.\nThe following values are considered to be true: boolean true, non-zero ints and floats, and the strings \"true\", \"yes\", \"on\", \"enable\", and \"1\" (case-insensitive). false is returned for the opposite values: boolean false, integer or floating-point 0, and the strings \"false\", \"no\", \"off\", \"disable\", and \"0\" (also case-insensitive).\nIf the value is not listed here, the function returns the default value, or if omitted raises an error.\nThis function is intended to be used on states of binary sensors, switches, or similar entities, so its behavior is different from Python’s built-in bool conversion, which would consider e.g. \"on\", \"off\", and \"unknown\" all to be true, but \"\" to be false; if that is desired, use not not value or a similar construct instead.\nLike float and int, bool has a filter form. Using none as the default value is particularly useful in combination with the immediate if filter: it can handle all three possible cases in a single line. log(value, base, default) will take the logarithm of the input. When the base is omitted, it defaults to e - the natural logarithm. If value or base can’t be converted to a float, returns the default value, or if omitted raises an error. Can also be used as a filter. sin(value, default) will return the sine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. cos(value, default) will return the cosine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. tan(value, default) will return the tangent of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. asin(value, default) will return the arcus sine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. acos(value, default) will return the arcus cosine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. atan(value, default) will return the arcus tangent of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. atan2(y, x, default) will return the four quadrant arcus tangent of y / x. If y or x can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. sqrt(value, default) will return the square root of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. max([x, y, ...]) will obtain the largest item in a sequence. Uses the same parameters as the built-in max filter. min([x, y, ...]) will obtain the smallest item in a sequence. Uses the same parameters as the built-in min filter. average([x, y, ...], default) will return the average value of the sequence. If list is empty or contains non-numeric value, returns the default value, or if omitted raises an error. Can be used as a filter. median([x, y, ...], default) will return the median value of the sequence. If list is empty or contains non-numeric value, returns the default value, or if omitted raises an error. Can be used as a filter. statistical_mode([x, y, ...], default) will return the statistical mode value (most frequent occurrence) of the sequence. If the list is empty, it returns the default value, or if omitted raises an error. It can be used as a filter. e mathematical constant, approximately 2.71828. pi mathematical constant, approximately 3.14159. tau mathematical constant, approximately 6.28318. Filter round(precision, method, default) will convert the input to a number and round it to precision decimals. Round has four modes and the default mode (with no mode specified) will round-to-even. If the input value can’t be converted to a float, returns the default value, or if omitted raises an error. Filter value_one|bitwise_and(value_two) perform a bitwise and(&) operation with two values. Filter value_one|bitwise_or(value_two) perform a bitwise or(|) operation with two values. Filter ord will return for a string of length one an integer representing the Unicode code point of the character when the argument is a Unicode object, or the value of the byte when the argument is an 8-bit string. In addition to strings and numbers, Python (and Jinja) supports lists, sets, and dictionaries. To help you with testing these types, you can use the following tests: Note that, in Home Assistant, Jinja has built-in tests for boolean (True/False), callable (any function), float (a number with a decimal), integer (a number without a decimal), iterable (a value that can be iterated over such as a list, set, string, or generator), mapping (mainly dict but also supports other dictionary like types), number (float or int), sequence (a value that can be iterated over and indexed such as list and string), and string. While Jinja natively supports the conversion of an iterable to a list, it does not support conversion to a tuple or set. To help you with using these types, you can use the following functions: Note that, in Home Assistant, to convert a value to a list, a string, an int, or a float, Jinja has built-in functions with names that correspond to each type. These functions are used to process raw value’s in a bytes format to values in a native Python type or vice-versa.\nThe pack and unpack functions can also be used as a filter. They make use of the Python 3 struct library.\nSee: Python struct library documentation Some examples: For more information on regular expressions\nSee: Python regular expression operations The other part of templating is processing incoming data. It allows you to modify incoming data and extract only the data you care about. This will only work for platforms and integrations that mention support for this in their documentation. It depends per integration or platform, but it is common to be able to define a template using the value_template configuration key. When a new value arrives, your template will be rendered while having access to the following values on top of the usual Home Assistant extensions: This means that if the incoming values looks like the sample below: The template for on would be: Nested JSON in a response is supported as well: Just use the “Square bracket notation” to get the value. The following overview contains a couple of options to get the needed values: To evaluate a response, go to Developer Tools > Template, create your output in “Template editor”, and check the result. The MQTT integration relies heavily on templates. Templates are used to transform incoming payloads (value templates) to status updates or incoming service calls (command templates) to payloads that configure the MQTT device. For incoming data a value template translates incoming JSON or raw data to a valid payload.\nIncoming payloads are rendered with possible JSON values, so when rendering the value_json can be used access the attributes in a JSON based payload. Example value template: With given payload: Template {{ value_json.temperature | round(1) }} renders to 21.9. Additional the MQTT entity attributes entity_id, name and this can be used as variables in the template. The this attribute refers to the entity state of the MQTT item. For service calls command templates are defined to format the outgoing MQTT payload to the device. When a service call is executed value can be used to generate the correct payload to the device. Example command template: With given value 21.9 template {\"temperature\": {{ value }} } renders to: Additional the MQTT entity attributes entity_id, name and this can be used as variables in the template. The this attribute refers to the entity state of the MQTT item. If your template uses an entity_id that begins with a number (example: states.device_tracker.2008_gmc) you must use a bracket syntax to avoid errors caused by rendering the entity_id improperly. In the example given, the correct syntax for the device tracker would be: states.device_tracker['2008_gmc'] The default priority of operators is that the filter (|) has priority over everything except brackets. This means that: Would round 10 to 2 decimal places, then divide states('sensor.temperature') by 10 (rounded to 2 decimal places so 10.00). This behavior is maybe not the one expected, but priority rules imply that."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/remote/",
        "content": "If you’re interested in logging in to Home Assistant while away, you’ll have to make your instance remotely accessible. Below are a few options to do this. Remember to follow the securing checklist before doing this. Users of Home Assistant Cloud can use the Remote UI without requiring any configuration. A unique remote URL will be generated and given to you along with a certificate so all your traffic to Home Assistant is encrypted automatically. A secure way to remotely access your Home Assistant is to use a Virtual Private Network (VPN) service such as Tailscale or ZeroTier One. A VPN connection needs to be established before you can connect to your Home Assistant from outside your local network. The VPN makes this connection secure. When using the Home Assistant Companion app (such as on a mobile device), without this connection, your sensors will not update in Home Assistant. Set up port forwarding (for any port) from your router to port 8123 on the computer that is hosting Home Assistant. General instructions on how to do this can be found by searching <router model> port forwarding instructions. You can use any free port on your router and forward that to port 8123. A problem with making a port accessible is that some Internet Service Providers only offer dynamic IPs. This can cause you to lose access to Home Assistant while away. You can solve this by using a free Dynamic DNS service like DuckDNS. If you cannot access your Home Assistant installation remotely, remember to check if your ISP provides you with a dedicated IP, instead of one shared with other users via a CG-NAT. This is becoming fairly common nowadays due to the shortage of IPv4 addresses. Some, if not most ISPs will require you to pay an extra fee to be assigned a dedicated IPv4 address. Just putting a port up is not secure. You should definitely consider encrypting your traffic if you are accessing your Home Assistant installation remotely. For details please check the set up encryption using Let’s Encrypt blog post or this detailed guide to using Let’s Encrypt with Home Assistant."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/state_object",
        "content": "Your devicesA device is a model representing a physical or logical unit that contains entities.\n are represented in Home Assistant as entities. The entitiesAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] will write their current stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more] to the state machine for other entities/templates/frontend to access. States are a current representation of the entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more]. If you overwrite a state via the states dev tool or the API, it will not impact the actual device. If the device state is being polled, it will overwrite the state in the state machine the next polling. All states will always have an entity id, a state and a timestamp when last updated and last changed. The attributes of an entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] are optional. There are a few attributes that are used by Home Assistant for representing the entity in a specific way. Each integration will also have its own attributes to represent extra state data about the entity. For example, the light integration has attributes for the current brightness and color of the light. When an attribute is not available, Home Assistant will not write it to the state. When using templates, attributes will be available by their name. For example state.attributes.assumed_state. When an attribute contains spaces, you can retrieve it like this: state_attr('sensor.livingroom', 'Battery numeric'). Context is used to tie eventsAn event is when something happens.[Learn more] and statesThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more] together in Home Assistant. Whenever an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] or user interaction causes states to change, a new context is assigned. This context will be attached to all events and states that happen as result of the change."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/yaml/#migrating-your-yaml-automations-to-automationsyaml",
        "content": "Automations are created in Home Assistant via the UI, but are stored in a YAML format. If you want to edit the YAML of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more], select the automation, click on the menu button in the top right then on Edit in YAML. The UI will write your automations to automations.yaml. This file is managed by the UI and should not be edited manually. It is also possible to write your automations directly inside configuration.yaml or other YAML files. You can do this by adding a labeled automation block to your configuration.yaml: You can add as many labeled automation blocks as you want. Friendly name for the automation. A unique id for your automation, will allow you to make changes to the name and entity_id in the UI, and will enable debug traces. A description of the automation. Used to define the state of your automation at startup. When not set, the state will be restored from the last run. See Automation initial state. Configuration values for the traces stored, currently only stored_traces can be configured. The number of traces which will be stored. See Number of debug traces stored. Variables that will be available inside your templates, both in condition and action. The value of the variable. Any YAML is valid. Templates can also be used to pass a value to the variable. Variables that will be available inside your templates triggers. The value of the variable. Any YAML is valid. Only limited templates can be used. Controls what happens when the automation is invoked while it is still running from one or more previous invocations. See Automation modes. Controls maximum number of runs executing and/or queued up to run at a time. Only valid with modes queued and parallel. When max is exceeded (which is effectively 1 for single mode) a log message will be emitted to indicate this has happened. This option controls the severity level of that log message. See Log Levels for a list of valid options. Or silent may be specified to suppress the message from being emitted. The trigger(s) which will start the automation. Multiple triggers can be added and the automation will start when any of these triggers trigger. An ID that can be used in the automation to determine which trigger caused the automation to start. Variables that will be available in the conditions and action sequence. The value of the variable. Any YAML is valid. Templates can also be used to pass a value to the variable. Conditions that have to be true to start the automation. By default all conditions listed have to be true, you can use logical conditions to change this default behavior. The sequence of actions to be performed in the script. \n\n Example of a YAML based automation that you can add to configuration.yaml. When writing automations directly in YAML, you will have access to advanced options that are not available in the user interface. At startup, automations by default restore their last state of when Home Assistant ran. This can be controlled with the initial_state option. Set it to false or true to force initial state to be off or on. When using YAML you can configure the number of debugging traces stored for an automation. This is controlled with the stored_traces option under trace. Set stored_traces to the number of traces you wish to store for the particular automation. If not specified the default value of 5 will be used. If you want to migrate your manual automations to use the editor, you’ll have to copy them to automations.yaml. Make sure that automations.yaml remains a list! For each automation that you copy over, you’ll have to add an id. This can be any string as long as it’s unique. When automations remain visible in the Home Assistant dashboard, even after having deleted in the YAML file, you have to delete them in the UI. To delete them completely, go to UI Settings -> Devices & Services -> Entities and find the automation in the search field or by scrolling down. Check the square box aside of the automation you wish to delete and from the top-right of your screen, select ‘REMOVE SELECTED’."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/condition/",
        "content": "Conditions are an optional part of an automation rule. They can be used to prevent the automation’s actions from being run. After a triggerA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more] occurred, all conditions will be checked. If any of them do not return true, the automation will stop executing. Conditions look very similar to triggers, but they are very different — a trigger will look at events happening in the system, while a condition only looks at how the system looks right now. A trigger can observe that a switch is being turned on. A condition can only see if a switch is currently on or off. The available conditions for an automation are the same as for the script syntax so see that page for a full list of available conditions. Example of using condition: The condition option of an automation, also accepts a single condition template directly. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#numeric-state-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/templating/#home-assistant-template-extensions",
        "content": "This is an advanced feature of Home Assistant. You’ll need a basic understanding of: Templating is a powerful feature that allows you to control information going into and out of the system. It is used for: Templating in Home Assistant is powered by the Jinja2 templating engine. This means that we are using their syntax and make some custom Home Assistant variables available to templates during rendering. Jinja2 supports a wide variety of operations: We will not go over the basics of the syntax, as Jinja2 does a great job of this in their templates documentation. The frontend has a template editor tool to help develop and debug templates. Navigate to Developer Tools > Template, create your template in the Template editor and check the results on the right. Templates can get big pretty fast. To keep a clear overview, consider using YAML multiline strings to define your templates: There are a few very important rules to remember when adding templates to YAML: Remembering these simple rules will help save you from many headaches and endless hours of frustration when using automation templates. Jinja supports a set of language extensions that add new functionality to the language.\nTo improve the experience of writing Jinja templates, we have enabled the following\nextensions: You can write reusable Jinja templates by adding them to a custom_templates folder under your\nconfiguration directory. All template files must have the .jinja extension and be less than 5MiB.\nTemplates in this folder will be loaded at startup. To reload the templates without\nrestarting Home Assistant, invoke the homeassistant.reload_custom_templates service. Once the templates are loaded, Jinja includes and imports will work\nusing config/custom_templates as the base directory. For example, you might define a macro in a template in config/custom_templates/formatter.jinja: In your automations, you could then reuse this macro by importing it: Extensions allow templates to access all of the Home Assistant specific states and adds other convenience functions and filters. Templates for some triggers as well as trigger_variables only support a subset of the Home Assistant template extensions. This subset is referred to as “Limited Templates”. Not supported in limited templates. Avoid using states.sensor.temperature.state, instead use states('sensor.temperature'). It is strongly advised to use the states(), is_state(), state_attr() and is_state_attr() as much as possible, to avoid errors and error message when the entity isn’t ready yet (e.g., during Home Assistant startup). The next two statements result in the same value if the state exists. The second one will result in an error if the state does not exist. Print out a list of all the sensor states: Print out a list of all the sensor states sorted by entity_id: Entities that are on: Other state examples: The examples below show the output of a temperature sensor with state 20.001, unit °C and user configured presentation rounding set to 1 decimal. The following example results in the number 20.001: The following example results in the string \"20.0 °C\": The following example result in the string \"20.001 °C\": The following example results in the number 20.0: The following example results in the number 20.001: The following example results in the string \"20.0 °C\": Not supported in limited templates. You can print an attribute with state_attr if state is defined. With strings: List of friendly names: List of lights that are on with a brightness of 255: Not supported in limited templates. The expand function and filter can be used to sort entities and expand groups. It outputs a sorted array of entities with no duplicates. The same thing can also be expressed as a filter: The same thing can also be expressed as a test: A common case is to conditionally return a value based on another value.\nFor example, return a “Yes” or “No” when the light is on or off. This can be written as: Or using a shorter syntax: Additionally, to the above, you can use the iif function/filter, which is\nan immediate if. Syntax: iif(condition, if_true, if_false, if_none) iif returns the value of if_true if the condition is truthy, the value of if_false if it’s falsy and the value of if_none if it’s None.\nAn empty string, an empty mapping or an an empty list, are all falsy, refer to the Python documentation for an in depth explanation. if_true is optional, if it’s omitted True is returned if the condition is truthy.\nif_false is optional, if it’s omitted False is returned if the condition is falsy.\nif_none is optional, if it’s omitted the value of if_false is returned if the condition is None. Examples using iif: The immediate if filter does not short-circuit like you might expect with a typical conditional statement. The if_true, if_false and if_none expressions will all be evaluated and the filter will simply return one of the resulting values. This means you cannot use this filter to prevent executing an expression which would result in an error. For example, if you wanted to select a field from trigger in an automation based on the platform you might go to make this template: trigger.platform == 'event' | iif(trigger.event.data.message, trigger.to_state.state). This won’t work because both expressions will be evaluated and one will fail since the field doesn’t exist. Instead you have to do this trigger.event.data.message if trigger.platform == 'event' else trigger.to_state.state. This form of the expression short-circuits so if the platform is event the expression trigger.to_state.state will never be evaluated and won’t cause an error. now(), relative_time(), today_at(), and utcnow() are not supported in limited templates. now() returns a datetime object that represents the current time in your time zone. utcnow() returns a datetime object of the current time in the UTC timezone. today_at(value) converts a string containing a military time format to a datetime object with today’s date in your time zone. as_datetime() converts a string containing a timestamp, or valid UNIX timestamp, to a datetime object. as_timestamp(value, default) converts datetime object or string to UNIX timestamp. If that fails, returns the default value, or if omitted raises an error. This function can also be used as a filter. as_local() converts datetime object to local time. This function can also be used as a filter. strptime(string, format, default) parses a string based on a format and returns a datetime object. If that fails, it returns the default value or, if omitted, raises an error. relative_time converts datetime object to its human-friendly “age” string. The age can be in second, minute, hour, day, month or year (but only the biggest unit is considered, e.g., if it’s 2 days and 3 hours, “2 days” will be returned). Note that it only works for dates in the past. timedelta returns a timedelta object and accepts the same arguments as the Python datetime.timedelta function – days, seconds, microseconds, milliseconds, minutes, hours, weeks. as_timedelta(string) converts a string to a timedelta object. Expects data in the format DD HH:MM:SS.uuuuuu, DD HH:MM:SS,uuuuuu, or as specified by ISO 8601 (e.g. P4DT1H15M20S which is equivalent to 4 1:15:20) or PostgreSQL’s day-time interval format (e.g. 3 days 04:05:06) This function can also be used as a filter. Filter timestamp_local(default) converts a UNIX timestamp to the ISO format string representation as date/time in your local timezone. If that fails, returns the default value, or if omitted raises an error. If a custom string format is needed in the string, use timestamp_custom instead. Filter timestamp_utc(default) converts a UNIX timestamp to the ISO format string representation representation as date/time in UTC timezone. If that fails, returns the default value, or if omitted raises an error. If a custom string format is needed in the string, use timestamp_custom instead. Filter timestamp_custom(format_string, local=True, default) converts an UNIX timestamp to its string representation based on a custom format, the use of a local timezone is the default. If that fails, returns the default value, or if omitted raises an error. Supports the standard Python time formatting options. UNIX timestamp is the number of seconds that have elapsed since 00:00:00 UTC on 1 January 1970. Therefore, if used as a function’s argument, it can be substituted with a numeric value (int or float). If your template is returning a timestamp that should be displayed in the frontend (e.g., as a sensor entity with device_class: timestamp), you have to ensure that it is the ISO 8601 format (meaning it has the “T” separator between the date and time portion). Otherwise, frontend rendering on macOS and iOS devices will show an error. The following value template would result in such an error: {{ states.sun.sun.last_changed }} => 2023-07-30 20:03:49.253717+00:00 (missing “T” separator) To fix it, enforce the ISO conversion via isoformat(): {{ states.sun.sun.last_changed.isoformat() }} => 2023-07-30T20:03:49.253717+00:00 (contains “T” separator) The to_json filter serializes an object to a JSON string. In some cases, it may be necessary to format a JSON string for use with a webhook, as a parameter for command-line utilities or any number of other applications. This can be complicated in a template, especially when dealing with escaping special characters. Using the to_json filter, this is handled automatically. to_json also accepts boolean arguments for pretty_print, which will pretty print the JSON with a 2-space indent to make it more human-readable, and sort_keys, which will sort the keys of the JSON object, ensuring that the resulting string is consistent for the same input. If you need to generate JSON that will be used by a parser that lacks support for Unicode characters, you can add ensure_ascii=True to have to_json generate Unicode escape sequences in strings. The from_json filter operates similarly, but in the other direction, de-serializing a JSON string back into an object. Conversely, from_json can be used to de-serialize a JSON string back into an object to make it possible to easily extract usable data. Sometimes a template should only return if a value or object is defined, if not, the supplied default value should be returned. This can be useful to validate a JSON payload.\nThe is_defined filter allows to throw an error if a value or object is not defined. Example using is_defined to parse a JSON payload: This will throw an error UndefinedError: 'value_json' is undefined if the JSON payload has no val attribute. Examples: Not supported in limited templates. If only one location is passed in, Home Assistant will measure the distance from home. The closest function and filter will find the closest entity to the Home Assistant location: Find entities closest to a coordinate or another entity. All previous arguments still apply for second argument. Since closest returns a state, we can combine it with distance too. The last argument of the closest function has an implicit expand, and can take any iterable sequence of states or entity IDs, and will expand groups: It will also work as a filter over an iterable group of entities or groups: Jinja provides by default a in operator how return True when one element is in a provided list.\nThe contains test and filter allow you to do the exact opposite and test for a list containing an element. This is particularly useful in select or selectattr filter, as well as to check if a device has a specific attribute, a supported_color_modes, a specific light effect. Some examples: Some of these functions can also be used in a filter. This means they can act as a normal function like this sqrt(2), or as part of a filter like this 2|sqrt. The numeric functions and filters raise an error if the input is not a valid number, optionally a default value can be specified which will be returned instead. The is_number function and filter can be used to check if a value is a valid number. Errors can be caught by the default filter. float(value, default) function will attempt to convert the input to a float. If that fails, returns the default value, or if omitted raises an error. float(default) filter will attempt to convert the input to a float. If that fails, returns the default value, or if omitted raises an error. is_number will return True if the input can be parsed by Python’s float function and the parsed input is not inf or nan, in all other cases returns False. Note that a Python bool will return True but the strings \"True\" and \"False\" will both return False. Can be used as a filter. int(value, default) function is similar to float, but converts to an int instead. Like float, it has a filter form, and an error is raised if the default value is omitted. Fractional part is discarded: int(\"1.5\") is 1. bool(value, default) function converts the value to either true or false.\nThe following values are considered to be true: boolean true, non-zero ints and floats, and the strings \"true\", \"yes\", \"on\", \"enable\", and \"1\" (case-insensitive). false is returned for the opposite values: boolean false, integer or floating-point 0, and the strings \"false\", \"no\", \"off\", \"disable\", and \"0\" (also case-insensitive).\nIf the value is not listed here, the function returns the default value, or if omitted raises an error.\nThis function is intended to be used on states of binary sensors, switches, or similar entities, so its behavior is different from Python’s built-in bool conversion, which would consider e.g. \"on\", \"off\", and \"unknown\" all to be true, but \"\" to be false; if that is desired, use not not value or a similar construct instead.\nLike float and int, bool has a filter form. Using none as the default value is particularly useful in combination with the immediate if filter: it can handle all three possible cases in a single line. log(value, base, default) will take the logarithm of the input. When the base is omitted, it defaults to e - the natural logarithm. If value or base can’t be converted to a float, returns the default value, or if omitted raises an error. Can also be used as a filter. sin(value, default) will return the sine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. cos(value, default) will return the cosine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. tan(value, default) will return the tangent of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. asin(value, default) will return the arcus sine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. acos(value, default) will return the arcus cosine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. atan(value, default) will return the arcus tangent of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. atan2(y, x, default) will return the four quadrant arcus tangent of y / x. If y or x can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. sqrt(value, default) will return the square root of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter. max([x, y, ...]) will obtain the largest item in a sequence. Uses the same parameters as the built-in max filter. min([x, y, ...]) will obtain the smallest item in a sequence. Uses the same parameters as the built-in min filter. average([x, y, ...], default) will return the average value of the sequence. If list is empty or contains non-numeric value, returns the default value, or if omitted raises an error. Can be used as a filter. median([x, y, ...], default) will return the median value of the sequence. If list is empty or contains non-numeric value, returns the default value, or if omitted raises an error. Can be used as a filter. statistical_mode([x, y, ...], default) will return the statistical mode value (most frequent occurrence) of the sequence. If the list is empty, it returns the default value, or if omitted raises an error. It can be used as a filter. e mathematical constant, approximately 2.71828. pi mathematical constant, approximately 3.14159. tau mathematical constant, approximately 6.28318. Filter round(precision, method, default) will convert the input to a number and round it to precision decimals. Round has four modes and the default mode (with no mode specified) will round-to-even. If the input value can’t be converted to a float, returns the default value, or if omitted raises an error. Filter value_one|bitwise_and(value_two) perform a bitwise and(&) operation with two values. Filter value_one|bitwise_or(value_two) perform a bitwise or(|) operation with two values. Filter ord will return for a string of length one an integer representing the Unicode code point of the character when the argument is a Unicode object, or the value of the byte when the argument is an 8-bit string. In addition to strings and numbers, Python (and Jinja) supports lists, sets, and dictionaries. To help you with testing these types, you can use the following tests: Note that, in Home Assistant, Jinja has built-in tests for boolean (True/False), callable (any function), float (a number with a decimal), integer (a number without a decimal), iterable (a value that can be iterated over such as a list, set, string, or generator), mapping (mainly dict but also supports other dictionary like types), number (float or int), sequence (a value that can be iterated over and indexed such as list and string), and string. While Jinja natively supports the conversion of an iterable to a list, it does not support conversion to a tuple or set. To help you with using these types, you can use the following functions: Note that, in Home Assistant, to convert a value to a list, a string, an int, or a float, Jinja has built-in functions with names that correspond to each type. These functions are used to process raw value’s in a bytes format to values in a native Python type or vice-versa.\nThe pack and unpack functions can also be used as a filter. They make use of the Python 3 struct library.\nSee: Python struct library documentation Some examples: For more information on regular expressions\nSee: Python regular expression operations The other part of templating is processing incoming data. It allows you to modify incoming data and extract only the data you care about. This will only work for platforms and integrations that mention support for this in their documentation. It depends per integration or platform, but it is common to be able to define a template using the value_template configuration key. When a new value arrives, your template will be rendered while having access to the following values on top of the usual Home Assistant extensions: This means that if the incoming values looks like the sample below: The template for on would be: Nested JSON in a response is supported as well: Just use the “Square bracket notation” to get the value. The following overview contains a couple of options to get the needed values: To evaluate a response, go to Developer Tools > Template, create your output in “Template editor”, and check the result. The MQTT integration relies heavily on templates. Templates are used to transform incoming payloads (value templates) to status updates or incoming service calls (command templates) to payloads that configure the MQTT device. For incoming data a value template translates incoming JSON or raw data to a valid payload.\nIncoming payloads are rendered with possible JSON values, so when rendering the value_json can be used access the attributes in a JSON based payload. Example value template: With given payload: Template {{ value_json.temperature | round(1) }} renders to 21.9. Additional the MQTT entity attributes entity_id, name and this can be used as variables in the template. The this attribute refers to the entity state of the MQTT item. For service calls command templates are defined to format the outgoing MQTT payload to the device. When a service call is executed value can be used to generate the correct payload to the device. Example command template: With given value 21.9 template {\"temperature\": {{ value }} } renders to: Additional the MQTT entity attributes entity_id, name and this can be used as variables in the template. The this attribute refers to the entity state of the MQTT item. If your template uses an entity_id that begins with a number (example: states.device_tracker.2008_gmc) you must use a bracket syntax to avoid errors caused by rendering the entity_id improperly. In the example given, the correct syntax for the device tracker would be: states.device_tracker['2008_gmc'] The default priority of operators is that the filter (|) has priority over everything except brackets. This means that: Would round 10 to 2 decimal places, then divide states('sensor.temperature') by 10 (rounded to 2 decimal places so 10.00). This behavior is maybe not the one expected, but priority rules imply that."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/basic/",
        "content": "As part of the default onboarding process, Home Assistant can detect your location from IP address geolocation. Home Assistant will automatically select a unit system and time zone based on this location. You may adjust this during onboarding, or afterwards at Settings > System > General, network related configuration is found under Settings > System > Network. If you prefer YAML, you can add the following information to your configuration.yaml: You will not be able to edit anything in Settings > System > General in the UI if you are using YAML configuration for any of the following: name, latitude, longitude, elevation, unit_system, temperature_unit, time_zone, external_url, internal_url, country, currency. Additionally, some options are only visible after “Advanced Mode” is enabled on your User Profile. Name of the location where Home Assistant is running. Latitude of your location required to calculate the time the sun rises and sets. Longitude of your location required to calculate the time the sun rises and sets. Altitude above sea level in meters. Impacts sunrise data. metric for Metric, us_customary for US Customary. This also sets temperature_unit, Celsius for Metric and Fahrenheit for US Customary Override temperature unit set by unit_system. C for Celsius, F for Fahrenheit. Pick your time zone from the column TZ of Wikipedia’s list of tz database time zones Pick your currency code from the column Code of Wikipedia’s list of ISO 4217 active codes The URL that Home Assistant is available on from the internet. For example: https://example.duckdns.org:8123. Note that this setting may only contain a protocol, hostname and port; using a path is not supported. The URL that Home Assistant is available on from your local network. For example: http://homeassistant.local:8123. Note that this setting may only contain a protocol, hostname and port; using a path is not supported. Customize entities. Customize all entities in a domain. Customize entities matching a pattern. List of folders that can be used as sources for sending files. List of external URLs that can be fetched. URLs can match specific resources (e.g., http://10.10.10.12/images/image1.jpg) or a relative path that allows access to resources within it (e.g., http://10.10.10.12/images would allow access to anything under that path) A mapping of local media sources and their paths on disk. Default language used by Home Assistant. This may, for example, influence the language used by voice assistants. The language should be specified as an RFC 5646 language tag, and must be a language which Home Assistant is translated to. Country in which Home Assistant is running. This may, for example, influence radio settings to comply with local regulations. The country should be specified as an ISO 3166.1 alpha-2 code. Pick your country from the column Code of Wikipedia’s list of ISO 31661 alpha-2 officially assigned code codes Home Assistant offers a service to reload the core configuration while Home Assistant is running called homeassistant.reload_core_config. This allows you to change any of the above sections and see it being applied without having to restart Home Assistant. To call this service, go to the “Services” tab under Developer Tools, select the homeassistant.reload_core_config service and click the “CALL SERVICE” button. Alternatively, you can press the “Location & Customizations” button under Developer Tools > YAML."
    },
    {
        "url": "https://www.home-assistant.io/docs/tools/dev-tools/",
        "content": "The dashboard contains a section called Developer tools. \n\nScreenshot of Home Assistant's developer tools.\n The Developer Tools is meant for all (not just for the developers) to quickly try out things - like calling services, updating states, raising events, and publishing messages in MQTT). It is also a necessary tool for those who write custom automations and scripts by hand. The following describes each of the sections in detail. This section shows all the available entities, their corresponding state and the attribute values. The state and the attribute information is what Home Assistant sees at run time. To update the entity with a new state, or a new attribute value, click on the entity, scroll to the top, and modify the values, and click on “SET STATE” button. Note that this is the state representation of a device within Home Assistant. That means, it is what Home Assistant sees, and it does not communicate with the actual device in any manner. The updated information can still be used to trigger events, and state changes. To communicate with the actual device, it is recommended to call services in the services section above, instead of updating state. For example, changing the light.bedroom state from off to on does not turn on the light. If there is an automation that triggers on the state change of the light.bedroom, it will be triggered – even though the actual bulb has not turned on. Also, when the bulb state changes – the state information will be overridden (the refresh icon can be used to retrieve the latest information that Home Assistant has). In other words, the changes that are made through the “States” section are temporary, and is recommended to use for testing purposes only. The table containing all entities can be filtered for each column. The used search is a wildcard search meaning that if you input “office” in the entity column filter, every entity whose ID matches “*office*” will be shown. You can also add your own wildcards in the search input (e.g., “office*light”).\nThe attribute filter supports separate filters for attribute names and values, separated by a colon “:”. So the filter “location:3” will result in the table showing all entities that have an attribute name that contains “location” and whose attribute value contains “3”. This section is used to call Services that are available in the ServiceRegistry. The list of services in the “Service” dropdown are automatically populated based on the integrations that are found in the configuration, automation and script files. If a desired service does not exist, it means either the integration is not configured properly or not defined in the configuration, automation or script files. When a Service is selected, and if that service requires an entity_id to be passed, the “Entity” dropdown will automatically be populated with corresponding entities. A Service may also require additional input to be passed. It is commonly referred to as “service data”. The service data is accepted in YAML format, and it may be optional depending on the service. When an entity is selected from the Entity dropdown, it automatically populates service data with the corresponding entity_id. The service data YAML can then be modified to pass additional [optional] parameters. The following is an illustration on how to call a light.turn_on service. To turn on a light bulb, use the following steps: The template editor provides a way to quickly test templates prior to placing them into automations and scripts. A code editor is on the left side and your real-time output is displayed in the preview on the right side. By default, this will contain sample code that illustrates how templates can be written and tested. This sample code can be removed and replaced with your own. You can restore the default example by pressing the “Reset to Demo Template” button beneath the code editor. For more information about Jinja2, visit Jinja2 documentation, and also read templating document here. In the Events section, you can either fire an event on the event bus or subscribe to an event type in order to view the event data JSON. To fire an event, simply type the name of the event, and pass the event data in JSON format.\nFor example, to fire a custom event, enter the event_type as event_light_state_changed and the event data JSON as If there is an automation that handles that event, it will be automatically triggered. See below: To subscribe to an event, enter the event event type under “Listen to events” and click “Start listening”. Some events types are listed in the Events section under “Active listeners”. You can usually find information about event types for a particular integration in its documentation. You can then examine the event data JSON to find the correct parameters for your automations. For example, subscribing to the event type shelly.click of the Shelly integration, returns event data JSON similar to the following on a button press. The Statistics tab shows a list of long-term statistic entities. If the long term statistics is not working for an entity, a Fix Issue link is shown. Select it to view a description of the issue. There might also be an option to fix the issue.  Another use of the statistics developer tool is to correct any measurements. Select the\n\nicon. Use date & time to search for the incorrect data point and adjust the value.  The Assist tab lets you see how Home Assistant’s Assist processes a sentence. If no matching intent is found, then Assist is unable to interpret the sentence. If a matching intent was found, information is provided on the action that will be performed on which entities. The example below shows how the following sentence was parsed: what lights are on in the office. "
    },
    {
        "url": "https://www.home-assistant.io/docs/ecosystem/certificates/lets_encrypt/",
        "content": " This guide is for users running Home Assistant Core.\nIf you are using Home Assistant do not use this guide. Instead, use the DuckDNS add-on for Home Assistant. This guide was added on 16/03/2017 and was valid at the time of writing. This guide makes the following assumptions: Steps we will take: An IP address is a bit like a phone number. When you access your Home Assistant instance you type something similar to 192.168.0.200:8123 in to your address bar of your browser. The bit before the colon is the IP address (in this case 192.168.0.200) and the bit after is the port number (in this case 8123). When you SSH in to the device running Home Assistant you will use the same IP address, and you will use port 22. You may not be aware that you are using port 22, but if you are using Putty look in the box next to where you type the IP address, you will see that it has already selected port 22 for you. So, if an IP address is like a phone number, a port number is like an extension number. An analogy would be if you phone your local doctors on 192-1680-200 and the receptionist answers, you ask to speak to Dr. Smith and she will put you through to extension 8123, which is the phone Dr. Smith is sitting at. The doctors surgery is the device your Home Assistant is running on, Dr. Smith is your Home Assistant. Thusly, your Home Assistant instance is ‘waiting for your call’ on port 8123, at the device IP 192.168.0.200 . Now, to speak to the outside world your connection goes through a router. Your router will have two IP addresses. One is the internal network number, most likely 192.168.0.1 in my example, and an external IP address that incoming traffic is sent to. In the example of calling the doctors, the external IP is your telephone number’s area code. So, when we want to connect to our Home Assistant instance from outside our network we will need to call the correct extension number, at the correct phone number, in the correct area code. We will be looking for a system to run like this (in this example I will pretend our external IP is 203.0.113.12): Sounds simple? It really is except for two small, but easy to overcome, complications: To get around the issue of changing IP addresses we must remember that there are two IP addresses affected. Your external one (which we will ‘call’ to get on to your network from the internet) and your internal one (192.168.0.200 in the example I am currently using). So, we can use a static IP to ensure that whenever our device running Home Assistant connects to our router it always uses the same address. This way our internal IP never changes. This is covered in step 1 below. We then have no control over our external IP, as our Service Provider will give us a new one at random intervals. To fix this we will use a service called DuckDNS which will give us a name for our connection (something like examplehome.duckdns.org) and behind the scenes will continue to update your external IP. So no matter how many times the IP address changes, typing examplehome.duckdns.org in to our browser will convert to the correct, up-to-date, IP address. This is covered in step 3 below. To get around the issue of not being able to chain the IP addresses together (I can’t say I want to call 203.0.113.12 and be put through to 192.168.0.200, and then be put through to extension 8123) we use port forwarding. Port forwarding is the process of telling your router which device to allow the outside connection to speak to. In the doctors surgery example, port forwarding is the receptionist. This takes a call from outside, and forwards it to the correct extension number inside. It is important to note that port forwarding can forward an incoming request for one port to a different port on your internal network if you so choose, and we will be doing this later on. The end result being that when we have our TLS/SSL certificate our incoming call will by default be requesting port 443 (because that is the default HTTPS port, like the default SSH port is 22), our port forwarding rule can forward this to our Home Assistant instance on port 8123 (or we can specify the port number in the URL). When this guide is completed we will run something like this: So, let’s make it happen… Whenever a device is connected to a network it has an IP address. This IP address is often dynamically assigned to the device on connection. This means there are occasions where the IP address you use to access Home Assistant, or SSH in to the device running Home Assistant, may change. Setting a static IP address means that the device will always be on the same address. SSH in to your system running Home Assistant and login. Type the following command to list your network interfaces: You will receive an output similar to the image below: \n\nScreenshot\n Make a note of the interface name and the IP address you are currently on. In the picture it is the wireless connection that is highlighted, but with your setup it may be the wired one (eth0 or similar), make sure you get the correct information. Then type the following command to open the text file that controls your network connection: At the bottom of the file add the following lines: It is important to note that the first three bytes of your static IP address and your router’s IP address should be the same, e.g.: Press Ctrl + x to close the editor, pressing Y to save the changes when prompted. Reboot your device running HA: When it comes back up check that you can SSH in to it again on the IP address you wrote down. Make sure Home Assistant is running and access it via the local network by typing the IP address and port number in to the browser: All working? Hooray! You now have a static IP. This will now always be your internal IP address for your Home Assistant device. This will be known as YOUR-HA-IP for the rest of this guide. Log in to your router’s configuration pages and find the port forwarding options. This bit is hard to write a guide for because each router has a different way of presenting these options. Searching Google for “port forwarding” and the name of your router may help. When you find it you will likely have options similar to: Service name - Port Range - Local IP - Local Port - Protocol You may also have other options (like ‘source IP’), these can usually be left blank or in their default state. Set the port forwarding to: Then save the change. On my router you have to fill these values in, then press an ‘add’ button to add the new rule to the list, then save the changes. All routers have a different interface, but you must ensure that these rules are saved at this point. If you are unsure, you can reboot the router and log back in, if the rule is present it was saved, if not, it wasn’t! Once you have saved this rule, go to your browser, and go to: This will tell you your current external IP address Type the external IP address in to the URL bar with http:// in front and :8123 after like so (203.0.113.12 is my example!): Can you see your Home Assistant instance? If not, your router may not support ‘loopback’ - try the next step anyway and if that works, and this one still doesn’t, just remember that you cannot use loopback, so will have to use internal addresses when you’re on your home network. More on this later on if it’s relevant to you. Just to verify this isn’t some kind of witchcraft that is actually using your internal network, pick up your phone, disconnect it from your Wi-Fi so that you are on your mobile data and not connected to the home network, put the same URL in the browser on your phone. Can you see it now, from a device that is definitely not connected to your local network? Excellent! You now have a remotely accessible Home Assistant instance. But what if your external IP changes? Plus, remembering all those numbers is pretty hard, isn’t it? Read on to get yourself set up with a word-based URL at DuckDNS that will track any changes to your IP address so you don’t have to stress anymore. Open your browser and go to https://duckdns.org. Sign in and create an account using one of the id validation options in the top right corner. In the domains section pick a name for your subdomain, this can be anything you like, and click add domain. The URL you will be using later to access your Home Assistant instance from outside will be the subdomain you picked, followed by duckdns.org . For our example we will say our URL is examplehome.duckdns.org Set up Home Assistant to keep your DuckDNS URL and external IP address in sync. In your configuration.yaml file add the following: The access token is available on your DuckDNS page. Restart Home Assistant after the change. What you have now done is set up DuckDNS so that whenever you type examplehome.duckdns.org in to your browser it will convert that to your router’s external IP address. Your external IP address will always be up to date because Home Assistant will update DuckDNS every time it changes. Now type your new URL in to your address bar on your browser with port 8123 on the end: What now happens behind the scenes is this: Did it work? Super! You now have a remotely accessible Home Assistant instance that has a text-based URL and will not drop out if your service provider changes your IP. But, it is only as secure as the password you set, which can be snooped during your session by a malicious hacker with relative ease. So we need to set up some encryption with TLS/SSL, read on to find out how. First we need to set up another port forward like we did in step 2. Set your new rule to: Remember to save the new rule. Now SSH in to the device your Home Assistant is running on. If you’re running the ‘standard’ setup on a Raspberry Pi the chances are you just logged in as the ‘pi’ user. If not, you may have logged in as the Home Assistant user. There are commands below that require the Home Assistant user to be on the sudoers list. If you are not using the ‘standard’ Pi setup it is presumed you will know how to get your Home Assistant user on the sudoers list before continuing. If you are running the ‘standard’ Pi setup, from your ‘pi’ user issue the following command (where homeassistant is the Home Assistant user): If you did not already log in as the user that currently runs Home Assistant, change to that user (usually homeassistant or hass - you may have used a command similar to this in the past): Make sure you are in the home directory for the Home Assistant user: We will now install the certbot software: You might need to stop Home Assistant before continuing with the next step. You can do this via the Web-UI or use the following command if you are running on Raspbian: You can restart Home Assistant after the next step using the same command and replacing stop with start.\nNow we will run the certbot program to get our SSL certificate. You will need to include your email address and your DuckDNS URL in the appropriate places: Once the program has run it will generate a certificate and other files and place them in a folder /etc/letsencrypt/ . Confirm this file has been populated: This should show a folder named exactly after your DuckDNS URL. Our Home Assistant user needs access to files within the letsencrypt folder, so issue the following commands to change the permissions. Did all of that go without a hitch? Wahoo! Your Let’s Encrypt certificate is now ready to be used with Home Assistant. Move to step 5 to put it all together Following on from Step 4 your SSH will still be in the certbot folder. If you edit your configuration files over SSH you will need to change to our homeassistant folder: If you use Samba shares to edit your files you can exit your SSH now. If during step 4 you had to use port 443 instead of port 80 to generate your certificate, you should delete that rule now. Go to your router’s configuration pages and set up a new port forwarding rule, thus: Remember to save the rule changes. Now edit your configuration.yaml file to reflect the SSL entries and your base URL (changing the examplehome subdomain to yours in all three places): You may wish to set up other options for the HTTP integration at this point, these extra options are beyond the scope of this guide. Save the changes to configuration.yaml. Restart Home Assistant. In step 3 we accessed our Home Assistant from the outside world with our DuckDNS URL and our port number. We are going to use a slightly different URL this time. Note the S after http, and that no port number is added. This is because HTTPS will use port 443 automatically, and we have already set up our port forward to redirect this request to our Home Assistant instance on port 8123. You should now be able to see your Home Assistant instance via your DuckDNS URL, and importantly note that your browser shows the connection as secure. You will now NO LONGER be able to access your Home Assistant via your old internal IP address in the way you previously have. Your default way to access your Home Assistant instance, even from inside your house, is to use your DuckDNS URL. In cases where you need to access via the local network only (which should be few and far between) you can access it with the following URL (note the added S after http): …and accepting the browsers warning that you are connecting to an insecure site. This warning occurs because your certificate expects your incoming connection to come via your DuckDNS URL. It does not mean that your device has suddenly become insecure. Some cases such as this are where your router does not allow ‘loopback’ or where there is a problem with incoming connections due to technical failure. In these cases you can still use your internal connection and safely ignore the warnings. If you were previously using a webapp on your phone/tablet to access your Home Assistant you should delete the old one and create a new one with the new address. The old one will no longer work as it is not keyed to your new, secure URL. All done? Accessing your Home Assistant from across the world with your DuckDNS URL and a lovely secure logo on your browser? Ace! Now let’s clean up our port forwards so that we are only exposing the parts of our network that are absolutely necessary to the outside world. In step 2 we created a port forwarding rule called ha_test. This opens port 8123 to the world, and is no longer necessary. Go to your router’s configuration pages and delete the ha_test rule. You should now have two rules in relation to Home Assistant for your port forwards, named: ha_ssl and ha_letsencrypt If you have any more for Home Assistant you should delete them now. If you only have ha_ssl this is probably because during step 4 you had to use port 443 instead of port 80, so we deleted the rule during step 5. You are now part of one of two groups: Please remember whether you are a ONE-RULE person or a BOTH-RULE person for step 8! Let’s Encrypt certificates only last for 90 days. When they have less than 30 days left they can be renewed. Renewal is a simple process. Move on to step 7 to see how to monitor your certificates expiry date, and be ready to renew your certificate when the time comes. Setting a sensor to read the number of days left on your TLS/SSL certificate before it expires is not required, but it has the following advantages: If you do not wish to set up a sensor you can skip straight to step 8 to learn how to update your certificates. The sensor will rely on a command line program that needs to be installed on your device running Home Assistant. SSH in to the device and run the following commands: In cases where, for whatever reason, apt-get installing is not appropriate for your installation you can fetch the ssl-cert-check script from http://prefetch.net/code/ssl-cert-check bearing in mind that you will have to modify the command in the sensor code below to run the script from wherever you put it, modify permission if necessary and so on. To set up a senor add the following to your configuration.yaml (remembering to correct the URL for your DuckDNS): Save the configuration.yaml. Restart Home Assistant. On your default_view you should now see a sensor badge containing your number of days until expiry. If you’ve been following this guide from the start and have not taken any breaks in between, this should be 89 or 90. The sensor will update every 3 hours. You can place this reading on a card using groups, or hide it using customize. These topics are outside of the scope of this guide, but information can be found on their respective integrations pages: Group and Customize Got your sensor up and running and where you want it? Top drawer! Nearly there, now move on to the final steps to ensure that you’re never without a secure connection in the future. The certbot program we downloaded in step 4 contains a script that will renew your certificate. The script will only obtain a new certificate if the current one has less than 30 days left on it, so running the script more often than is actually needed will not cause any harm. If you are a ONE-RULE person (from step 6), you can automatically renew your certificate with your current port mapping by temporarily stopping Home Assistant and telling certbot to bind port 8123 internally, and using a tls-sni challenge so that the Let’s Encrypt CA binds port 443 externally. The flags used to specify these additional steps are shown below. If you are a TWO-RULE person (from step 6), you can automatically renew your certificate using a http-01 challenge and port 80. There are a number of options for automating the renewal process: Your certificate can be renewed as a ‘cron job’ - cron jobs are background tasks run by the computer at specified intervals (and are totally independent of Home Assistant). Defining cron is outside of the scope of this guide but you will have had dealings with crontab when setting up DuckDNS in step 3 To set a cron job to run the script at regular intervals: SSH in to your device running Home Assistant. Change to your Home Assistant user (where homeassistant is the name of the user): Open the crontab: If you are a TWO-RULE Person: Scroll to the bottom of the file and paste in the following line If you are a ONE-RULE Person: Scroll to the bottom of the file and paste in the following line Let’s take a moment to look at the differences here: Save the file and exit You can set an automation in Home Assistant to run the certbot renewal script. Add the following sections to your configuration.yaml if you are a TWO-RULE person If you are a ONE-RULE person, replace the certbot command above with certbot renew --quiet --no-self-upgrade --standalone --preferred-challenges tls-sni-01 --tls-sni-01-port 8123 --pre-hook \"sudo systemctl stop [email protected]\" --post-hook \"sudo systemctl start [email protected]\" You can manually update the certificate when your certificate is less than 30 days to expiry. To manually update: SSH in to your device running Home Assistant. Change to your Home Assistant user (where homeassistant is the name of the user): Change to your certbot folder Run the renewal command If you are a ONE-RULE person, replace the certbot command above with certbot renew --quiet --no-self-upgrade --standalone --preferred-challenges tls-sni-01 --tls-sni-01-port 8123 --pre-hook \"sudo systemctl stop [email protected]\" --post-hook \"sudo systemctl start [email protected]\" So, now were all set up. We have our secured, remotely accessible Home Assistant instance and we’re on track for keeping our certificates up to date. But what if something goes wrong? What if the automation didn’t fire? What if the cron job forgot to run? What if the dog ate my homework? Read on to set up an alert so you can be notified in plenty of time if you need to step in and sort out any failures. We set up our automatic renewal of our certificates and whatever method we used the certificate should be renewed on or around 30 days before it expires. But what if a week later it still hasn’t been? This alert will go off if the expiry time on the certificate gets down to 21 days. This will give you 3 weeks to fix the problem, get your new certificate installed and get another 90 days of secure Home Assistant connections in play. In your configuration.yaml add the following automation, adding your preferred notification platform where appropriate: If you receive this warning notification, follow the steps for a manual update from step 8. Any error messages received at that point can be googled and resolved. If the manual update goes without a hitch there may be something wrong with your chosen method for automatic updates, and you can start troubleshooting from there. So, that’s it. We’ve taken a Home Assistant instance that was only reachable on the local network, made it accessible from the internet, secured it, and set up a system to ensure that it always stays secure. Well done, go and treat yourself to a cookie! Thanks for the guide, but is Let’s Encrypt really fixed with outside ports 80&443 so I can’t use a custom port? This is still a good guide for HA Core, but when using HA Core, you might also run the Mosquitto MQTT Broker on the same machine in a secured mode (like for Owntracks or MQTT bridging). The broker will not automatically pick up changed/renewed SSL certs, so the renew_ssl shell command would probably look more like: Now certbot can run without sudo if it has write access to the cert folders/files, but\nsudo is still needed to start/stop services (like the Mosquitto MQTT Broker), so this will hang, because the homeassistant user would ask for a sudo password. I didn’t want to make the homeassistant user part of the sudo group, so I used a sudoers file /etc/sudoers.d/030_homeassistant_shell_commands for this: This will allow members of the homeassistant group to use sudo without a password and should eventually be more refined (much as the old hassbian scripts sudoer rules), because as shown it poses a certain security risk to systems that are reachable from “outside” your network. This is just to show how it can be done, so your HA Core can automate even more things. For more detailed information, please check man sudoers.5. This worked for me running HASS on 8123. I do have port 80 exposed with no service listening to the port, though. Just have to use https://your.domain.org:8123/ as the URL. I’ve followed this guide through #5, but can’t get any further. I have a DuckDNS account, and have managed to create port forwards and SSL cert files… but get the error: I moved my key files, but they are valid, and so are the paths. Somehow, it’s as if I don’t have the http integration? I’ve a problem the expiry time. When I run the command in a terminal on my Pi I’ve the correct value in return But the sensor don’t show any value. An idea? Im wondering if there is a write-up on installing the TLS/SSL on a HA docker install…\nIm very green on Docker. Hello,\nnew to HA (outstanding to me…). I tried to setup the external access to HA via Let’s Encrypt… All fine apparently, but when I try to access HA from outside I get: A doubt: is the CA provided by certbot within the “common” set of CAs?\nOr shall I configure something on the smartphone side? Any suggestion?\nThanks! solved …\nmy mistake: i missed the following configuration.yaml entries: now works flawlessly  I have the https working great but I want to use fison67’s HA-Connector SmartApp to bring a few HA only devices over to my ST hub but he states that https will not work with his SmartApp. Is there a way to keep my https setup with duckdns and also have http with an http_password available as well or is that not possible? Thanks for any help. EXCELLENT guide, thanks a lot! Hi I decided to use this guideline I’ll reserve this post to note my comments Assumptions link to this assumption \" You have already secured your Home Assistant instance, following the advice \" has to be changed to … https://www.home-assistant.io/docs/configuration/securing/ 0,1 ,2,3= OK ( HA android app connected to HA by http:subdomain.duckdns.org:8123 + TFA authentication) Great guide, however I’m using homeassistant docker and it errors when trying to install certbot. Looks like the docker image is stripped down the bare basics, any idea on how to get around this? thanks bash-5.0$ apt-get install certbot -y\nbash: apt-get: command not found Is this manual intended for use on a separate install on raspbian. I get stuck when I want to login with SSH. I can’t do sudo there! I’m 75% down the road, currently at the ssl-cert-check step, but I have encountered a couple of problems: btw, my home-assistant is running in a freebsd jail Hey guys, I created a video in GERMAN / deutsch how to use Let’s Encrypt together with DuckDNS.\nPerhaps it is also helpful for some of you: https://youtu.be/O9J7v08PT9c Best regards, Tristan Thanks guys for this guide. I have a issue with installing TLS/SSL with Let’s Encrypt. My outside ports ports 80&443 are blocked by Unifi USG Pro-4. So I can do a forward rule on my firewall, but before this rule work the USG Pro-4 takes controll. I could not find anything to switch of this two ports on USG. For this reason I can’t use outside ports 80&443. So when I run sudo certbot certonly --standalone --preferred-challenges http-01 --email [email protected] -d xxx.yyy.org I get following error message Saving debug log to /var/log/letsencrypt/letsencrypt.log\nPlugins selected: Authenticator standalone, Installer None\nObtaining a new certificate\nPerforming the following challenges:\nhttp-01 challenge for XXXX\nCleaning up challenges\nProblem binding to port 80: Could not bind to IPv4 or IPv6. Any ideas how I can fix that so that let’s encrypt is using another port Thanks in advance, Tom Hi Tom Good to see you here  Let’s connect tomorrow to check your USG Configuration. I had no problems setting up the PortForwarding on my USG. BTW: I’m getting blocked by your PI-Hole when accessing your public URL on port 80… You’ve probably solved this already, but to help others out: when using the dockerized Home Assistant, the correct command is apk add certbot. It’s using Alpine Linux. Powered by Discourse, best viewed with JavaScript enabled"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#device-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/energy/battery/",
        "content": "A home battery allows homes to store energy when you are either producing more solar power than you’re using, or store energy from the grid if the current price is low. Home Assistant allows you to track how much energy flows from/to your battery. Home Assistant will need to know the amount of energy flowing from/to your batteries. This data can be tracked in various ways. Some battery vendors have an API to integrate the data into your Home Assistant instance. An example is Tesla Powerwall. Current transformer (CT) clamp sensors measure your energy usage by looking at the current passing through an electrical wire. This makes it possible to calculate the energy usage. In Home Assistant we have support for off-the-shelf CT clamp sensors or you can build your own. Attention! Installing CT clamp sensor devices requires opening your electrical cabinet. This work should be done by someone familiar with electrical wiring and may require a licensed professional in some regions. Your qualified installer will know how to do this. Disclaimer: Some links in this section are affiliate links."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/events/",
        "content": "The core of Home Assistant is the event bus. The event bus allows any integration to fire or listen for events. It is the core of everything. For example, any state change will be announced on the event bus as a state_changed event containing the previous and the new state of an entity. Home Assistant contains a few built-in events that are used to coordinate between various integrations. All events share these basic fields. In addition, all events contain a data dictionary with event-specific information. These are described below. This event is fired when a service is called. This event is fired when a new integration has been loaded and initialized. Please note that while this event is fired for each loaded integration during Home Assistant startup, the automation engine of Home Assistant is started last. Thus this event can not be used to run automations during startup as it would have missed these events. This event is fired when the core configuration is updated, for example when the location has been changed. It contains no additional data. This event is fired when a data entry flow has changed and is used by the frontend to reload the flow state. These events are fired during the startup of Home Assistant, in the following order: These events contain no additional data. If you want to trigger automation on a Home Assistant start event, we recommend using the special Home Assistant trigger instead of listening to these events. These events are fired during the shutdown of Home Assistant, in the following order: These events contain no additional data. Please note that homeassistant_final_write and homeassistant_close, cannot be used with automations, as the automation engine would already have been stopped when those are fired. If you want to trigger automation on a Home Assistant stop event, we recommend using the special Home Assistant trigger instead of listening to these events. This event is fired when a new service has been registered within Home Assistant. This event is fired when a service has been removed from Home Assistant. This event is fired when a state has changed. It contains the entity identifier and both the new_state and old_state of the entity as state objects. This event is fired after a theme has been set or reloaded. It contains no additional data. This event is fired when a user has been added. This event is fired when a user has been removed. Integration: automation This event is fired when automations have been reloaded and thus might have changed. This event contains no additional data. Integration: automation This event is fired when an automation is triggered. Integration: homeassistant This event is fired when scenes have been reloaded and thus might have changed. This event contains no additional data. Integration: script This event is fired when a script is run. A script can be invoked by a user or triggered by an automation. The resulting changes can be tracked because all related events will share the same context as this event."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#webhook-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/modes/",
        "content": "An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered while it is already running. The automation’s mode configuration option controls what happens when the automation is triggered while the actionsActions are used in several places in Home Assistant. As part of a script or automation, actions define what is going to happen once a trigger is activated. In scripts, an action is called sequence.\n[Learn more] are still running from a previous triggerA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more]. \n\n For both queued and parallel modes, configuration option max controls the maximum\nnumber of runs that can be executing and/or queued up at a time. The default is 10. When max is exceeded (which is effectively 1 for single mode) a log message will be emitted to indicate this has happened. Configuration option max_exceeded controls the severity level of that log message. Set it to silent to ignore warnings or set it to a log level. The default is warning. Some automations you only want to run every 5 minutes. This can be achieved using the single mode and silencing the warnings when the automation is triggered while it’s running. Sometimes an automation is doing an action on a device that does not support multiple simultaneous actions. In such cases, a queue can be used. In that case, the automation will be executed once it’s current invocation and queue are done."
    },
    {
        "url": "https://www.home-assistant.io/docs/scripts/conditions/#trigger-condition",
        "content": "Conditions can be used within a scriptScripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on.\n[Learn more] or automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] to prevent further execution. When a condition evaluates true, the script or automation will be executed. If any other value is returned, the script or automation stops executing. A condition will look at the system at that moment. For example, a condition can test if a switch is currently turned on or off. Unlike a triggerA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more], which is always or, conditions are and by default - all conditions have to be true. All conditions support an optional alias. Test multiple conditions in one condition statement. Passes if all embedded conditions are true. If you do not want to combine AND and OR conditions, you can list them sequentially. The following configuration works the same as the one listed above: Currently you need to format your conditions like this to be able to edit them using the automations editor. The AND condition also has a shorthand form. The following configuration works the same as the ones listed above: Test multiple conditions in one condition statement. Passes if any embedded condition is true. The OR condition also has a shorthand form. The following configuration works the same as the one listed above: Test multiple AND and OR conditions in one condition statement. Passes if any embedded condition is true.\nThis allows you to mix several AND and OR conditions together. Or in shorthand form: Test multiple conditions in one condition statement. Passes if all embedded conditions are not true. The NOT condition also has a shorthand form. The following configuration works the same as the one listed above: This type of condition attempts to parse the state of the specified entity or the attribute of an entity as a number, and triggers if the value matches the thresholds. If both below and above are specified, both tests have to pass. You can optionally use a value_template to process the value of the state before testing it. It is also possible to test the condition against multiple entities at once.\nThe condition will pass if all entities match the thresholds. Alternatively, the condition can test against a state attribute.\nThe condition will pass if the attribute value of the entity matches the thresholds. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below\noptions to make the condition more dynamic. Tests if an entity has a specified state. It is also possible to test the condition against multiple entities at once.\nThe condition will pass if all entities match the state. Instead of matching all, it is also possible if one of the entities matches.\nIn the following example the condition will pass if any entity matches the state. Testing if an entity is matching a set of possible conditions;\nThe condition will pass if the entity matches one of the states given. Or, combine multiple entities with multiple states. In the following example,\nboth media players need to be either paused or playing for the condition to pass. Alternatively, the condition can test against a state attribute.\nThe condition will pass if the attribute matches the given state. Finally, the state option accepts helper entities (also known as input_*\nentities). The condition will pass if the state of the entity matches the state\nof the given helper entity. You can also use templates in the for option. The for template(s) will be evaluated when the condition is tested. The sun state can be used to test if the sun has set or risen. The sun elevation can be used to test if the sun has set or risen, it is dusk, it is night, etc. when a trigger occurs.\nFor an in-depth explanation of sun elevation, see sun elevation trigger. The sun condition can also test if the sun has already set or risen when a trigger occurs. The before and after keys can only be set to sunset or sunrise. They have a corresponding optional offset value (before_offset, after_offset) that can be added, similar to the sun trigger. Note that if only before key is used, the condition will be true from midnight until sunrise/sunset. If only after key is used, the condition will be true from sunset/sunrise until midnight. If both before: sunrise and after: sunset keys are used, the condition will be true from midnight until sunrise and from sunset until midnight. If both after: sunrise and before: sunset keys are used, the condition will be true from sunrise until sunset. This is an example of 1 hour offset before sunset: This is ‘when dark’ - equivalent to a state condition on sun.sun of below_horizon: This is ‘when light’ - equivalent to a state condition on sun.sun of above_horizon: A visual timeline is provided below, showing an example of when these conditions are true. In this chart, sunrise is at 6:00, and sunset is at 18:00 (6:00 PM). The green areas of the chart indicate when the specified conditions are true.  The template condition tests if the given template renders a value equal to true. This is achieved by having the template result in a true boolean expression or by having the template render True. Within an automation, template conditions also have access to the trigger variable as described here. The template condition has a shorthand notation that can be used to make your scripts and automations shorter. For example: Or in a list of conditions, allowing to use existing conditions as described in this\nchapter and one or more shorthand template conditions This shorthand notation can be used everywhere in Home Assistant where\nconditions are accepted. For example, in and, or\nand not conditions: It’s also supported in the repeat action’s while or until option, or in a choose action’s conditions option: It’s also supported in script or automation condition actions: The time condition can test if it is after a specified time, before a specified time or if it is a certain day of the week. Valid values for weekday are mon, tue, wed, thu, fri, sat, sun.\nNote that if only before key is used, the condition will be true from midnight until the specified time.\nIf only after key is used, the condition will be true from the specified time until midnight.\nTime condition windows can span across the midnight threshold if both after and before keys are used. In the example above, the condition window is from 3pm to 2am. A better weekday condition could be by using the Workday Binary Sensor. For the after and before options a time helper (input_datetime entity)\nor another sensor entity containing a timestamp with the “timestamp” device\nclass, can be used instead. Please note that the time condition only takes the time into account. If\na referenced sensor or helper entity contains a timestamp with a date, the\ndate part is fully ignored. The trigger condition can test if an automation was triggered by a certain trigger, identified by the trigger’s id. For a trigger identified by its index, both a string and integer is allowed: It is possible to give a list of triggers: Zone conditions test if an entity is in a certain zone. For zone automation to work, you need to have set up a device tracker platform that supports reporting GPS coordinates. It is also possible to test the condition against multiple entities at once.\nThe condition will pass if all entities are in the specified zone. Testing if an entity is matching a set of possible zones;\nThe condition will pass if the entity is in one of the zones. Or, combine multiple entities with multiple zones. In the following example,\nboth entities need to be either in the home or the work zone for the condition\nto pass. Every individual condition can be disabled, without removing it.\nTo do so, add enabled: false to the condition configuration. This can be useful if you want to temporarily disable a condition, for example,\nfor testing. A disabled condition will behave as if it were removed. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/splitting_configuration",
        "content": "So you’ve been using Home Assistant for a while now and your configuration.yaml file brings people to tears or you simply want to start off with the distributed approach, here’s how to split the configuration.yaml into more manageable (read: humanly readable) pieces. First off, several community members have sanitized (read: without API keys/passwords etc) versions of their configurations available for viewing, you can see a list of them here. As commenting code doesn’t always happen, please read on for the details. Now despite the logical assumption that the configuration.yaml will be replaced by this process it will in fact remain, albeit in a much less cluttered form. In this lighter version we will still need what could be called the core snippet: Note that each line after homeassistant: is indented two (2) spaces. Since the configuration files in Home Assistant are based on the YAML language, indentation and spacing are important. Also note that seemingly strange entry under customize:. !include customize.yaml is the statement that tells Home Assistant to insert the contents of customize.yaml at that point. This is how we are going to break a monolithic and hard to read file (when it gets big) into more manageable chunks. Now before we start splitting out the different components, let’s look at the other integrations (in our example) that will stay in the base file: As with the core snippet, indentation makes a difference. The integration headers (mqtt:) should be fully left aligned (aka no indent), and the key (sensor:) should be indented two (2) spaces. The list - under the key sensor should be indented another two (2) spaces followed by a single space. The mqtt sensor list contains two (2) configurations containing two (2) keys each. While some of these integrations can technically be moved to a separate file they are so small or “one off’s” where splitting them off is superfluous. Also, you’ll notice the # symbol (hash/pound). This represents a “comment” as far as the commands are interpreted. Put another way, any line prefixed with a # will be ignored. This makes breaking up files for human readability really convenient, not to mention turning off features while leaving the entry intact. Now, lets assume that a blank file has been created in the Home Assistant configuration directory for each of the following: automation.yaml will hold all the automation integration details. zone.yaml will hold the zone integration details and so forth. These files can be called anything but giving them names that match their function will make things easier to keep track of. Inside the base configuration file add the following entries: Nesting !includes (having an !include within a file that is itself !included) will also work. Some integrations support multiple top-level !includes, this includes integrations defining an IoT domain, e.g. light, switch, sensor as well as the automation, script and template integrations, if you give a different label to each one. Configuration for other integrations can instead be split up by using packages. To learn more about packages, see the Packages page. Example of multiple top-level keys for the light platform. where light-groups.yaml might look like: with light-switches.yaml containing: Alright, so we’ve got the single integrations and the include statements in the base file, what goes in those extra files? Let’s look at the device_tracker.yaml file from our example: This small example illustrates how the “split” files work. In this case, we start with two (2) device tracker entries (owntracks and nmap). These files follow “style 1” that is to say a fully left aligned leading entry (- platform: owntracks) followed by the parameter entries indented two (2) spaces. This (large) sensor configuration gives us another example: You’ll notice that this example includes a secondary parameter section (under the steam section) as well as a better example of the way comments can be used to break down files into sections. All of the above can be applied when splitting up files using packages. To\nlearn more about packages, see the Packages page. That about wraps it up. If you have issues checkout home-assistant.log in the configuration directory as well as your indentations. If all else fails, head over to our Discord chat server and ask away. If you have many configuration files, Home Assistant provides a CLI that allows you to see how it interprets them, each installation type has its own section in the common-tasks about this: We offer four advanced options to include whole directories at once. Please note that your files must have the .yaml file extension; .yml is not supported. This will allow you to !include files with .yml extensions from within the .yaml files; without those .yml files being imported by the following commands themselves. These work recursively. As an example using !include_dir_list automation, will include all 6 files shown below: configuration.yaml can be turned into: configuration.yaml automation/presence/automation1.yaml automation/presence/automation2.yaml It is important to note that each file must contain only one entry when using !include_dir_list. configuration.yaml can be turned into: configuration.yaml alexa/LocateIntent.yaml alexa/WhereAreWeIntent.yaml configuration.yaml can be turned into: configuration.yaml automation/presence.yaml It is important to note that when using !include_dir_merge_list, you must include a list in each file (each list item is denoted with a hyphen [-]). Each file may contain one or more entries. configuration.yaml can be turned into: configuration.yaml group/interior.yaml group/exterior.yaml You want to go the advanced route and split your automations, but still want to be able to create automations in the UI?\nIn a chapter above we write about nesting !includes. Here is how we can do that for automations. Using labels like manual or ui allows for using multiple keys in the config: configuration.yaml"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/editor/",
        "content": "The automation editor is an easy way of creating and editing automations from the UI. This page uses the Random sensor as an example, though any other sensor with a numeric value can be used as well. From the UI, choose Settings which is located in the sidebar, then click on Automations & Scenes to go to the automation editor. Press the Create Automation button in the lower right corner to get started. You can create an automation based on a blueprint or start from scratch. Select Create new automation.  Click on the Add Trigger button and select Numeric state.  If the value of the sensor is greater than 10, then the automation should trigger.  Click on the Add Action button and select Call service.  The action for this automation creates a persistent notification.  As the message we want a simple text that is shown as part of the notification. Press the Save button, and the save dialogue will appear. Give your automation a meaningful name and press the Save button again.  Automations created or edited via the user interface are activated immediately after saving the automation. Read the documentation for Automating Home Assistant to learn more about automations. When you’re creating automations using the GUI and they don’t appear in the UI, make sure that you add back automation: !include automations.yaml from the default configuration to your configuration.yaml."
    },
    {
        "url": "https://www.home-assistant.io/docs/energy/solar-panels/",
        "content": "Gain insight into your energy production by integrating your solar panels into Home Assistant. If you also set up the Solar Forecast integration, you will be able to see expected solar production and automate based on planned production. Home Assistant will need to know the amount of energy that is being produced. This can be done in various ways. Current transformer (CT) clamp sensors measure your energy usage by looking at the current passing through an electrical wire. This makes it possible to calculate the energy usage. In Home Assistant we have support for off-the-shelf CT clamp sensors or you can build your own. Attention! Installing CT clamp sensor devices requires opening your electrical cabinet. This work should be done by someone familiar with electrical wiring and may require a licensed professional in some regions. Your qualified installer will know how to do this. Disclaimer: Some links in this section are affiliate links. Some solar inverters have APIs that can be read by Home Assistant. Energy integrations"
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#time-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/platform_options/",
        "content": "Some integrations or platforms (those that are based on the entity class) allow various extra options to be set. By setting an entity namespace, all entities will be prefixed with that namespace. That way, light.bathroom can become light.holiday_house_bathroom. Platforms that require polling will be polled in an interval specified by the main integration. For example, a light will check every 30 seconds for a changed state. It is possible to overwrite this scanning interval for any platform that is being polled by specifying a scan_interval configuration key. In the example below, we set up the your_lights platform but tell Home Assistant to poll the devices every 10 seconds instead of the default 30 seconds."
    },
    {
        "url": "https://www.home-assistant.io/docs/scene/",
        "content": "You can create scenes that capture the states you want certain entities to be. For example, a scene can specify that light A should be turned on and light B should be bright red. In the scene you define in your YAML files, please ensure you use\nall required parameters as listed below. Friendly name of the scene. Description of the scene. Entities to control and their desired state. As you can see, there are two ways to define the states of each entity_id: Scenes can be activated using the service scene.turn_on (there is no ‘scene.turn_off’ service). With the scene.apply service you are able to apply a scene without first defining it via configuration. Instead, you pass the states as part of the service data. The format of the data is the same as the entities field in a configuration. Both the scene.apply and scene.turn_on services support setting a transition,\nwhich enables you to smoothen the transition to the scene. This is an example of an automation that sets a romantic scene, in which the\nlight will transition to the scene in 2.5 seconds. Transitions are currently only support by lights, which in their turn, have\nto support it as well. However, the scene itself does not have to consist of\nonly lights to have a transition set. Whenever you make a change to your scene configuration, you can call the scene.reload service to reload the scenes."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#sentence-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/frontend/icons/",
        "content": "\n\n Home Assistant utilizes the community-driven Material Design Icons (MDI) project for icons in the frontend. The icon library is a superset of the base icon library provided by Google and contains thousands of community-made icons for very specific applications, industries, and use-cases. Every entity in Home Assistant has a default icon assigned to it. There are way too many to list out here, but you’ll see them in your dashboard. You can customize any of your entities to change the icons displayed to you. The most common way you can find icons is by using the icon picker built right into Home Assistant. Select the “Icon” field when customizing an entity and start typing. The list will filter to icons that match your search criteria. You can also scroll through all available icons when the field is empty. \n\n The icon picker will filter by icon name and by aliases applied to the icon by the MDI project. For example, typing “user” will show you most “account”-named icons. The easiest way to browse and find icons outside of Home Assistant is with the official Material Design Icons Picker browser extension. The extension is available for Chrome, Firefox, and Edge and is maintained by the MDI team. \n\n Not all icons that appear in the MDI Picker Browser Extension may be available in Home Assistant (yet!). While the browser extension is updated as MDI releases new packages, Home Assistant may lag behind until its next release. The last way to browse through available icons is by viewing the library on the Pictogrammers website, https://pictogrammers.com/library/mdi/. Select an icon you’d like to use, then click “Home Assistant” to see an example of its usage. The Pictogrammers website will always show the latest release of the material design icons library. However, you may find icons that may not yet be available in Home Assistant (yet!). Watch the Home Assistant release notes for announcements on upgrades of the Material Design Icons library. Being open-source like Home Assistant, the material design icons library is always accepting suggestions and contributions to expand the library. Before suggesting or creating a new icon, it is very important that you search the current library and search all issues, open and closed, on their GitHub. Try searching with different terms that might mean the same thing. (e.g. “user”, “person”, “account”) If you have an idea for an icon that isn’t currently in the library, but are not interested in creating it yourself, open a new icon suggestion. If you want to contribute a new icon to the library, familiarize yourself with the System icons guidelines in the Material Design system. Then create your icon and submit it to the Pictogrammers team for review. Sometimes an icon exists, but you aren’t able to find it with the terms you were searching for. If this has ever happened to you, please open an issue with the Pictogrammers team to suggest new aliases that can be added to existing icons."
    },
    {
        "url": "https://www.home-assistant.io/docs/energy/faq/#split-consumption-by-tariffs",
        "content": "It’s a common mistake to take Power as an Energy value, but the two are not alike. Energy is a quantitative measurement of what it takes to produce work (e.g. heat water) while Power measures the speed at which energy is transferred. Electrical Power is measured in Watts (W) and Electrical Energy is measured in kiloWatt-hour (kWh). Think of this in a parallel to speed and distance: Power is the speed you are going and Energy is the distance driven. Therefore Energy (kiloWatt-hour) is not an average of the Power you are consuming over a given period of time (the unit of the average power would be Watt or kiloWatt again). Energy is the integral (mathematical operation) of the Power function. This difference is very important as you need to use the proper entities in our Energy Panel. Since in Home Assistant, we don’t deal with Power functions but with samples of the power being used, we can’t do the integral (mathematical operation) directly and get the true amount of energy consumed/produced. That said, if you can sample Power values fast enough (every few seconds) you can reliably measure energy transferred through mathematic approximations called Riemann Sum. Home Assistant provides this mathematical operation through the integration. If you are using a 3rd party device (e.g. not reading directly from your utility meter device or from the utility provider cloud service) you need HA to split your energy measurements into 2 (or more) tariffs, in order to track these energy consumptions separately. To accomplish such, you can use the utility_meter integration. With this integration, you define as many tariffs as required (in accordance with your utility provider contract) and HA will be able to differentiate energy consumptions in each of the tariffs. Please note that each utility provider has its own time schedules for peak and off-peak and you are required to create an automation that switches the utility_meter entity from one tariff to the other. If you do not see the Energy panel in the sidebar, make sure you have not removed default_config: from your configuration.yaml. If you have, you will need to add the energy: integration manually. You are trying to add a sensor to the energy dashboard, but it does not appear in the selection list. To find out why the sensor is not showing, check the following points: The sensor must have the appropriate attributes. Check your entity attributes in Developer Tools > States to confirm the following: If any of the attributes are not correct, please open an issue against the integration that provides your sensor, or if you are developing custom template sensors, make sure the templates have the correct settings. The entity must be a sensor. If you are trying to add something from another domain (for example an input_number), then you must first create a template sensor from it. The entity must not have any statistics errors. Go to Developer Tools > Statistics to check your specific entity. If your unit has a listed issue here, you must fix the issue before it can be added to the dashboard."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/trigger/#sun-trigger",
        "content": "Triggers are what starts the processing of an automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] rule. When any of the automation’s triggers becomes true (trigger fires), Home Assistant will validate the conditions, if any, and call the action. An automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] can be triggered by an eventAn event is when something happens.[Learn more], a certain entityAn entity represents a sensor, actor, or function in Home Assistant. Entities are used to monitor physical properties or to control other entities. An entity is usually part of a device or a service.\n[Learn more] stateThe state holds the information of interest of an entity, for example, if a light is on or off. Each entity has exactly one state and the state only holds one value at a time. However, entities can store attributes related to that state such as brightness, color, or a unit of measurement.\n[Learn more], at a given time, and more. These can be specified directly or more flexible via templates. It is also possible to specify multiple triggers for one automation. All triggers can be assigned an optional id. If the ID is omitted, it will instead be set to the index of the trigger. The id can be referenced from trigger conditions and actions. The id does not have to be unique for each trigger, and it can be used to group similar triggers for use later in the automation (i.e., several triggers of different types that should all turn some entity on). This video tutorial explains how trigger IDs work.  There are two different types of variables available for triggers. Both work like script level variables. The first variant allows you to define variables that will be set when the trigger fires. The variables will be able to use templates and have access to the trigger variable. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger_variables key at an automation level. These variables can only contain limited templates. The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. Fires when an event is being received. Events are the raw building blocks of Home Assistant. You can match events on just the event name or also require specific event data or context to be present. Events can be fired by integrations or via the API. There is no limitation to the types. A list of built-in events can be found here. It is also possible to listen for multiple events at once. This is useful for\nevent that contain no, or similar, data and contexts. It’s also possible to use limited templates in the event_type, event_data and context options. The event_type, event_data and context templates are only evaluated when setting up the trigger, they will not be reevaluated for every event. Fires when Home Assistant starts up or shuts down. Automations triggered by the shutdown event have 20 seconds to run, after which they are stopped to continue with the shutdown. Fires when a specific message is received on given MQTT topic. Optionally can match on the payload being sent over the topic. The default payload encoding is ‘utf-8’. For images and other byte payloads use encoding: '' to disable payload decoding completely. The payload option can be combined with a value_template to process the message received on the given MQTT topic before matching it with the payload.\nThe trigger in the example below will trigger only when the message received on living_room/switch/ac is valid JSON, with a key state which has the value \"on\". It’s also possible to use limited templates in the topic and payload options. The topic and payload templates are only evaluated when setting up the trigger, they will not be re-evaluated for every incoming MQTT message. Fires when the numeric value of an entity’s state (or attribute’s value if using the attribute property, or the calculated value if using the value_template property) crosses a given threshold. On state change of a specified entity, attempts to parse the state as a number and fires if the value is changing from above to below or from below to above the given threshold. When the attribute option is specified the trigger is compared to the given attribute instead of the state of the entity. More dynamic and complex calculations can be done with value_template. Number helpers (input_number entities), number and sensor entities that\ncontain a numeric value, can be used in the above and below thresholds,\nmaking the trigger more dynamic, like: The for: can also be specified as HH:MM:SS like this: You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the state of any of given entities changes. If only entity_id is given, the trigger will fire for all state changes, even if only state attributes change.\nIf at least one of from, to, not_from, or not_to are given, the trigger will fire on any matching state change, but not if only attributes change. To trigger on all state changes, but not on changed attributes, set at least one of from, to, not_from, or not_to to null. The values you see in your overview will often not be the same as the actual state of the entity. For instance, the overview may show Connected when the underlying entity is actually on. You should check the state of the entity by looking in the States menu under Developer tools. It’s possible to give a list of from states or to states: Trigger on all state changes, but not attributes by setting to to null: The not_from and not_to options are the counter parts of from and to. They can be used to trigger on state changes that are not the specified state. This can be useful to trigger on all state changes, except specific ones. You cannot use from and not_from at the same time. The same applies to to and not_to. When the attribute option is specified, the trigger only fires\nwhen the specified attribute changes. Changes to other attributes or the\nstate are ignored. For example, this trigger only fires when the boiler has been heating for 10 minutes: This trigger fires whenever the boiler’s hvac_action attribute changes: You can use for to have the state trigger only fire if the state holds for some time. This example fires, when the entity state changed to \"on\" and holds that\nstate for 30 seconds: Please note, that when holding a state, changes to attributes are ignored and\ndo not cancel the hold time. You can also fire the trigger when the state value changed from a specific\nstate, but hasn’t returned to that state value for the specified time. This can be useful, e.g., checking if a media player hasn’t turned “off” for\nthe time specified, but doesn’t care about “playing” or “paused”. Please note, that when using from, to and for, only the value of the\nto option is considered for the time specified. In this example, the trigger fires if the state value of the entity remains the\nsame for for the time specified, regardless of the current state value. You can also use templates in the for option. The for template(s) will be evaluated when an entity changes as specified. Use quotes around your values for from and to to avoid the YAML parser from interpreting values as booleans. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. Fires when the sun is setting or rising, i.e., when the sun elevation reaches 0°. An optional time offset can be given to have it fire a set time before or after the sun event (e.g., 45 minutes before sunset). A negative value makes it fire before sunrise or sunset, a positive value afterwards. The offset needs to be specified in number of seconds, or in a hh:mm:ss format. Since the duration of twilight is different throughout the year, it is recommended to use sun elevation triggers instead of sunset or sunrise with a time offset to trigger automations during dusk or dawn. Sometimes you may want more granular control over an automation than simply sunset or sunrise and specify an exact elevation of the sun. This can be used to layer automations to occur as the sun lowers on the horizon or even after it is below the horizon. This is also useful when the “sunset” event is not dark enough outside and you would like the automation to run later at a precise solar angle instead of the time offset such as turning on exterior lighting. For most automations intended to run during dusk or dawn, a number between 0° and -6° is suitable; -4° is used in this example: If you want to get more precise, you can use this solar calculator, which will help you estimate what the solar elevation will be at any specific time. Then from this, you can select from the defined twilight numbers. Although the actual amount of light depends on weather, topography and land cover, they are defined as: Civil twilight: 0° > Solar angle > -6° This is what is meant by twilight for the average person: Under clear weather conditions, civil twilight approximates the limit at which solar illumination suffices for the human eye to clearly distinguish terrestrial objects. Enough illumination renders artificial sources unnecessary for most outdoor activities. Nautical twilight: -6° > Solar angle > -12° Astronomical twilight: -12° > Solar angle > -18° A very thorough explanation of this is available in the Wikipedia article about the Twilight. Fires when a tag is scanned. For example, a NFC tag is\nscanned using the Home Assistant Companion mobile application. Additionally, you can also only trigger if a card is scanned by a specific\ndevice/scanner by setting the device_id: Or trigger on multiple possible devices for multiple tags: Template triggers work by evaluating a template when any of the recognized entities change state. The trigger will fire if the state change caused the template to render ‘true’ (a non-zero number or any of the strings true, yes, on, enable) when it was previously ‘false’ (anything else). This is achieved by having the template result in a true boolean expression (for example {{ is_state('device_tracker.paulus', 'home') }}) or by having the template render true (example below). With template triggers you can also evaluate attribute changes by using is_state_attr (like {{ is_state_attr('climate.living_room', 'away_mode', 'off') }}) You can also use templates in the for option. The for template(s) will be evaluated when the value_template becomes ‘true’. Templates that do not contain an entity will be rendered once per minute. Use of the for option will not survive Home Assistant restart or the reload of automations. During restart or reload, automations that were awaiting for the trigger to pass, are reset. If for your use case this is undesired, you could consider using the automation to set an input_datetime to the desired time and then use that input_datetime as an automation trigger to perform the desired actions at the set time. The time trigger is configured to fire once a day at a specific time, or at a specific time on a specific date. There are three allowed formats: A string that represents a time to fire on each day. Can be specified as HH:MM or HH:MM:SS. If the seconds are not specified, :00 will be used. The entity ID of an input datetime. The Entity ID of a sensor with the “timestamp” device class. Multiple times can be provided in a list. Both formats can be intermixed. With the time pattern trigger, you can match if the hour, minute or second of the current time matches a specific value. You can prefix the value with a / to match whenever the value is divisible by that number. You can specify * to match any value (when using the web interface this is required, the fields cannot be left empty). Do not prefix numbers with a zero - using '01' instead of '1' for example will result in errors. Persistent notification triggers are fired when a persistent_notification is added or removed that matches the configuration options. See the Persistent Notification integration for more details on event triggers and the additional event data available for use by an automation. Webhook trigger fires when a web request is made to the webhook endpoint: /api/webhook/<webhook_id>. The webhook endpoint is created automatically when you set it as the webhook_id in an automation trigger. You can run this automation by sending an HTTP POST request to http://your-home-assistant:8123/api/webhook/some_hook_id. Here is an example using the curl command line program, with an example form data payload: Webhooks support HTTP POST, PUT, HEAD, and GET requests; PUT requests are recommended. HTTP GET and HEAD requests are not enabled by default but can be enabled by adding them to the allowed_methods option. The request methods can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. By default, webhook triggers can only be accessed from devices on the same network as Home Assistant or via Nabu Casa Cloud webhooks. The local_only option should be set to false to allow webhooks to be triggered directly via the internet. This option can also be configured in the UI by clicking the settings gear menu button beside the Webhook ID. Remember to use an HTTPS URL if you’ve secured your Home Assistant installation with SSL/TLS. Note that a given webhook can only be used in one automation at a time. That is, only one automation trigger can use a specific webhook ID. Payloads may either be encoded as form data or JSON. Depending on that, its data will be available in an automation template as either trigger.data or trigger.json. URL query parameters are also available in the template as trigger.query. Note that to use JSON encoded payloads, the Content-Type header must be set to application/json, e.g.: Webhook endpoints don’t require authentication, other than knowing a valid webhook ID. Security best practices for webhooks include: Zone trigger fires when an entity is entering or leaving the zone. The entity can be either a person, or a device_tracker. For zone automation to work, you need to have setup a device tracker platform that supports reporting GPS coordinates. This includes GPS Logger, the OwnTracks platform and the iCloud platform. Geolocation trigger fires when an entity is appearing in or disappearing from a zone. Entities that are created by a Geolocation platform support reporting GPS coordinates.\nBecause entities are generated and removed by these platforms automatically, the entity ID normally cannot be predicted. Instead, this trigger requires the definition of a source, which is directly linked to one of the Geolocation platforms. This isn’t for use with device_tracker entities. For those look above at the zone trigger. Device triggers encompass a set of events that are defined by an integration. This includes, for example, state changes of sensors as well as button events from remotes.\nMQTT device triggers are set up through autodiscovery. In contrast to state triggers, device triggers are tied to a device and not necessarily an entity.\nTo use a device trigger, set up an automation through the browser frontend.\nIf you would like to use a device trigger for an automation that is not managed through the browser frontend, you can copy the YAML from the trigger widget in the frontend and paste it into your automation’s trigger list. Calendar trigger fires when a Calendar event starts or ends, allowing\nfor much more flexible automations than using the Calendar entity state which only supports a single\nevent start at a time. An optional time offset can be given to have it fire a set time before or after the calendar event (e.g., 5 minutes before event start). See the Calendar integration for more details on event triggers and the\nadditional event data available for use by an automation. A sentence trigger fires when Assist matches a sentence from a voice assistant using the default conversation agent. Sentence triggers only work with Home Assistant Assist. External conversation agents such as OpenAI or Google Generative AI cannot be used to trigger automations. Sentences are allowed to use some basic template syntax like optional and alternative words. For example, [it's ]party time will match both “party time” and “it’s party time”. The sentences matched by this trigger will be: Punctuation and casing are ignored, so “It’s PARTY TIME!!!” will also match. Adding one or more {lists} to your trigger sentences will capture any text at that point in the sentence. A slots object will be available in the trigger data.\nThis allows you to match sentences with variable parts, such as album/artist names or a description of a picture. For example, the sentence play {album} by {artist} will match “play the white album by the beatles” and have the following variables available in the action templates: Wildcards will match as much text as possible, which may lead to surprises: “play day by day by taken by trees” will match album as “day” and artist as “day by taken by trees”.\nIncluding extra words in your template can help: play {album} by artist {artist} can now correctly match “play day by day by artist taken by trees”. It is possible to specify multiple triggers for the same rule. To do so just prefix the first line of each trigger with a dash (-) and indent the next lines accordingly. Whenever one of the triggers fires, processing of your automation rule begins. It is possible to specify multiple entities for the same trigger. To do so add multiple entities using a nested list. The trigger will fire and start, processing your automation each time the trigger is true for any entity listed. Every individual trigger in an automation can be disabled, without removing it.\nTo do so, add enabled: false to the trigger. For example:"
    },
    {
        "url": "https://www.home-assistant.io/docs/authentication/multi-factor-auth/",
        "content": "The Multi-factor Authentication (MFA) modules require you to solve a second challenge after you provide your password. A password can be compromised in a number of ways, for example, it can be guessed if it is a simple password. MFA provides a second level of defense by requiring: You can use MFA with any of the other authentication providers. If more than one MFA module is enabled, you can choose one when you log in. You can turn MFA on and off in the profile page for your user account. Time-based One-Time Password (TOTP) is widely adopted in modern authentication systems. Home Assistant generates a secret key which is synchronized with an app on your phone. Every thirty seconds or so the phone app generates a random six digit number. Because Home Assistant knows the secret key, it knows which number will be generated. If you enter the correct digits, then you’re in. Enable TOTP in your configuration.yaml like this: If no auth_mfa_modules configuration section is defined in configuration.yaml a TOTP module named “Authenticator app” will be autoloaded. You will need an authenticator app on your phone. We recommend either Google Authenticator or Authy. Both are available for iOS or Android. After restarting Home Assistant, go to your Profile and there should be a “Multi-factor Authentication Modules” section. Click Enable and a new secret key will be generated. Go to your phone app and enter the key, either by scanning the QR code or typing in the key below the QR code manually. Your phone app will now start generating a different six-digit code every thirty seconds or so. Enter one of these into Home Assistant under the QR code where it asks for a Code. Home Assistant and your phone app are now in sync and you can now use the code displayed in the app to log in. Once TOTP is enabled, Home Assistant requires the latest code from your phone app before you can log in. TOTP is time based so it relies on your Home Assistant clock being accurate. If the verification keeps failing, make sure the clock on Home Assistant is correct. The Notify MFA module uses the notify integration to send you an HMAC-based One-Time Password. It is typically sent to your phone, but can be sent to any destination supported by a notify service. You use this password to log in. Add Notify MFA to your configuration.yaml file like this: The list of notifying service entities you want to exclude. The list of notifying service entities you want to include. The message template. After restarting Home Assistant, go to your Profile and there should be a “Multi-factor Authentication Modules” section. Click Enable on the Notify One-Time Password option. Try logging out, then logging in again. You will be asked for the six-digit one-time password that was sent to your notify service. Enter the password to log in. If the validation failed, a new one-time password will be sent again. The Notify MFA module can’t tell if the one-time password was delivered successfully. If you don’t get the notification, you won’t be able to log in. You can disable the Notify MFA module by editing or removing the file [your_config_dir]/.storage/auth_module.notify."
    },
    {
        "url": "https://www.home-assistant.io/docs/configuration/packages/",
        "content": "Packages in Home Assistant provide a way to bundle different integration’s configuration together. With packages we have a way to include different integrations, or different configuration parts using any of the !include directives introduced in splitting the configuration. Packages are configured under the core homeassistant/packages in the configuration and take the format of a package name (no spaces, all lower case) followed by a dictionary with the package configuration. For example, package pack_1 would be created as: The package configuration can include: switch, light, automation, groups, or most other Home Assistant integrations including hardware platforms. It can be specified inline or in a separate YAML file using !include. Inline example, main configuration.yaml: Include example, main configuration.yaml: The file my_package.yaml contains the “top-level” configuration: There are some rules for packages that will be merged: Platform based integrations (light, switch, etc) can always be merged. Integrations where entities are identified by a key that will represent the entity_id ({key: config}) need to have unique ‘keys’ between packages and the main configuration file. For example if we have the following in the main configuration. You are not allowed to re-use “my_input” again for input_boolean in a package: Any integration that is not a platform [1], or dictionaries with Entity ID keys [2] can only be merged if its keys, except those for lists, are solely defined once. One way to organize packages is to create a folder named “packages” in your Home Assistant configuration directory. In the packages directory, you can store any number of packages in a YAML file. This entry in your configuration.yaml will load all YAML-files in this packages folder and its subfolders: The benefit of this approach is to pull all configurations required to integrate a system into one file—rather than keeping them spread across several files.\nYou can use other !include methods for packages; for example !include_dir_merge_named. However, unlike !include_dir_merge_named, the !include_dir_named method uses the same indentation as the ‘configuration.yaml’. This means that you can copy and paste elements from the config file. With !include_dir_named, the file name is used as the package name. File names must be unique. With the !include_dir_merge_named method, the package name has to be included in the file. The configuration below then needs to be indented accordingly. This means you cannot directly copy and paste from the configuration file. and in packages/subsystem1/functionality1.yaml: It is possible to customize entities within packages. Just create your customization entries under: If you are moving configuration to packages, auth_providers must stay within ‘configuration.yaml’. See the general documentation for Authentication Providers. This is because Home Assistant processes the authentication provided early in the start-up process, even before packages are processed."
    },
    {
        "url": "https://www.home-assistant.io/docs/backend/database/",
        "content": "Home Assistant uses databases to store eventsAn event is when something happens.[Learn more] and parameters for history and tracking. The default database used is SQLite and the database file is stored in your configuration directory (e.g., <path to config dir>/home-assistant_v2.db); however, other databases can be used. If you prefer to run a database server (e.g., PostgreSQL), use the recorder integration. To work with SQLite database manually from the command-line, you will need an installation of sqlite3. Alternatively DB Browser for SQLite provides a viewer for exploring the database data and an editor for executing SQL commands.\nFirst load your database with sqlite3: It helps to set some options to make the output more readable: You could also start sqlite3 and attach the database later. Not sure what database you are working with? Check it, especially if you are going to delete data. Get all available tables from your current Home Assistant database: To only show the details about the states table (since we are using that one in the next examples): The identification of the available columns in the table is done and we are now able to create a query. Let’s list your Top 10 entities: If you don’t want to keep certain entities, you can delete them permanently by using the services provided by the recorder. For a more interactive way of working with the database, check the Data Science Portal."
    },
    {
        "url": "https://www.home-assistant.io/docs/automation/templating/#available-trigger-data",
        "content": "Automations support templating in the same way as scripts do. In addition to the Home Assistant template extensions available to scripts, the trigger and this template variables are available. The template variable this is also available when evaluating any trigger_variables declared in the configuration. The variable this is the state object of the automation at the moment of triggering the actions. State objects also contain context data which can be used to identify the user that caused a scriptScripts are components that allow users to specify a sequence of actions to be executed by Home Assistant when turned on.\n[Learn more] or automationAutomations in Home Assistant allow you to automatically respond to things that happen in and around your home.[Learn more] to execute. Note that this will not change while executing the actionsActions are used in several places in Home Assistant. As part of a script or automation, actions define what is going to happen once a trigger is activated. In scripts, an action is called sequence.\n[Learn more]. The variable trigger is an object that contains details about which triggerA trigger is a set of values or conditions of a platform that are defined to cause an automation to run.[Learn more] triggered the automation. Templates can use the data to modify the actions performed by the automation or displayed in a message. For example, you could create an automation that multiple sensors can trigger and then use the sensor’s location to specify a light to activate; or you could send a notification containing the friendly name of the sensor that triggered it. Each trigger platform can include additional data specific to that platform. Triggers from all platforms will include the following data. These are the properties available for a Calendar trigger. These are the properties available for a Device trigger. Inherites template variables from event or state template based on the type of trigger selected for the device. These are the properties available for a Event trigger. These are the properties available for a MQTT trigger. These are the properties available for a numeric state trigger. These are the properties available for a Sentence trigger. These are the properties available for a State trigger. These are the properties available for a Sun trigger. These are the properties available for a Template trigger. These are the properties available for a Time trigger. These are the properties available for a time pattern trigger. These properties are available for a persistent notification trigger. These are the properties available for a Webhook trigger. These are the properties available for a Zone trigger."
    }
]